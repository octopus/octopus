! $Id$
!

#include "global.h"

      module crystal

      use global
      use messages
      use io
      use units
      use lib_adv_alg
      use math
      use blas

      implicit none

      FLOAT, allocatable :: xk(:,:)
      integer, allocatable :: kmap(:)

      integer :: ntrans, gmtrx(48,3,3)
      integer :: rmtrx(48,3,3)
      FLOAT :: tnp(48,3),   &
                  trans(3,3,48) !rotation matrices in cartesian coordinates

      FLOAT, private :: a(3,3)    ! lattice vectors in cart. coord.
      FLOAT, private :: amet(3,3) ! adot(i,j) = a_i dot a_j
      FLOAT, private :: b(3,3)    ! reciprocal lattice vectors
      FLOAT, private :: bmet(3,3) ! b_i dot b_k for reciprocal lattice vectors

!      FLOAT, private :: volume_check, xdum
      integer, private ::  i, j, k, l! ,m , ierr

      FLOAT :: tnpi(3), xmt(3,3)
      character(len=1) :: i1(3)
      character(len=5) :: nametr(3)


!   subroutines internal to this module

      private invers
      private crystal_monkpack
      private crystal_symgen
      private crystal_symchk
      private symm_ident
      private atftmt
      private pgl
      private rot
      private rlv

      contains

      subroutine crystal_init(al,ntype,natom,maxnatom,coorat,    &
                              nk_axis,k_shift,nrk,rk,w)

      integer  :: nx,ny,nz,nrk,ntype,maxnatom,nk_axis(3)
      integer  :: natom(ntype)
      FLOAT :: sx,sy,sz,k_shift(3)
      FLOAT :: rk(3,*), w(*) , al(3,3)
      FLOAT :: coorat(ntype,maxnatom,3)

! Local

      integer  :: ipr, invers_no, jabs, jcar, neg
      FLOAT :: volume_check, celvol, ek, ek1, ek2
      FLOAT :: a1(3),a2(3),a3(3),am(3),      &
                       b1(3), b2(3), b3(3), ba(3),   &
                       rkcar(3),rkmod(3,4)
!      FLOAT :: scale
!      character(len=1) :: np
!      logical :: vol_input

      call push_sub('crystal.crystal_init')

!  now only for cubic crystls..will be made general later on

      a = al
      nx = nk_axis(1)
      ny = nk_axis(2)
      nz = nk_axis(3)
      sx = k_shift(1)
      sy = k_shift(2)
      sz = k_shift(3)


!      compute reciprocal lattice and reset scales.
!               T                       T        -1          T -1
!              B A  = 2pi (1), so b =  B  = 2pi(A  )  = 2pi(a )
!     and we can compute the determinant (celvol) and the inverse.
!     But note that the 2pi factor is NOT needed here yet. (It
!     will be put in below)

      b = transpose(a)

      call invers(b,volume_check)
      if (volume_check < M_ZERO) then
        message(1) = 'Note: The lattice vectors as given do not form a direct triad'
        call write_warning(1)
        volume_check = - volume_check
      endif

      celvol = volume_check

      write(message(1), '(a15,f10.4,a)')'CRYSTAL: cell volume = ', &
            celvol/units_out%length%factor**3,'['//trim(units_out%length%abbrev)//'^3]'
      call write_info(1)

!     compute the inner products ba, put in the 2pi factor and clean up.

      do i = 1, 3
        a1(i) = a(i,1)
        a2(i) = a(i,2)
        a3(i) = a(i,3)
        b(i,:) = M_TWO*M_PI*b(i,:)
      end do

      am(1) = sqrt(sum(a1(:)**2))
      am(2) = sqrt(sum(a2(:)**2))
      am(3) = sqrt(sum(a3(:)**2))

      ba(:) = M_TWO*M_PI/am(:)
      b1(:) = b(:,1)
      b2(:) = b(:,2)
      b3(:) = b(:,3)

!     compute metrics bmet(i,j) and amet(i,j)

      do i = 1, 3
        do j = i, 3
          bmet(i,j) = 0
          amet(i,j) = 0
          do k = 1, 3
            bmet(i,j) = bmet(i,j) + b(k,i)*b(k,j)
            amet(i,j) = amet(i,j) + a(k,i)*a(k,j)
          end do
          if (i /= j) then
            bmet(j,i) = bmet(i,j)
            amet(j,i) = amet(i,j)
          end if
         end do
      end do

!      printout

      message(1) = 'CRYSTAL: lattice vectors ['//trim(units_out%length%abbrev)//']'
      write(message(2), '(a,3(f10.5,1x))') 'a1 = ',a1/units_out%length%factor
      write(message(3), '(a,3(f10.5,1x))') 'a2 = ',a2/units_out%length%factor
      write(message(4), '(a,3(f10.5,1x))') 'a3 = ',a3/units_out%length%factor
      call write_info(4)
      message(1) = 'CRYSTAL: reciprocal basis ['//trim(units_out%length%abbrev)//']'
      write(message(2), '(a,3(f10.5,1x))') 'b1 = ',b1*units_out%length%factor
      write(message(3), '(a,3(f10.5,1x))') 'b2 = ',b2*units_out%length%factor
      write(message(4), '(a,3(f10.5,1x))') 'b3 = ',b3*units_out%length%factor
      call write_info(4)


!      write(6,9140) b1, b2, b3
! 9140 format(/' reciprocal basis (Ang)',/3(/1x,3f10.5))
      write(6,9150) ((amet(i,j),j=1,3),i=1,3)
 9150 format(/' direct space metrix (some units)',/3(/1x,3f10.5))
      write(6,9160) ((bmet(i,j),j=1,3),i=1,3)
 9160 format(/' reciprocal space metrix (some units)',/3(/1x,3f10.5))

! generate symmetries operation

      ipr = 1
      call crystal_symgen(ipr,a,coorat,natom,maxnatom,ntype,invers_no)

!  k-points are generated by the MP scheme

      allocate(xk(3,nx*ny*nz),kmap(nx*ny*nz))

      call crystal_monkpack(nx,ny,nz,sx,sy,sz,nrk,rk,w,.false.)

      message(1) =' ikp       weight             kpoint (relative)                kpoint (absolute)'
      call write_info(1)

      do 120 i = 1, nrk

         do j = 1, 4
           rkmod(:,j) = rk(:,i)
            end do
         rkmod(1,2) = rkmod(1,2) - M_ONE
         rkmod(2,3) = rkmod(2,3) - M_ONE
         rkmod(3,4) = rkmod(3,4) - M_ONE
         ek = CNST(2000.0)
         do j = 1, 4
            ek1 = M_ZERO
            ek2 = M_ZERO
            do k = 1, 3
               do l = 1, 3
                  ek1 = ek1 + rkmod(k,j)*bmet(k,l)*rkmod(l,j)
                  ek2 = ek2 + (rkmod(k,j)-M_ONE)*bmet(k,l)* (rkmod(l,j)-M_ONE)
               end do
            end do
            if (ek1 < ek) then
               ek = ek1
               jcar = j
            end if
            if (ek2 < ek) then
               ek = ek2
               jcar = -j
            end if
          end do

!      rk in cartesian coordinates

         neg = 0
         do k = 1, 3
            jabs = abs(jcar)
            rkcar(k) = b1(k)*rkmod(1,jabs) + b2(k)*rkmod(2,jabs) + b3(k)*rkmod(3,jabs)
            if (jcar < 0) rkcar(k) = rkcar(k) - b1(k) - b2(k) - b3(k)
            if (rkcar(k) < M_ZERO) neg = neg + 1
         end do
         if (neg <= 1) neg = 1
         if (neg > 1) neg = -1

!      printout

!        write(message(1),'(i4,3x,f10.6,3x,3f10.6,3x,3f10.6)') &
!              i,w(i),(rk(j,i),j=1,3), (R_REAL(neg)*rkcar(j),j=1,3)
!        call write_info(1)
       write(6,9060)i,w(i),(rk(j,i),j=1,3), (R_REAL(neg)*rkcar(j),j=1,3)
9060  format(i4,3x,f10.6,3x,3f10.6,3x,3f10.6)

  120 continue

!        write(message(1),'(//1x,i3,a,/1x,51('-'),//4x,a3,3i5,6x,a3,3f6.2,//)') &
!             nrk,' k points generated by program from parameters :', &
!             'n =',nx, ny, nz,'s =',sx, sy, sz
!        call write_info(1)

      write(6,9070) nrk, nx, ny, nz, sx, sy, sz
 9070 format(//1x,i3,' k points generated by program from',               &
            ' parameters :',/1x,51('-'),//4x,'n =',3i5,6x,'s =',3f6.2,//)

      deallocate(xk,kmap)

        call pop_sub()
      end subroutine crystal_init

      subroutine invers(mat,determinant)
        ! Compute the inverse of a 3x3 matrix (in situ) and its determinant
        FLOAT :: mat(3,3), determinant

        determinant = lalg_inverter(3, mat, invert = .true., symmetric = .true.)

      return
      end subroutine invers


      subroutine crystal_monkpack(nx,ny,nz,sx,sy,sz,nrk,rk,w,need_gw)

      implicit none

!      Implements the Monkhorst-Pack scheme.

!      Sets up uniform array of k points. Use the normal MP scheme
!      (PRB13, 5188, (1976)) when sx=sy=sz=0.5. If sx=sy=0,
!      the special hexagonal scheme is used (PRB16, 1748, (1977))

!     .. Scalar Arguments ..
       FLOAT :: sx, sy, sz
       integer nrk, nx, ny, nz

!     .. Array Arguments ..
      FLOAT :: rk(3,*), w(*)

!     .. Local Scalars ..
      FLOAT :: dw, dx, dy, dz !, xdum
      integer i, j, k, l, n
!      integer km, kp, kdel, jm, jp, ip, irk, im
!      character tmny_kpnts*80 , wkarr_ovfw*80
      logical need_gw

!     .. Local Arrays ..

      FLOAT :: rktran(3), rktran_inv(3)

!     .. Intrinsic Functions ..
      intrinsic abs

      call push_sub('crystal.crystal_monkpack')

!      nx, ny, and nz are the number of points in the three
!      directions dermined by the lattice wave vectors. sx, sy, and
!      sz shift the grid of integration points from the origin.
!
!      kmap is used to mark reducible k points and also to
!      map reducible to irreducible k points

      dx = M_ONE/R_REAL(nx)
      dy = M_ONE/R_REAL(ny)
      dz = M_ONE/R_REAL(nz)
      n = 0
      do i = 1, nx
        do j = 1, ny
          do k = 1, nz
               n = n + 1
            xk(1,n) = (R_REAL(i-1) + sx)*dx
            xk(2,n) = (R_REAL(j-1) + sy)*dy
            xk(3,n) = (R_REAL(k-1) + sz)*dz
               kmap(n) = n
         end do
        end do
       end do

!      reduce to irreducible zone

      dw = M_ONE/R_REAL(n)
      nrk = 0
      do 120 i = 1, n
         if (kmap(i) /= i) go to 120

!      new irreducible point
!      mark with negative kmap

         nrk = nrk + 1
         do j = 1, 3
            rk(j,nrk) = xk(j,i)
         end do
         kmap(i) = -nrk
         w(nrk) = dw
         if (i == n) go to 120
!ang         goto 120

!      operate on irreducible rk with the symmetry operations
!
         do 110 j = 1, ntrans
           do k = 1, 3
             rktran(k) = M_ZERO
             do l = 1, 3
                  rktran(k) = gmtrx(j,k,l)*rk(l,nrk) + rktran(k)
             end do

!      translate to interval 0-1 and compute its inverse for
!      later use. (built as reduce_01(-rk)). This
!          fixes a bug when rktran(l)=0 (first reported by
!          Mike Surh, March 1992)
!
               rktran(k) = reduce_01(rktran(k))
               rktran_inv(k) = reduce_01(-rktran(k))
           end do

!      remove (mark) k points related to irreducible rk by symmetry

            do 100 k = i + 1, n
             if (kmap(k) /= k) go to 100

!      both the transformed rk ...

             do l = 1, 3
                if (abs(rktran(l)-xk(l,k)) > CNST(1.0e-5)) go to 80
             end do
               w(nrk) = w(nrk) + dw
               kmap(k) = nrk

               go to 100

!      ... and its inverse (see construction above)
!ar        do not use in GW calculations!!

   80          continue
         if (need_gw) go to 100
           do l = 1, 3
              if (abs(rktran_inv(l)-xk(l,k) )> CNST(1.0e-5)) go to 100
           end do
               w(nrk) = w(nrk) + dw
               kmap(k) = nrk
  100       continue
  110    continue
  120 continue


      return

      call pop_sub()
      end subroutine crystal_monkpack

      FLOAT function reduce_01(x)
!     Reduces x to its appropriate equivalent in [0,1)
!     It works for -500 < x < infinity...
!     A function that works for all x is: mod(mod(x,1)+1,1), but it
!     involves two mods...

      FLOAT :: x

      reduce_01 = mod(x+CNST(500.0), M_ONE)

      end function reduce_01


      subroutine crystal_symgen(ipr, a,coorat,natom,maxnatom,ntype,invers_no)

      implicit none

      integer :: ipr        ! ipr=1 print

!     This is the driver routine to generate the symmetry
!     operations.
!
!     Adapted by J.L. Martins from the program GROUP
!     written in 1974 by Warren and Worlton
!     Computer Physics Communications, vol 8, 71-74 (1974)
!     incorporated by Eckold et al into UNISOFT.
!     Modified by Alberto Garcia (1990)
!
!     Let us see if we can get the rotations both in real and
!     in reciprocal space:
!
!     gmtrx : g-space representation
!     rmtrx: r-space representation
!
!     Input:
!
!     a(i,j) is the i-th cartesian component of the j-th primitive
!     translation vector of the direct lattice and thus it is the
!     transpose of the matrix A defined by Jones in The Theory
!     of Brillouin Zones and Electronic States in Crystals
!
!     coorat(i,j,k) is the k-th component (lattice coordinates) of
!     the position of the j-th atom of type i.
!
!     natom(i) is the number of atoms of type i.
!
!     ntype is the total number of types of atoms.
!
!     internal:
!
!     b contains the reciprocal lattice vectors in the
!     crystallographic usage, that is, WITHOUT the 2pi factor.
!     This matrix IS Jones.
!
!     na is the number of atoms.
!
!     ity(i) is an integer distinguishing atoms of different type
!     i.e. different atomic species.
!
!     x(j,i) is the j-th cartesian component of the position vector for
!     the i-th atom in the unit cell.
!
!     output:
!
!     ntrans is the number of point group operations.
!
!     gmtrx is the matrix of rotations in g-lattice coordinates.
!     rmtrx is the matrix of rotations in r-lattice coordinates.
!
!     tnp(oper,ilat) is the fractional translation in latt. coor.
!
!     invers_no is the operation number of the inversion (0 if not
!     present). It is used to restore the inversion symmetry by
!     a simple change of origin when possible
!
!     .. Scalar Arguments ..
      integer :: ntype, invers_no,  maxnatom
!     ..
!     .. Array Arguments ..
      FLOAT :: a(3,3), coorat(ntype,maxnatom,3)
      integer :: natom(ntype)
!     ..
!     .. Local Scalars ..
      FLOAT :: xdum
      integer :: i, ihg, ind, ipm, j, k, l, li, m, na, nat !,ierr
!     ..
!     .. Local Arrays ..
      FLOAT :: b(3,3), r(49,3,3), r1(3,3), rlat(48,3,3)


      FLOAT, allocatable :: x(:,:)
      integer, allocatable :: ity(:)


      integer :: ib(48)
      character :: id(48)*10
!     ..
!     .. Intrinsic Functions ..
!      intrinsic :: int, mod
!     ..

      call push_sub('crystal.crystal_symgen')

      ipm = 0

      allocate(x(3,ntype*maxnatom))
      allocate(ity(ntype*maxnatom))


!
!     Calculate cartesian coordinates, atom types, and number of atoms.
!
      na = 0
      do i = 1, ntype
         nat = natom(i)
        do j = 1, nat
            ind = na + j
          do k = 1, 3
            x(k,ind) = M_ZERO
             do l = 1, 3
                  x(k,ind) = x(k,ind) + a(k,l)*coorat(i,j,l)
             end do
          end do
            ity(ind) = i
         end do
         na = na + natom(i)
       end do

!     Determine reciprocal lattice basis vectors.
!     We know that
!
!               T                             T -1         -1
!              B A  = 2pi (1), so   B  = 2pi(A )   = 2pi(a )
!
!     and we can use the linpack (SCILIB version) routines
!     sgefa and sgedi to
!     compute the determinant (celvol) and the inverse.
!     But note that the 2pi factor is NOT needed here.
!
      b=a

      call invers(b,xdum)
      call pgl(a,b,r,ntrans,ib,ihg)

!     Subroutine pgl determines the point group of the lattice and the
!     crystal system. The array ib contains the locations of the group
!     operations and ntrans is the order of the group.
!
      call atftmt(ipr,b,x,r,ity,na,ib,ihg,ipm,li,ntrans,     &
           invers_no, ntype, maxnatom)
!
!     Subroutine atftmt determines the point group of the crystal,
!     the atom transformation table f0, the fractional translations
!     tnp associated with each rotation and the multiplication
!     table mt for the point group of the crystal. The array ib now
!     contains operations in the point group of the crystal and ntrans
!     is the order of this group.
!
!     if(li>0) write(6,180)
! 180 format (5x,'the point group of the crystal contains the',
!    1' inversion, therefore,',/,5x,'time reversal invariance will',
!    2' be invoked for all wave vectors.')
!
!     We have the rotations in cartesian coordinates.
!     Transform into lattice coordinates (r-space and g-space)
!
         do l = 1, ntrans
!
!           In terms of the real-space basis vectors:
!                      T
!              y^prime = ( B R a ) y     ( y are the r-lattice coord.)
!
!                              T
!              watch out: b = B
!
!           Trans * a ...
!
            do j = 1, 3
              do k = 1, 3
                r1(j,k) = M_ZERO
                do m = 1, 3
                     r1(j,k) = r1(j,k) + trans(m,j,l)*a(m,k)
                end do
              end do
            end do
!
!           B * Trans * a
!
            do j = 1, 3
              do k = 1, 3
                rlat(l,j,k) = M_ZERO
                do m = 1, 3
                     rlat(l,j,k) = rlat(l,j,k) + b(j,m)*r1(m,k)
                end do
                  rmtrx(l,j,k) = nint(rlat(l,j,k))
              end do
            end do
          end do
!
!        Identify the symmetry operations
!
         call symm_ident(ntrans,rmtrx,tnp,id)
!
!
         do l = 1, ntrans
!
!           In terms of the g-space basis vectors:
!                      T  T
!              z^prime = ( a  R  b ) z    ( z are the g-lattice coord.)
!
            do k=1,3
               gmtrx(l,:,k)=rmtrx(l,k,:)
            end do
         end do

!
!       write the matrices and fractional translations
!
         if(ipr == 1) then
            write(6,9000)
 9000       format(///4x,'Rotation matrices (r-lattice) and fractional', &
            ' translations (r-lattice)',//)
!
            do i = 1, ntrans
               write(6,9010) i, ((rmtrx(i,j,k),k=1,3),j=1,3),           &
                    (tnp(i,k),k=1,3), id(i)
!
            end do
 9010       format(i5,3(3x,3i3),4x,3f9.5,1x,a5)

            write(6,*) ' skipping symmetry check!'
         endif
!      call crystal_symchk(ipr,ierr,ntrans,rmtrx,tnp,1)
!      call crystal_symchk(ipr,ierr,ntrans,gmtrx,tnp,0)

         deallocate(x)
         deallocate(ity)

      return

      call pop_sub()
      end subroutine crystal_symgen

      subroutine crystal_symchk(ipr,ierr,ntrans,mtrx,tnp,flag)

!     crystal_symchk checks if the symmetry operations defined by
!     mtrx and tnp really forms a group.
!
!     Jan 7, 1990: AG/ 2pi factor removed ! /
!
!
! Out  ierr                returns 0 if no error, otherwise it returns
!                          the number of the suspected operation.
!
! Inp  flag                0 for g-space check, 1 for r-space check
!
      integer :: ierr, ntrans, flag, ipr
      FLOAT :: tnp(48,3)
      integer :: mtrx(48,3,3)
      integer :: mult(48,48), nerr(48)
!     ..
!     .. Local Scalars ..
      FLOAT :: ttest
      integer :: i, im, itest, j, k, l, m, maxerr
      character(len=80) ::  not_a_grp
      integer :: mtest(3,3)

!     .. Intrinsic Functions ..
!      intrinsic :: abs, dble !, atan
!     ..
!     .. Common blocks ..
      common mult, nerr

      not_a_grp = 'The symmetry operations' //                   &
                 ' do not form a group. Check operation no%i4$'

      call push_sub('crystal.crystal_symchk')

!
!      check for duplicate operations
!
      if (ntrans == 1) return
      do i = 2, ntrans
         im = i - 1
         do 30 j = 1, im
          do k = 1, 3
            if (abs(tnp(i,k)-tnp(j,k)) > CNST(1.e-8)) go to 30
               do l = 1, 3
                if (mtrx(i,k,l) /= mtrx(j,k,l)) go to 30
              end do
            end do
            if(ipr == 1) then
!            write(message(1),'(/,a20,i3,a4,i3,a10)')  &
!                 ' symmetry operations',j,' and',i,' are equal'
!            call write_info(1)
               write(6,9000) j, i
            endif
 9000       format(/' symmetry operations',i3,' and',i3,' are equal')
            ierr = i
            write(message(1),'(a)')not_a_grp
            call write_fatal(1)

            return
   30    continue
      end do
!
!      construct muliplication table
!
      do 120 i = 1, ntrans
         nerr(i) = 0
         do 110 j = 1, ntrans
            mult(i,j) = 0
!
!      mulitiply i and j
!
            do k = 1, 3
              do l = 1, 3
                  mtest(k,l) = 0
                do m = 1, 3
                     mtest(k,l) = mtest(k,l) + mtrx(i,k,m)*mtrx(j,m,l)
                end do
              end do
            end do
!
!      check for match
!
            do 100 k = 1, ntrans
               do l = 1, 3
                  do m = 1, 3
                    if (mtest(l,m) /= mtrx(k,l,m)) go to 100
                  end do
                end do
               mult(i,j) = k
  100       continue
  110    continue
  120 continue
!
!      if translations not correct set mult(i,j) to -1
!
      if (flag==0) then
!
         if(ipr == 1) then
         message(1) = 'Checking in g-space'
         call write_info(1)
         endif
      do i = 1, ntrans
         do 150 j = 1, ntrans
            k = mult(i,j)
            if (k == 0) go to 150
            do 140 l = 1, 3
               ttest = tnp(j,l)
               do m = 1, 3
                  ttest = ttest + R_REAL(mtrx(i,m,l))*(tnp(i,m)-tnp(k,m))
               end do
               ttest = abs(ttest)
               itest = nint(ttest)
               if (abs(ttest-R_REAL(itest)) < CNST(1.e-4)) go to 140
!     if (abs(ttest-R_REAL(itest)) < CNST(1.e-6)) go to 140
               write(6,*) i,j,l,abs(ttest-R_REAL(itest))
               mult(i,j) = -1
!
               go to 150
!
  140       continue
  150    continue
      end do
!
      else
!
         if(ipr == 1) then
           message(1) = 'Checking in r-space'
           call write_info(1)
         endif
      do i = 1, ntrans
         do 550 j = 1, ntrans
            k = mult(i,j)
            if (k == 0) go to 550
            do 540 l = 1, 3
               ttest = tnp(i,l) - tnp(k,l)
               do m = 1, 3
                  ttest = ttest + mtrx(i,l,m)*tnp(j,m)
               end do
               itest = nint(ttest)
               if (abs(ttest-R_REAL(itest)) < CNST(1.e-4)) go to 540
!               if (abs(ttest-R_REAL(itest)) < CNST(1.e-6)) go to 540
               write(6,*) i,j,k,l,abs(ttest-R_REAL(itest))
               mult(i,j) = -1

               go to 550

  540       continue
  550    continue
      end do

      endif
!
!      check multiplication table
!
      do i = 1, ntrans
         do 170 j = 1, ntrans
            if (mult(i,j) > 0) go to 170
            nerr(i) = nerr(i) + 1
            nerr(j) = nerr(j) + 1
  170    continue
      end do
!
!      find element with max error
!
      ierr = 0
      maxerr = 0
      do 190 i = 1, ntrans
         if (nerr(i) <= maxerr) go to 190
         maxerr = nerr(i)
         ierr = i
  190 continue
      if (ierr == 0) return
      if(ipr == 1) then
         write(6,9010)
 9010    format('1Multiplication table',/)
      do i = 1, ntrans
         write(6,'(1x,48i2)') (mult(i,j),j=1,ntrans)
      end do
      endif
      write(message(1),'(a)')not_a_grp
      call write_fatal(1)
!
      return
!
      call pop_sub()
     end subroutine crystal_symchk
!
!
      subroutine symm_ident(ntrans,mtrx,tnp,id)
!
      implicit none
!
      integer :: ntrans
      integer :: mtrx(48,3,3)
      FLOAT :: tnp(48,3)
      character :: id(48)*10
!
!      integer :: i,j
      integer :: oper
      logical :: proper
      FLOAT :: det, trace
      FLOAT :: a(3,3)
!      FLOAT :: wr(3), wi(3), fv1(3), te, tt, e(3), z(3,3), canon_t(3), rdot
!      logical :: nonsym(48)
!      integer :: ierr, ipt, iv1(3)
      FLOAT :: t(3)
      character(len=2) :: axes(-2:2)
!
      data axes / 'C2', 'C3', 'C4', 'C6', 'E ' /

      do 100 oper = 1, ntrans
!
!       Copy the matrix to a FLOAT format for
!       processing with EISPACK. Also, copy the non-primitive
!       translation.
!
            a = mtrx(oper,:,:)
            t = tnp(48,:)
!
!       Compute determinant  and trace
!
        det = a(1,1)*a(2,2)*a(3,3) + a(2,1)*a(3,2)*a(1,3) +       &
              a(1,2)*a(2,3)*a(3,1) - a(3,1)*a(2,2)*a(1,3) -       &
              a(2,1)*a(1,2)*a(3,3) - a(1,1)*a(3,2)*a(2,3)

        proper = (nint(det) == 1)
        trace = a(1,1) + a(2,2) + a(3,3)

        if (proper) then
!           Proper operation
            id(oper) = axes(nint(trace - 1))
        else
!           R = IS , where S is proper
            call blas_scal(9,-M_ONE,a(1,1),1)
            id(oper) = 'I' // axes(nint(-trace - 1))
        endif
!
!       Find eigenvector of a with eigenvalue = +1 (vector
!       parallel to the axis.
!
!        call rg(3,3,a,wr,wi,1,z,iv1,fv1,ierr)
!
!        do 40 i = 1, 3
!           if ( abs( cmplx(wr(i),wi(i)) - (M_ONE,M_ZERO) )
!     &          < CNST(1.e-8) ) ipt = i
!   40   continue
!
!c       Get the correct eigenvector
!        call scopy(3,z(1,ipt),1,e,1)
!c
!c       Perform the dot product with t:
!c
!        te = rdot(e,t)
!c
!        nonsym(oper) = .false.
!c
!        if (proper) then
!          if (abs(te) > CNST(1.e-8)) then
!            nonsym(oper) = .true.
!            call scopy(3,e,1,canon_t,1)
!            call sscal(3,te,canon_t,1)
!          endif
!        else
!          tt = rdot(t,t)
!          if (abs(te) - sqrt(tt) > CNST(1.e-8)) then
!             nonsym(oper) = .true.
!             call scopy(3,t,1,canon_t,1)
!             call saxpy(3,-te,e,1,canon_t,1)
!          endif
!        endif
!        if (nonsym(oper)) id(oper) = id(oper) // '*'

  100 continue

      return

      end subroutine symm_ident
!
!
      subroutine atftmt(ipr, ai, x, r, ity, na, ib, ihg,        &
                        ipm, li, nc, invers_no, mxdtyp, mxdatm)

      implicit none
!
!     INPUT:
!     -----
!
      integer :: ipr,         & ! print flag
           ihg,               & ! holohedral group number
           ipm,               & ! print flag for multiplication table
           na,                & ! total number of atoms (of all kinds)
           mxdtyp,            & ! max number of atom types
           mxdatm               ! max number of atoms of each type

      FLOAT ::                 &
           x(3,mxdtyp*mxdatm), &! compact list of all coordinates (cartesian)
           r(49,3,3),          &! the rotation matrices as they come
                                ! out of the pgl subroutine
!           a(3,3),             &! realspace lattice vectors
           ai(3,3)              ! inverse of lattice vectors (no 2pi)

!
!     INPUT/OUTPUT:
!
      integer :: ity(mxdtyp*mxdatm), & ! compact list of all the types of all atoms
           ib(48),             &! index map for symmetry operations
           nc                   ! number of symm-ops without/with basis

!
!     OUTPUT:
!     ------
!
      integer :: li,          & ! something to do with inversion?
           invers_no            ! which operation is the inversion
!
!     DESCRIPTION:
!     -----------
!
!
!     subroutine atftmt determines the point group of the crystal, the
!     atom transformation table,f0, the fractional translations,tnp,
!     associated with each rotation and finally the multiplication table
!     mt, for the point group of the crystal. ib now contains
!     operations in the p.g. of the crystal and ntrans is the order of
!     this group.
!
!
!     1997 Bernd Pfrommer, based on a routine from Alberto Garcia s
!     code. I cleaned up some more, put in dynamic memory allocation,
!     explicit typing, fortran 90 style, and more comments. Also,
!     some shortcuts were put in to speed up the case where the
!     symmetry is low. The rdiff array precomputes the rotated
!     vectors to speed up things

!
!     ------------------------ local variables -----------------------
!
!     ..
      FLOAT :: v(3,48), vr(3), vt(3), xb(3)
      integer :: ia(48), ic(48), mt(48,48)

      FLOAT :: da, dif, eps, ts, vs
      parameter(eps=CNST(1.0e-8))    ! used to be 1.0d-8

      integer :: i, il, is, isy, iu, j, k, k1, k2, k3, k4, ks, &
                 l, m, n, n1, n2, n3, nca, ni

      FLOAT, allocatable :: rx(:,:), rdiff(:,:,:)
      integer, allocatable :: if0(:,:)


      character :: cst(7)*12
!     ..
!     .. Intrinsic Functions ..
      intrinsic :: abs, mod
!     ..
!     .. Data statements ..
!
      data cst/'triclinic   ', 'monoclinic  ', 'orthorhombic',  &
           'tetragonal  ', 'cubic       ', 'trigonal    ',      &
           'hexagonal   '/
!     ..
      invers_no = 0

      allocate(rx(3,mxdtyp*mxdatm))
      allocate(if0(48,mxdtyp*mxdatm))
      allocate(rdiff(3,na,na))
!
!     eps should be slightly larger than computer precision
!
      nca = 0
      ni = 13
      if (ihg < 6) ni = 25
      li = 0
      do 130 n = 1, nc          ! loop over all lattice symmetry operations
         l = ib(n)              ! get index of symmetry operation
         ic(n) = ib(n)
!
!        operate on all atoms with symmetry operation l, and store in
!        list rx
!
         do k = 1, na
            do i = 1, 3
             rx(i,k) = M_ZERO
               do j = 1, 3
                  rx(i,k) = rx(i,k) + r(l,i,j)*x(j,k)
               end do
            end do
         end do

!     This piece of code is pretty naive, and scales like order(n**3).
!     It basically checks if for each
!
!       R*x_1 - x_2   there is a matching R*x_3-x4
!
!     excluding the trivial case of x_1 == x_3  and  x_2 == x_4
!
!
         do k1 = 1, na          ! precompute the rdiffs first
            do k2 = 1, na
               xb(:) = rx(:,k1)-x(:,k2)
               call rlv(ai,xb,rdiff(1,k2,k1),il) ! rdiff = R*x_1 -x_2
!     subroutine rlv removes a direct lattice vector from xb
!     leaving the remainder in rdiff. if a nonzero lattice vector was
!     removed, il is made nonzero.
            end do
         end do
!
!
!
         do k1 = 1, na          ! double loop over compact atom list
            do k2 = 1, na
             if (ity(k1) == ity(k2)) then ! same type atoms?
                  vr = rdiff(:,k2,k1) !vr stands for v-reference.
                  ks = 0
                  do k3 = 1, na
                     do k4 = 1, na
                   if (ity(k3) == ity(k4)) then
                           vt = rdiff(:,k4,k3) ! vt stands for v-test
                      dif = M_ZERO
                           do i = 1, 3
                              da = abs(vr(i)-vt(i)) + eps
                         dif = dif + mod(da,M_ONE)
                           end do
                      if (dif <= M_TEN*eps) then
                              if0(l,k3) = k4
!     if0 is the function defined in maradudin and vosko by
!     eq.(2.35). it defines the atom transformation table
                              ks = ks + k4
                        if (ks == na*(na+1)/2) go to 110 ! found all
                              go to 80
                           end if
                        end if
                     end do
                     exit
 80                  continue
                  end do
!
!                 BP put in this shortcut (check carefully). If there
!                 is a single R*x_1- x_2 without match, then give up.
               if(ks==0) goto 130 ! this is not a symmetry operation
               end if
            end do
         end do
!
         go to 130              ! this was not a symmetry operation
!
 110     continue               ! we found a symmetry operation
         nca = nca + 1
!
!        v(i,l) is the i-th cartesian component of the fractional
!        translation associated with the rotation r(l).
!
         v(1:3,l) = vr(1:3)
!
         ib(nca) = l
         if (l == ni) then
            li = l
            invers_no = nca
         endif
  130 continue

      deallocate(rdiff)
!
!     -------------- there are no gotos across this line -------------------
!
      if(ipr == 1) then
         if ((ihg == 7.and.nca == 24).or.(ihg == 5.and.nca == 48)) then
            write(6,9010) cst(ihg)
 9010       format(/' The point group of the crystal is the full ' &
                 ,a12,'group')
         else
            write(6,9000) cst(ihg), (ic(i),i=1,nc)
 9000       format(/' The crystal system is ',a12       &
                 ,' with operations: ',/5x,24i3,/5x,24i3,/)
         endif
      endif


      vs = M_ZERO
      nc = nca
      do n = 1, nc
         l = ib(n)
         vs = sum(abs(v(1:3,l)))
      end do
      if (vs > eps) then
        if(ipr == 1)  then
           message(1) = ''
           message(2) = ' The space group is non-symmorphic'
           message(3) =' (Or a non standard  origin of coordinates is used)'
           message(4) = ''
           call write_info(4)
         end if

         isy = 0
         is = 0
      else
        if(ipr == 1) then
           message(1) = ''
           message(2) = ' the space group of the crystal is symmorphic'
           message(3) = ''
           call write_info(3)
      end if
         isy = 1
         is = 1
      endif

!
!    !construct the multiplication table
!
      do n1 = 1, nc
         do n2 = 1, nc
            l = ib(n1)
            m = ib(n2)
            do i = 1, 3
               do j = 1, 3
               r(49,i,j) = M_ZERO
                  do k = 1, 3
                     r(49,i,j) = r(49,i,j) + r(l,i,k)*r(m,k,j)
                  end do
               end do
            end do
            do n3 = 1, nc
               n = ib(n3)
             ts = M_ZERO
               do i = 1, 3
                  do j = 1, 3
                     ts = ts + abs(r(49,i,j)-r(n,i,j))
                  end do
               end do
             if (ts > CNST(100.0)*eps) cycle
               mt(l,m) = n
               exit
            end do
         end do
      end do

      il = 1
      iu = nc
      if (iu > 24) iu = 24
  280 continue
      if(ipr == 1) then
         write(6,9040) (ib(i),i=il,iu)
!        write(message(1),'(a19,24i3)')' Operation number  ',(ib(i),i=il,iu)
!        call write_info(1)
      endif
 9040 format(' Operation number  ',24i3)
      do 300 i = 1, na
         do j = 1, nc
            l = ib(j)
            ia(j) = if0(l,i)
         end do
  300 continue
      if (nc-iu) 320, 320, 310
  310 continue
      if(ipr == 1) then
         write(6,9050)
      endif
 9050 format(//)
      il = 25
      iu = nc
!
      go to 280
!
!     Print multiplication table and fractional translations.
!
  320 continue
      if (ipm == 0) go to 410
      il = 1
      iu = nc
      if (nc > 24) iu = 24
      if (is) 330, 330, 340
  330 continue
      if(ipr == 1) then

!        write(message(1),'(a1,57x,a,30x,a)')'0','Multiplication table','Fractional translations'
!        write(message(2),'(a1,4x,24i4)')'0',(ib(i),i=il,iu)
!        write(message(3),'(a,107x,a)')'+','v(1)      v(2)      v(3)'
!        call write_info(3)
         write(6,9060)
 9060    format('0',57x,'Multiplication table',30x,'Fractional translations')
         write(6,9070) (ib(i),i=il,iu)
 9070    format('0',4x,24i4)
         write(6,9080)
 9080    format('+',107x,'v(1)      v(2)      v(3)')
      endif
!
      go to 360
!
  340 continue
      if(ipr == 1) then
        write(message(1),'(a1,57x,a)')'0','Multiplication table'
        call write_info(1)
         write(6,9090)
      endif
 9090 format('0',57x,'Multiplication table')
  350 continue
      if(ipr == 1) then
        write(message(1),'(a1,4x,24i4)')'0',(ib(i),i=il,iu)
        call write_info(1)
         write(6,9100) (ib(i),i=il,iu)
      endif
 9100 format('0',4x,24i4)
  360 continue
      do 400 j = 1, nc
         l = ib(j)
         do 370 i = il, iu
            n = ib(i)
            ia(i) = mt(l,n)
  370    continue
         if (is) 380, 380, 390
  380    continue
         if(ipr == 1) then
           write(message(1),'(i5,24i4)')ib(j), (ia(i),i=il,iu)
           call write_info(1)
           write(message(1),'(a,102x,3f10.4)')'+',(v(i,l),i=1,3)
           call write_info(1)
            write(6,9120) ib(j), (ia(i),i=il,iu)
            write(6,9110) (v(i,l),i=1,3)
 9110       format('+',102x,3f10.4)
         endif
!
         go to 400
!
  390    continue
         if(ipr == 1) then
           write(message(1),'(i5,24i4)')ib(j), (ia(i),i=il,iu)
           call write_info(1)
            write(6,9120) ib(j), (ia(i),i=il,iu)
         endif
  400 continue
 9120 format(i5,24i4)
      if (iu == nc) go to 410
      il = 25
      iu = nc
      is = 1
!
      go to 350
!
  410 continue
!

      do i = 1, nc
         l = ib(i)
        do j = 1, 3
            tnp(i,j) = -v(j,l)
          do k = 1, 3
               trans(j,k,i) = r(l,j,k)
          end do
        end do
      end do
!
      deallocate(rx)
      deallocate(if0)

      return
!
      end subroutine atftmt
!
!     ------------------------------------------------------------------------
!
!
      subroutine pgl(a,b,r,nc,ib,ihg)

      integer :: ihg, nc
      integer :: ib(48)
      FLOAT :: a(3,3), b(3,3), r(49,3,3)

!     Local variables
      integer :: i, ihc, j, k, lx, n, nr
      FLOAT :: eps, tr
      FLOAT :: vr(3), xa(3)
      parameter(eps=CNST(1.0e-8))    ! used to be 1.0d-8
!     ..
!     .. Intrinsic Functions ..
!      intrinsic abs
!     ..
!
!     eps should be slightly larger than computer precision
!

      ihc = 0
!
!     ihc is 0 for hexagonal groups and 1 for cubic groups.
!
      nr = 24
   10 continue
      nc = 0
      call rot(r,nr)
      do n = 1, nr
         ib(n) = 0
        tr = M_ZERO
        do k = 1, 3
          do i = 1, 3
            xa(i) = M_ZERO
            do j = 1, 3
                  xa(i) = xa(i) + r(n,i,j)*a(j,k)
            end do
          end do
            call rlv(b,xa,vr,lx)
          tr = tr + sum(abs(vr(:)))
        end do
        if (tr <= M_TEN*eps) then
            nc = nc + 1
            ib(nc) = n
         end if
      end do
      if (ihc == 0) then
         if (nc == 12) then
            ihg = 6
            return
         end if
         if (nc > 12) then
            ihg = 7
            return
         end if
         if (nc < 12) then
            nr = 48
            ihc = 1
            go to 10
         end if
      else
         if (nc == 16) then
            ihg = 4
            return
         end if
         if (nc > 16) then
            ihg = 5
            return
         end if
         if (nc < 16) then
            if (nc == 4) then
               ihg = 2
               return
            end if
            if (nc > 4) then
               ihg = 3
               return
            end if
            if (nc < 4) then
               ihg = 1
               return
            end if
         end if
      end if
!
!     ihg stands for holohedral group number.
!
      end subroutine pgl
!
      subroutine rot(r,nr)

      integer :: nr
      FLOAT :: r(49,3,3)
!     .. Local Scalars ..
      FLOAT :: f
      integer :: i, j, k, n, nv
!     .. Intrinsic Functions ..
      intrinsic sqrt

      do n = 1, nr
         r(n,:,:) = M_ZERO
       end do

      if (nr <= 24) then

!        define the generators for the rotation matrices
!                                 --hexagonal group
!
         f = sqrt(M_THREE)/M_TWO
         r(2,1,1) = M_HALF
         r(2,1,2) = -f
         r(2,2,1) = f
         r(2,2,2) = M_HALF
         r(7,1,1) = -M_HALF
         r(7,1,2) = -f
         r(7,2,1) = -f
         r(7,2,2) = M_HALF
         do 40 n = 1, 6
            r(n,3,3) = M_ONE
            r(n+18,3,3) = M_ONE
            r(n+6,3,3) = -M_ONE
            r(n+12,3,3) = -M_ONE
   40    continue
!
!     generate the rest of the rotation matrices
!
         do i = 1, 2
           r(1,i,i) = M_ONE
           do j = 1, 2
               r(6,i,j) = r(2,j,i)
             do k = 1, 2
                  r(3,i,j) = r(3,i,j) + r(2,i,k)*r(2,k,j)
                  r(8,i,j) = r(8,i,j) + r(2,i,k)*r(7,k,j)
                  r(12,i,j) = r(12,i,j) + r(7,i,k)*r(2,k,j)
             end do
           end do
         end do
         do i = 1, 2
           do j = 1, 2
               r(5,i,j) = r(3,j,i)
             do k = 1, 2
                  r(4,i,j) = r(4,i,j) + r(2,i,k)*r(3,k,j)
                  r(9,i,j) = r(9,i,j) + r(2,i,k)*r(8,k,j)
                  r(10,i,j) = r(10,i,j) + r(12,i,k)*r(3,k,j)
                  r(11,i,j) = r(11,i,j) + r(12,i,k)*r(2,k,j)
             end do
           end do
         end do
!
         do n = 1, 12
            nv = n + 12
           r(nv,1:2,1:2) = -r(n,1:2,1:2)
         end do
      else
!
!        define the generators for the rotation matrices
!                                          --cubic group
!
         r(9,1,3) = M_ONE
         r(9,2,1) = M_ONE
         r(9,3,2) = M_ONE
         r(19,1,1) = M_ONE
         r(19,2,3) = -M_ONE
         r(19,3,2) = M_ONE
         do i = 1, 3
           r(1,i,i) = M_ONE
           do j = 1, 3
               r(20,i,j) = r(19,j,i)
               r(5,i,j) = r(9,j,i)
             do k = 1, 3
                  r(2,i,j) = r(2,i,j) + r(19,i,k)*r(19,k,j)
                  r(16,i,j) = r(16,i,j) + r(9,i,k)*r(19,k,j)
                  r(23,i,j) = r(23,i,j) + r(19,i,k)*r(9,k,j)
             end do
           end do
         end do
         do i = 1, 3
           do j = 1, 3
             do k = 1, 3
                  r(6,i,j) = r(6,i,j) + r(2,i,k)*r(5,k,j)
                  r(7,i,j) = r(7,i,j) + r(16,i,k)*r(23,k,j)
                  r(8,i,j) = r(8,i,j) + r(5,i,k)*r(2,k,j)
                  r(10,i,j) = r(10,i,j) + r(2,i,k)*r(9,k,j)
                  r(11,i,j) = r(11,i,j) + r(9,i,k)*r(2,k,j)
                  r(12,i,j) = r(12,i,j) + r(23,i,k)*r(16,k,j)
                  r(14,i,j) = r(14,i,j) + r(16,i,k)*r(2,k,j)
                  r(15,i,j) = r(15,i,j) + r(2,i,k)*r(16,k,j)
                  r(22,i,j) = r(22,i,j) + r(23,i,k)*r(2,k,j)
                  r(24,i,j) = r(24,i,j) + r(2,i,k)*r(23,k,j)
             end do
           end do
         end do
         do i = 1, 3
           do j = 1, 3
             do k = 1, 3
                  r(3,i,j) = r(3,i,j) + r(5,i,k)*r(12,k,j)
                  r(4,i,j) = r(4,i,j) + r(5,i,k)*r(10,k,j)
                  r(13,i,j) = r(13,i,j) + r(23,i,k)*r(11,k,j)
                  r(17,i,j) = r(17,i,j) + r(16,i,k)*r(12,k,j)
                  r(18,i,j) = r(18,i,j) + r(16,i,k)*r(10,k,j)
                  r(21,i,j) = r(21,i,j) + r(12,i,k)*r(15,k,j)
             end do
           end do
         end do
         do n = 1, 24
            nv = n + 24
            r(nv,:,:) = -r(n,:,:)
         end do
      end if
!
      end subroutine rot

      subroutine rlv(p,g,y,l)

      implicit none

        FLOAT   :: g(3),  &  ! vector to be multiplied
                        p(3,3)    ! multiplication matrix, e.g. lattice vectors
        FLOAT   :: y(3)      ! mod(multiplied vector,lattice vector)
        integer :: l       ! is nonzero if a lattice vector was removed

!     subroutine rlv removes a direct lattice vector from g by
!     operation p, leaving the remainder in y. If a nonzero lattice
!     vector was removed, l is made nonzero.

!      intrinsic :: abs, nint

        y(1:3) = matmul(p(1:3,1:3),g(1:3))
        l = sum(nint(abs(y(1:3))))
        y(1:3) = y(1:3) - M_ONE*nint(y(1:3))

      return
      end subroutine rlv

      end module crystal

