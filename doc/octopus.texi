\input texinfo @c -*-texinfo-*- 
@c %**start of header
@setfilename octopus.info 
@settitle @code{octopus} manual
@c %**end of header

@c This is to install octopus into the info main tree.
@dircategory Individual utilities
@direntry
* octopus: (octopus).           The octopus program.
@end direntry


@copying
This manual is for octopus 1.1, a first principles, electronic
structure, excited states, time-dependent density functional
theory program.

@strong{Warning: this is not yet the final version of the manual
for the 1.1 version.}

Copyright @copyright{} 2002, 2003
Miguel A. L. Marques, Alberto Castro and Angel Rubio

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.1 or
any later version published by the Free Software Foundation.
@end quotation
@end copying






@titlepage

@title @code{octopus} manual
@subtitle Electronic Structure
@subtitle Molecular Dynamics
@subtitle Excited-State Dynamics
@subtitle Recipes-Generator
@subtitle March 2002
@sp 4
@image{octosex,8cm,}
@center Male Hapalochlaena lunulata (top),
@center and female Hapalochlaena lunulata (bottom).
@center Photograph by Roy Caldwell.

@sp 2
@author By Miguel A. L. Marques, Alberto Castro and Angel Rubio.

San Sebasti@'an (Spain), Valladolid (Spain), Berlin (Germany).

@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage





@iftex
@headings off
@c @evenheading @thispage{}            @| @thistitle @| @image{octosex,1.7cm}
@c @oddheading  @image{octosex,1.75cm} @| @thischapter  @| @thispage{} 
@evenheading @thispage{}            @| @thistitle @|
@oddheading  @| @thischapter  @| @thispage{} 
@end iftex



@ifnottex
@node Top, Copying, (dir), (dir)
@top octopus
@insertcopying
@end ifnottex

@ifhtml
@image{octosex,8cm}
@center Male Hapalochlaena lunulata (top),
@center and female Hapalochlaena lunulata (bottom).
@center Photograph by Roy Caldwell.
@end ifhtml

@menu
* Copying::                     
* Authors::                     
* Introduction::                
* Installation::                
* The input file::              
* External utilities::          
* Examples::                    
* Options Index::               

@detailmenu
 --- The Detailed Node Listing ---

Introduction

* Description of octopus::      
* Time dependent density functional theory::  

Installation

* Quick instructions::          
* Long instructions::           
* Troubleshooting::             

Description of input options

* The parser::                  
* Input file options::          

Input file options

* Generalities::                
* Species::                     
* Coordinates::                 
* Velocities::                  
* Mesh::                        
* States::                      
* Hamiltonian::                 
* Exchange and correlation::    
* SCF::                         
* Unoccupied States::           
* Time Dependent::              
* Photo-electron spectrum::     
* Geometry optimization::       
* Function output for visualization::  
* Spectrum calculations::       
* Varia::                       

External utilities

* strength-function::           
* hs-from-mult::                
* hs-from-acc::                 
* function-to-dx::              
* nbo2xyz::                     

Examples

* Hello world::                 
* Benzene::                     

@end detailmenu
@end menu

@c ***************THE BODY OF THE DOCUMENT*******************************

@c ***************COPYING************************************************
@node Copying, Authors, Top, Top
@chapter Copying

This program is "free"; this means that everyone is free to use it and free to
redistribute it on a free basis.
What is not allowed is to try to prevent others from further sharing
any version of this program that they might get from you.

Specifically, we want to make sure that you have the right to give
away copies of the program, that you receive
source code or else can get it if you want it, that you can change this
program or use pieces of them in new free programs, and that you know
you can do these things.

To make sure that everyone has such rights, we have to forbid you to
deprive anyone else of these rights.  For example, if you distribute
copies of the program, you must give the recipients all
the rights that you have.  You must make sure that they, too, receive or
can get the source code.  And you must tell them their rights.

Also, for our own protection, we must make certain that everyone finds
out that there is no warranty for this program.
If these programs are modified by someone else and passed on, we want
their recipients to know that what they have is not what we distributed,
so that any problems introduced by others will not reflect on our
reputation.

The precise conditions of the license 
are found in the General Public
Licenses that accompany it.

@c ********************AUTHORS, COLLABORATORS AND ACKNOWLEDGEMENTS*******
@node Authors, Introduction, Copying, Top
@chapter Authors, Collaborators and Acknowledgements.

The main developing team of this program is composed by
Miguel A. L. Marques and Angel Rubio, working at the Donostia
International Physics Center and Department of Materials Science
UPV/EHU (San Sebastian, Espa@~na), and Alberto
Castro, who works at the University of Valladolid, Departamento de
F@'isica Te@'orica (Valladolid, Espa@~na).

@code{octopus} is based on a fixed-nucleus code written by
George F. Bertsch, K. Yabana to perform real-time dynamics in
clusters (Phys Rev B @strong{54}, 4484 (1996))
and on a condensed matter real-space plane-wave based code written 
by A. Rubio, X. Blase and S.G. Louie 
(Phys. Rev. Lett. @strong{77}, 247 (1996)). 
The code was afterwards extended to handle periodic systems by  
G.F. Bertsch, J.I. Iwata, A. Rubio, and K. Yabana
(Phys. Rev. B, @strong{62}, 7998 (2000)). Contemporaneously there was
a major rewrite of the original cluster code to handle a vast majority 
of finite systems. At this point the cluster code was
named ``tddft''.

This version was consequently enhanced and beautified by A. Castro 
(at the time Ph.D. student of A. Rubio), originating a fairly verbose 15,000 
lines of Fortran 90/77. In the year 2000, M. Marques (aka Hyllios, 
aka Ant@'onio de Faria, cors@'ario portugu@^es), joins the A. Rubio group 
in Valladolid as a postdoc. Having to use ``tddft'' for his work, and being 
petulant enough to think he could structure the code better than his 
predecessors, starts a major rewrite of the code together with A. Castro, 
finishing version 0.2 of ``tddft.'' But things were still not perfect: due to 
their limited experience in Fortran 90, and due to the inadequacy of this 
language for anything beyond a HELLO WORLD program, several parts of the code 
were still clumsy. Also the idea of GPLing the almost 20,000 lines arose 
during an alcoholic evening. So after several weeks of frantic coding and 
after getting rid of the Numerical Recipes code that still lingered around, 
@code{octopus} was born.

The present released version has been completely rewritten and keeps
very little relation to the old version (even input and output files) and has
been enhanced with major new flags to perform various excited-state
dynamics in finite and extended systems (one-dimensional periodic
chains). The code will be updated frequently and new versions can 
be found @uref{http://www.tddft.org/programs/octopus, here}.

The main features of the present version are described in detail in
@emph{octopus: a first principles tool for excited states electron-ion
dynamics}, Comp. Phys. Comm. @strong{151}, 60 (2003).
Updated references as well
as results obtained with octopus will be posted regularly to the @code{octopus}
web page. If you find the code useful for you research we would appreciate
if you give reference to this work and previous ones.

If you have some free time, and if you feel like taking a joy ride with
Fortran 90, just drop us an @email{octopus@@tddft.org, email}. You can
also send us patches, comments, ideas, wishes, etc. They will be included
in new releases of octopus.  

@c ********************* INTRODUCTION ***********************************
@node Introduction, Installation, Authors, Top
@chapter Introduction

@menu
* Description of octopus::      
* Time dependent density functional theory::  
@end menu

@node  Description of octopus, Time dependent density functional theory, Introduction, Introduction
@section Description of @code{octopus}
     
@code{octopus} @footnote{
@emph{octopus}: Etymology: New Latin @emph{Octopod-}, @emph{Octopus}, 
from Greek @emph{oktOpous}.
Any of a genus (@emph{Octopus}) of cephalopod mollusks that have 
eight muscular arms equipped with two rows of suckers; 
broadly, any octopod excepting the paper nautilus.
Something that resembles an octopus especially in having many 
centrally directed branches.
(Taken from the Merryam-Webster's dictionary.)
}
is a program aimed at the ab initio virtual experimentation on
electron/ion dynamics in external electromagnetic fields of arbitrary
intensity, shape and frequency in  
a hopefully ever increasing range of systems types. Its 
main characteristics are:

@itemize @bullet

@item Electrons are described quantum-mechanically within the
Density-Functional Theory (DFT) for the ground-state whereas the
excitation spectra is computed using time-dependent form (TDDFT)
by performing simulations in time.  

@item The electron-nucleus interaction is described within the
pseudo-potential approximation. Nuclei are described classically
as point particles. 

@item Wave-functions are expanded in a real-space grid. The kinetic
energy operator is computed with a high-order finite difference method.
FFTs are used in part of the calculations.
Time and grid spacing are related by imposing a stable time-evolution.

@item Forces on the ions are computed through the Ehrenfest theorem. 
Extension to quantum mechanical nuclear dynamics is in progress.

@item Allows for spin-polarised calculations as well as 
non-collinear magnetism and spin-orbit effects.

@item Computes photo-electron (energy and angle resolved)
and photo-absorption spectra for different polarised external electromagnetic
fields. Linear response calculations are a simple case of this
general time-evolution procedure (see below).

@item Includes non-linear electronic effects: high-harmonic generation,
interaction with a laser pulse of arbitrary intensity. For the time being
only time- and spatially-dependent electric fields are included, in the future
magnetic fields will be incorporated.

@item Reads different geometry files including protein-data-base (PDB) for
biological calculations (interaction of biomolecules with electromagnetic
fields).

@item It allows for one and two dimesional modes, by using for
example the soft-coulomb potential or any other given as input.

@item Laser-pulse optimisation using genetic algorithms (to be done).

@item Utilities to analyse the computed spectra.

@item A very effective and easy-to-use parser to handle the input file.

@end itemize

@node  Time dependent density functional theory,  , Description of octopus, Introduction
@section Time dependent density functional theory

Several reviews of time dependent density function theory (TDDFT)
and its applications have appeared recently, like the works by 
Gross et al. @footnote{
  Gross, E.K.U., C.A. Ullricht and U.J. Grossmann, 1994, in
  @emph{Density Functional Theory}, (NATOP ASI Series), p.194;
  Gross, E.K.U., F. J. Dobson, and M. Petersilka, 1996, 
  @emph{Density Functional Theory} (Springer, New York).
}, Casida @footnote{
  Casida, M.E., 1995, in @emph{Recent Advances in Density Functional Methods},
  Part I, ed. D.P. Chong (World Scientific, Singapore), p.155;
  Casida, M.E., 1996, in @emph{Recent Developments and Applications of Modern
  Density Functional Theory}, ed. J.M. Seminario (Elsevier Science,
  Amsterdam), p.391
},
Dobson et al, @footnote{
  Dobson, J , G. Vignale and M.P. Das (Eds), 1997a, 
  @emph{Electronic Density Functional Theory: Recent Progress and New Directions}
  (Plenum, New York)  
}
, and Burke et al @footnote{
  Burke, K., M. Petersilka and E.K.U. Gross, 2001, in
  @emph{Recent Advances in Density Functional Methods}, edited by P.
  Fantucci and A. Bencini (World Scientific, Singapure).  
}.

@ifinfo
Please visit the printed version of this manual for a brief of
review of TDDFT.
@end ifinfo
@ifnotinfo
The Hohenberg-Kohn-Sham theory as described is a ground state theory, and
it is hence not meant for the calculation of electronic excitations.
However, one can extend the ideas of static DFT. When one asks for the 
evolution of the system under the influence of a time-dependent external
potential, one should search the extrema of the quantum mechanical
action
@tex
$$
  A = \int_{t_0}^{t_1} dt
  \langle \Psi(t) \vert i {\partial \over \partial t} - H(t) \vert
  \Psi(t) \rangle \, ,
$$
@end tex
Theorems have now been established for time-dependent DFT@footnote{
  Runge, E. and E. K. U. Gross, 1984, Phys. Rev. Lett.
  @strong{52} 997.
}
which are parallel to those of static DFT.
The first theorem proves a one-to-one mapping between time-dependent
potentials and time-dependent densities; the second proves the 
stationary-action principle.

The proof of the first theorem is based directly on the evolution of
the time-dependent Schr@"odinger equation from a fixed initial
many-particle state @tex $\Psi(t_0)=\Psi_0$ @end tex
under the influence of a time-dependent potential @tex $v(t)$ @end tex
required to be expandable in a Taylor series around @tex $t_0.$ @end tex
The initial state @tex $\Psi_0$ @end tex
does not need to be the ground state or some other eigenstate of the 
initial potential.  As one does not rely on the adiabatic connection as in standard
zero-temperature many-body perturbation theory the formalism is able to 
handle external perturbations varying fast in time. By virtue of the first 
theorem, the time-dependent density determines the external
potential uniquely up to an additive purely time-dependent function.
On the other hand, the potential determines the time-dependent wave-function,
therefore the expectation value of any quantum mechanical operator
is a unique functional of the density.

The second theorem deals with the variational principle of the action
functional with the initial condition 
@tex $\Psi(t_0)=\Psi_0.$ @end tex
From the previous one-to-one mapping between time-dependent
potentials and densities, the action is a functional of the density
that must have a stationary point at the correct time-dependent
density.
Thus the Euler equation corresponding to the extrema of 
@tex $A[\rho],$ @end tex
@tex $$
  {\delta A[\rho] \over \delta \rho({\bf r},t)} =0,
$$ 
@end tex
determines the time dependent density, just
as in the Hohenberg-Kohn formalism the static ground state
density is given by the minimum of the total energy
@tex ($\delta E[\rho]/\delta \rho({\bf r},t)=0$). @end tex

Similarly, one can define a time-dependent Kohn-Sham (KS) scheme by
introducing a non-interacting system that reproduces the exact
interacting density 
@tex $\rho({\bf r},t)$. @end tex
One gets the following time-dependent KS-equations:
@tex $$
  \left[ - {1 \over 2} \nabla^2 + V_{eff}({\bf r},t)
  \right] \psi_i({\bf r},t) = i{\partial\over\partial t} \psi_i({\bf
  r},t)
$$
$$
  \rho({\bf r},t) = \sum_{i=1}^N \vert \psi_i({\bf r},t) \vert^2
$$ @end tex
where 
@tex $$
  V_{\rm eff}({\bf r},t)= V_{\rm H}({\bf r},t) + V_{\rm xc}({\bf r},t)+
  V_{\rm ext}({\bf r},t)
$$ @end tex 
is the effective
time dependent potential felt by the electrons. It consist of
the sum of the external time-dependent applied field,
the time-dependent Hartree term, plus the  xc potential (defined
through the equivalence between the interacting and fictitious
non-interacting systems). The variational principle yields
@tex 
$$
  V_{\rm xc}({\bf r},t) = 
  {\delta A_{\rm xc}[\rho] \over \delta \rho({\bf r},t)} \, ,
$$ 
@end tex
where @tex $A_{\rm xc}[\rho] $ 
@end tex
is the xc part of the action functional

The main advantage of the time-dependent KS-scheme lies in its
computational simplicity compared to other quantum-chemical models 
such as time-dependent Hartree-Fock or configuration interaction.
@end ifnotinfo

@c *************************INSTALLATION*********************************
@node Installation, The input file, Introduction, Top
@chapter Installation

@menu
* Quick instructions::          
* Long instructions::           
* Troubleshooting::             
@end menu

@node Quick instructions, Long instructions, Installation, Installation
@section Quick instructions

For the inpatients, here goes the quick-start: 
@example
prompt> gzip -cd octopus<-version>.tar.gz | tar xvf -
prompt> cd octopus-<version>
prompt> ./configure
prompt> make
prompt> make install
@end example

This will probably @strong{not} work, so before giving up, just read
the following paragraphs.

Also, rpm and deb binaries for linux are supplied in the web-page.

@node Long instructions, Troubleshooting, Quick instructions, Installation
@section Long instructions

The code is written in standard Fortran 90, with some routines written
in C (and in bison, if we count the input parser). To build it
you will need both a C compiler (@code{gcc} works just fine), and a
Fortran 90 compiler. No free-software Fortran 90 compiler is available yet,
so, if you want to chew the @code{octopus}, you will have either
to help the @uref{http://g95.sourceforge.net, g95} project
or use any of the available comercial compilers.

Besides the compiler, you will also need:
@enumerate
@item @code{make}:  most computers have it installed, otherwise just
grab the GNU @code{make} and install it.

@item @code{cpp}: The C preprocessor is heavily used in @code{octopus}.
GNU @code{cpp} is just fine, but any @code{cpp} that accepts
the @code{-C} flag (preserve comments) should work just as well.

@item FFTW: Just grab this great library from @uref{http://www.fftw.org/, here}

@item LAPACK/BLAS: Not heavily used, but required. If you are running Linux,
there is a fair chance they are already installed in your system. The same
goes to the more heavyweight machines (alphas, IBMs, SGIs, etc). Otherwise,
just grab the source from @uref{http://www.netlib.org, here}.

@item GSL: Finally that someone had the nice idea of making a public scientific
library! GSL still needs to grow, but it is already quite useful and impressive.
@code{octopus} uses splines, complex numbers, special functions, etc. from GSL,
so it is a must! If you don't have it already installed in your system, you can
obtain GSL from @uref{http://sources.redhat.com/gsl/, here}. You will need version 1.0 
or higher.

@item MPI: If you want to run @code{octopus} in multi-tentacle (parallel) mode,
you will need an implementation of MPI. 
@uref{http://www-unix.mcs.anl.gov/mpi/mpich/, @code{mpich}} works just fine in our
Linux boxes.

@end enumerate

First you should obtain the code gzipped-tarred file @code{octopus<-version>.tar.gz} 
(this you probably have already done). The code is freely available, and
can be downloaded from @uref{http://www.tddft.org/programs/octopus}. There exists
a @code{cvs} server, which you can browse at 
@uref{http://nautilus.fis.uc.pt/cgi-bin/cvsweb.cgi/marques/octopus/}. 
The sources of the cvs version (in general more unstable the the @emph{official}
distribution) may be downloaded by anonymous cvs access:

@example
prompt> cvs -d :pserver:anonymousnautilus.fis.uc.pt:/server/cvsroot 
        login

prompt> cvs -d :pserver:anonymousnautilus.fis.uc.pt:/server/cvsroot 
        co marques/octopus
@end example


Uncompress
and untar it (@code{gzip -cd octopus<-version>.tar.gz | tar -xvf -}).
In the following, @code{OCTOPUS-HOME} denotes the home directory of
octopus, created by the @code{tar} command.

The @code{OCTOPUS-HOME} contains the following subdirectories:
@itemize @bullet
  @item @code{build}: contains files related to the building system. Not of real interest
    for the plain user.
  @item @code{CVS}: May actually not be there; contains files related to the CVS -- the 
    user does not need to know anything about it.
  @item @code{doc} : The documentation of @code{octopus} in @emph{texinfo} format.
  @item @code{faq} : Will contain a list of frequently asked questions -- very small list
    for the moment.
  @item @code{liboct} : Small C library that handles the interface to
    GSL and the parsing of the input file. It also contains some assorted
    routines that we didn't want to write in boring Fortran.
  @item @code{samples} : Sample input files for @code{octopus}.
  @item @code{share}: Made to contain ``auxiliary'' files eventually used by the code;
    in practice now it contains the Troullier-Martins and Hartwigsen-Goedecker-Hutter
    pseudopotential files.
  @item @code{src} : Fortran 90 source files. Note that these have to be preprocessed
    before being fed to the Fortran compiler, so do not be scared by
    all the # directives.
@end itemize

Before configuring you can (should) setup a couple of options. Although
the configure script tries to guess your system settings for you, we recommend 
that you set explicitly the default Fortran 90 compiler and the compiler options. In
@code{bash} you would typically do:
@example
export F90=abf90
export F90FLAGS="-O -YEXT_NAMES=LCS -YEXT_SFX=_"
@end example
if you are using the Absoft Fortran 90 compiler on a linux machine.

You can now run the configure script (@code{./configure}). 
@footnote{
If you downloade the cvs version, no @code{configure} script is present. In the
development version, some previous work has to be done: running the GNU autotools to 
generate this script. This may be done by issuing the short script
@code{./autogen.sh}. Note that you need to have working versions of the
@code{automake}, @code{autoconf} and @code{libtool} programs.
}
You can use
a fair amount of options to spice (@code{octopus}) to your own taste.
To obtain a full list just type @code{./configure --help}. Some 
commonly used options include:
@itemize @bullet
@item
@code{--prefix=PREFIX} : Change the base installation dir of @code{octopus}
  to @code{PREFIX}. The executable will be installed in @code{PREFIX/bin},
  the libraries in @code{PREFIX/lib} and the documentation in @code{PREFIX/info}.
  @code{PREFIX} defaults to the home directory of the user who runs @code{configure}.
@item
@code{--with-fftw=DIR} : Installation directory of the FFTW library.
@item
@code{--with-lapack=DIR} : Installation directory of the LAPACK and
  BLAS libraries.
@item
@code{--with-gsl-prefix=DIR} : Installation directory of the GSL library. The
  libraries are expected to be in @code{DIR/lib} and the include
  files in @code{DIR/include}. The value of @code{DIR} is usually found by
  issuing the command @code{gsl-config --prefix}. (If the GSL library is
  installed, the program @code{gsl-config} should be somewhere).
@item
@code{--enable-1d} : Build the 1d version of @code{octopus}.
@item
@code{--enable-2d} : Build the 2d version of @code{octopus}.
@item
@code{--enable-3d} : Build the 3d version of @code{octopus}. This is the
  default behaviour.
@item
@code{--enable-mpi} : Builds the parallel version (MPI) of @code{octopus}.
@item
@code{--enable-complex} : Builds a version with complex wave-functions
for the ground-state calculations (wave-functions are always complex for
the evolution). This is needed when spinors are needed --- e.g. noncollinear
magnetism is going to be considered, or the spin-orbit coupling term will
be used.
@end itemize

Run @code{make}, and then @code{make install}. If everything went fine, you
should now be able to taste @code{octopus}. Depending on the options passed to
the configure script, some suffixes or prefixes could be added to the generic
name @code{octopus} --- i.e. @code{octopus-1d} for the 1D version,
@code{zoctopus} for the code compiled with complex wave-functions,
@code{zoctopus-mpi} for a parallel version of the code compiled with
complex wave-function, and so on.

The program has been tested in the following platforms:
@itemize @bullet
@item @code{i686*-linux-gnu} : with the @uref{http://www.absoft.com, Absoft},
  and the @uref{http://www.intel.com/software/products/compilers/, Intel} compiler.
@item @code{alphae*} : both in Linux and in OSF with Compac's @code{fort} compiler.
@item @code{powerpc-ibm-aix4.3.3.0}: with native @code{xlf90} compiler.
@end itemize
If you manage to compile/run @code{octopus} in a different platform
or with a different compiler, please let us know so we can update the
list. Patches to solve compiler issues are also welcomed.

Build the documentation in the format you prefer. Since you are reading
this, you already have it in some format. Due to the power of @code{texinfo},
a series of formats are available, namely @code{dvi}, @code{html},
@code{pdf} and @code{info}. The @code{octopus.texi} source code of this
document is in the @code{OCTOPUS-HOME/doc} directory.

@node Troubleshooting,  , Long instructions, Installation
@section Troubleshooting

If you are reading this it is because something went wrong. Let us see
if we can fix it ;)

@strong{Could not find library...}:
This is probably the most common error you can get. @code{octopus} uses
three different libraries, @code{GSL}, @code{FFTW}, and 
@code{BLAS}/@code{LAPACK}. We assume that you have already
installed these libraries but, for some reason, you were not able to
compile the code. So, what went wrong?
@itemize @bullet

@item Did you pass the correct @code{--with-XXXX} (where XXXX is gsl, fftw or
  lapack in lowercase) to the configure script? If your libraries are
  installed in an non-standard directory (like @code{/opt/lapack}), you will
  have to pass the script the location of the library (in this example,
  you could try @code{./configure --with-lapack=/opt/lapack}.

@item If you are working in an alpha station, do not forget that the @code{CXML}
  library includes @code{BLAS} and @code{LAPACK}, so it can be used by
  @code{octopus}. If needed, just set the correct path with @code{--with-lapack}.

@item If the configuration script can not find @code{FFTW}, it is probable that
  you did not compile @code{FFTW} with the same Fortran compiler or with the
  same compiler options. The basic problem is that Fortran some times converts
  the function names to uppercase, other times to lowercase, and it can
  add an "_" to them, or even two. Obviously all libraries and the program have
  to use the same convention, so the best is to compile everything with
  the same Fortran compiler/options. If you are a power user, you can check the
  convention used by your compiler using the command @code{nm <library>}.

@c @item If the configuration script can not find @code{BLAS}/@code{LAPACK}, 
@c   first read the preceding point, for the same considerations apply to 
@c   @code{LAPACK}. If you are a Linux user and feel a bit frightened to
@c   compile @code{LAPACK} in your box (after all, it does not use the nice
@c   configure/make/make install paradigm), you can use the RPMs that come
@c   with the RedHat distribution. They will work for the Absoft @code{abf90} 
@c   compiler, but they will @strong{not} work for the Intel @code{ifc}
@c   compiler. There is nevertheless a small hack that can circumvent this
@c   annoyance. Let us assume that you have installed @code{BLAS}/@code{LAPACK}
@c   from the RPMs. Just execute (you may want to change the directories):
@c   @example
@c mkdir ~/lib/g77
@c cd ~/lib/g77
@c cp /usr/lib/libf2c.a libf2c_ifc.a
@c ar d libf2c_ifc.a main.o
@c ar d libf2c_ifc.a s_stop.o
@c cd OCTOPUS-HOME
@c export F90LIBS="-L$HOME/lib/g77 -lf2c_ifc"
@c ./configure <options>
@c make
@c make install
@c   @end example
@c  This should work (it worked for me, at least ;))

@end itemize

@strong{Whatever went wrong...}:
Up to now, we cannot really make a list of commonly found problems. So if something
else went wrong, please subscribe to @code{octopus-users} mailing list, and ask.


@c *******************DESCRIPTION OF INPUT OPTION************************
@node The input file, External utilities, Installation, Top
@chapter Description of input options

@menu
* The parser::                  
* Input file options::          
@end menu

@c **********************************************************************
@node The parser, Input file options, The input file, The input file
@section The parser

All input options should be in a file called '@code{inp}', in the
directory @code{octopus} is run from. Alternatively, if this file is not
found, standard input is read. For a fairly comprehensive
example, just look at the file @code{OCTOPUS_HOME/samples/inp}

At the beginning of the program @code{liboct} reads the @code{inp}
file, parses it, and generates a list of variables that will be
read by @code{octopus} (note that the input is case independent). 
There are two kind of variables, scalar
values (strings or numbers), and blocks (that you may view as
matrices). A scalar variable @code{var} can be defined by:
@example
var = exp
@end example
@code{var} can contain any alphanumeric character plus "_", and 
@code{exp} can be a quote delimited string, a number (integer,
real, or complex), a variable name, or a mathematical expression. 
In the expressions all arithmetic operators are supported 
("a+b", "a-b", "a*b", "a/b"; for exponentiation the C syntax
"a^b" is used), and the following functions can be use:
@itemize @bullet
@item @code{sqrt(x)} : The square root of @code{x}.
@item @code{exp(x)} : The exponential of @code{x}.
@item @code{log(x)} or @code{ln(x)}: The natural logarithm of @code{x}.
@item @code{log10(x)} : Base 10 logarithm of @code{x}.
@item @code{sin(x)}, @code{cos(x)}, @code{tan(x)}, @code{cot(x)},
  @code{sec(x)}, @code{csc(x)}: The sinus, co-sinus, tangent, co-tangent,
  secant and co-secant of @code{x}.
@item @code{asin(x)}, @code{acos(x)}, @code{atan(x)}, @code{acot(x)},
  @code{asec(x)}, @code{acsc(x)}: The inverse (arc-) sinus, co-sinus, tangent, co-tangent,
  secant and co-secant of @code{x}.
@item @code{sinh(x)}, @code{cosh(x)}, @code{tanh(x)}, @code{coth(x)},
  @code{sech(x)}, @code{csch(x)}: The hyperbolic sinus, co-sinus, tangent, co-tangent,
  secant and co-secant of @code{x}.
@item @code{asinh(x)}, @code{acosh(x)}, @code{atanh(x)}, @code{acoth(x)},
  @code{asech(x)}, @code{acsch(x)}: The inverse hyperbolic sinus, co-sinus, tangent, co-tangent,
  secant and co-secant of @code{x}.
@end itemize
You can also use any of the predefined variables:
@itemize @bullet
@item @code{pi} : 3.141592653589793, what else is there to say?
@item @code{e} : The base of the natural logarithms.
@item @code{false} or @code{f} or @code{no} : False in all its flavors. For the
  curious, @code{false} is defined as 0.
@item @code{true} or @code{t} or @code{yes} : The truthful companion of @code{false}. For the
  curious, @code{true} is defined as 1.
@end itemize

Blocks are defined as a collection of values, organised in row and column format.
The syntax is the following:
@example
%var
  exp | exp | exp | ...
  exp | exp | exp | ...
  ...
%
@end example
Rows in a block are separated by a newline, while columns are
separated by the character "|". There may be any number of lines and any
number of columns in a block. Note also that each line can have a different
number of columns.

If @code{octopus} tries to read a variable that is not defined in the
@code{inp} file, it automatically assigns to it a default value. All
variables read are output to the file '@code{out.oct}'. If you are
not sure of what the program is reading, just take a look at it.
Everything following the character "#" until the end of the line
is considered a comment and is simply cast into oblivion.

@node Input file options,  , The parser, The input file
@section Input file options

@code{octopus} has quite a few options, that we will subdivide in different groups.
After the name of the option, its type and default value (when applicable)
are given in parenthesis.

@menu
* Generalities::                
* Species::                     
* Coordinates::                 
* Velocities::                  
* Mesh::                        
* States::                      
* Hamiltonian::                 
* Exchange and correlation::    
* SCF::                         
* Unoccupied States::           
* Time Dependent::              
* Photo-electron spectrum::     
* Geometry optimization::       
* Function output for visualization::  
* Spectrum calculations::       
* Varia::                       
@end menu

@c **********************************************************************
@node Generalities, Species, Input file options, Input file options
@subsection Generalities
@itemize @bullet

@item @vindex @code{Verbose}
  @code{Verbose} (integer, 30) : 
Verbosity level of the program. The higher, the
more verbose @code{octopus} is. Current levels are:
@itemize @minus
  @item @code{verbose <=  0} : Silent mode. No output except fatal errors.
  @item @code{verbose >   0} : Warnings only.
  @item @code{verbose >  20} : Normal program info.
  @item @code{verbose > 999} : Debug mode. Issues a message every time the 
program enters a (important) subroutine, and prints the time it spend upon return.
@end itemize

@item @vindex @code{SystemName}
  @code{SystemName} (string, 'system') :
A string that identifies the current run. This parameter is used 
to build the names of some files generated by @code{octopus}.

@item @vindex @code{CalculationMode}
  @code{CalculationMode} (integer, 1) :
It defines the type of simulation to perform. Options are:
  @itemize @minus
    @item @code{1} : Start static calculation.
    @item @code{2} : Resume static calculation.
    @item @code{3} : Calculate unoccuppied states.
    @item @code{4} : Resume calculation of unoccupied states.
    @item @code{5} : Start time-dependent propagation.
    @item @code{6} : Resume time-dependent propagation.
    @item @code{7} : Start static polarizability calculation.
    @item @code{8} : Resume static polarizability calculation.
    @c @item @code{9} : Perform Born-Oppenheimer MD simulation.
    @item @code{10}: Perform geometry minimization.
    @item @code{11}: Calculates the phonon spectrum of the system.
    @item @code{12}: @emph{Optimum control} mode.
    @item @code{99} : Print out an octopus recipe.
  @end itemize

@item @vindex @code{Units}
@code{Units} (string, 'a.u'):
Atomic units seem to be the preferred system in the atomic and
molecular physics community (despite the opinion of some of the authors
of this program). Accordingly, atomic units can be used both for
input and output. However, some people like using eV for energies and @AA{} 
for lengths. This other system of units (the @emph{convenient system}, 
in words of Prof. George F. Bertsch), can also be used. See the Frequently
Asked Questions for some more details.
Valid options are:
@itemize @minus
  @item @code{'a.u'} : atomic units
  @item @code{'eVA'} : electron-volts/@aa{}ngstr@"om
@end itemize

@item @vindex @code{UnitsInput}
@code{UnitsInput} (string, 'a.u.'):
Same as @code{Units}, but only refers to the values in the input file.

@item @vindex @code{UnitsOutput}
@code{UnitsOutput} (string, 'a.u.'):
Same as @code{Units}, but only refers to the values in the output files.

@end itemize

@c **********************************************************************
@node Species, Coordinates, Generalities, Input file options
@subsection Species
@itemize @bullet

@item @vindex @code{Species}
@code{Species} (block data) : 
A specie is by definition an ion (nucleus + core electrons) described
through a pseudo-potential, or a model potential.
The format of this block is different for 1, 2 or 3 dimensions, and
can be best understood through examples. 

@itemize *

@item In 1D, or 2D, e.g.
@example
  %Species
    'H'  | 1.0079 | 1 | "-1/sqrt(x^2 + 1)"
  %
@end example
This defines a species labelled '@code{H}' of weight @code{1.0079},
and valence charge @code{1}. This 'valence charge' is used to calculate
the number of electrons present in the calculation: as many
as indicated by the valence charges of the species, plus any extra charge
specified by the user (@pxref{States}). Last field may be
any user defined potetial -- use @code{x} (and @code{y} in the 2D case) for the 
position of the electron relative to the species center.
For example. the potential often used in 1D calculations is the soft-Coulomb 
potential -Z/sqrt(x*x + 1).

@item In 3D, e.g.
@example
  %Species
    'O'       | 15.9994 | 8   | "tm2"  | 1 | 1
    'H'       |  1.0079 | 1   | "hgh"  | 0 | 0
    'jelli01' | 23.2    | 8.0 |  5.0
    'point01' | 32.3    | 2.0
    'usdef'   | 1 | 8 | "1/2*r^2"
  %
@end example
In this case, we have 4 "species" present:
@itemize @minus
@item Oxygen labelled '@code{O}'. Next number is the atomic mass (in atomic 
mass units), and third field, the atomic number (8, in this case).
Afterwards, "tm2" is the flavour of the pseudopotential: ``tm2'' stands
for Troullier-Martins. This means the pseudopotential will be 
read from an @code{O.ascii} or @code{O.vps} file, either in the working
directory or in the @code{OCTOPUS-HOME/share/PP/TM2} directory.
Next two numbers are the maximum 
@emph{l}-component of the pseudo-potential to consider in the
calculation, and the @emph{l}-component to consider as local.
@item Hydrogen defined in the same way as Oxygen. In this case, however, the
flavour is ``hgh'' standing for Hartwigsen-Goedecker-Hutter. Last two numbers
are irrelevant.
@item All species whose label starts by 'jelli' are jellium spheres.
The other parameters are the weight, the nuclear charge, and the
valence charge of the sphere.
@item All species whose label starts by 'point' are point charges.
The other parameters are the weight and the nuclear charge. In
fact, point charges are implemented as @emph{rather small} jellium
spheres, with zero valence charge.
@item All species whose label starts by 'usdef' are user defined
potentials. The second parameter is the mass (irrelevant in this case, 
for these species are not allowed to move), whereas the third parameter
is the 'valence charge', used to calculate the number of electrons.
Finally, the potential itself is defined by the fourth argument.
Use any of the @code{x}, @code{y}, @code{z} or @code{r} variables
to define position.

@end itemize
@end itemize
@end itemize

@c **********************************************************************
@node Coordinates, Velocities, Species, Input file options
@subsection Coordinates
@code{octopus} successively tries to read the atomic coordinates from
a PDB file, a XYZ file, or else directly from the @code{inp} file.
@itemize @bullet

@item @vindex @code{PDBCoordinates}
@code{PDBCoordinates} (string, 'coords.pdb') :
  Tries to read the atomic coordinates from the file @code{PDBCoordinates}.
  The PDB (@uref{http://www.rcsb.org/pdb/,Protein Data Bank}) format is
  quite complicated, and it goes well beyond the scope of this manual. You
  can find a comprehensive description in 
  @uref{http://www.rcsb.org/pdb/docs/format/pdbguide2.2/guide2.2_frame.html}.
  From the plethora of instructions defined in the PDB standard, @code{octopus}
  only reads 2, @code{ATOM} and @code{HETATOM}. From these fields, it reads:
  @itemize @minus
  @item columns 13-16 : The specie; in fact @code{octopus} only cares about the first
    letter -- 'CA' and 'CB' will both refer to Carbon -- so elements whose
    chemical symbol has more than one letter can not be represented in this way.
    So, if you want to run mercury ('Hg') please use one of the other two methods
    to input the atomic coordinates, @code{XYZCoordinates} or @code{Coordinates}.
  @item columns 18-21 : The residue. If residue is 'QM', the atom is treated
    in Quantum Mechanics, otherwise it is simply treated as an external classical
    point charge. Its charge will be given by columns 61-65.
  @item columns 31-54 : The Cartesian coordinates. The Fortran format is
    @code{'(3f8.3)'}.
  @item columns 61-65 : Classical charge of the atom. The Fortran format is
    @code{'(f6.2)'}.
  @end itemize

@item @vindex @code{XYZCoordinates}
@code{XYZCoordinates} (string, 'coords.xyz') :
  If @code{PDBCoordinates} is not present, reads the atomic coordinates
  from the XYZ file @code{XYZCoordinates}. The XYZ format is very simple,
  as can be seem from this example for the CO molecule (in @AA{}).
  @example
    2
      CO molecule in equilibrium
    C  -0.56415   0.0   0.0
    O   0.56415   0.0   0.0
  @end example
  The first line of the file has an integer indicating the number of
  atoms. The second can contain comments that are simply ignored by 
  @code{octopus}. Then there follows one line per each atom, containing
  the chemical species and the Cartesian coordinates of the atom.

@item @vindex @code{Coordinates}
@code{Coordinates} (block data) :
  If neither a @code{XYZCoordinates} or a @code{PDBCoordinates} was found,
  @code{octopus} tries to read the coordinates for the atoms from the
  block @code{Coordinates}. The format is quite straightforward:
  @example
    %Coordinates
      'C' | -0.56415 | 0.0 | 0.0 | no
      'O' |  0.56415 | 0.0 | 0.0 | no
    %
  @end example
  The first line defines a Carbon atom at coordinates (@code{-0.56415},
  @code{0.0}, @code{0.0}), that is @emph{not} allowed to move during
  dynamical simulations. The second line has a similar meaning. This
  block obviously defines a Carbon monoxide molecule, if the input
  units are @AA{}. Note that this in this way, as opposed to specifying
  the @code{PDBCoordinates} or @code{XYZCoordinates} file, it is possible
  to fix some of the atom (fixing all the atoms is always possible trough
  the @code{MoveIons} variable).

@item @vindex @code{AdjustCoordinates}
@code{AdjustCoordinates} (logical, false) :
  If true, translates the atom coordinates so that the
  geometrical centre of the molecule coincides with the zero of 
  the mesh, and rotates them, fixing the largest dimension
  of the molecule to the axis defined through @code{MainAxis}.
  Very useful when handling large and elongated molecules -- try
  it out!

@item @vindex @code{MainAxis}
@code{MainAxis} (block data) :
  Defines the axis to be used if @code{AdjustCoordinates} is true.
  If not set defaults to the z axis.

@item @vindex @code{OutputCoordinates}
@code{OutputCoordinates} (logical, false) :
  If true @code{octopus} outputs a XYZ file called 
  '@code{SystemName}.xyz' containing the coordinates of the atoms
  treated within Quantum Mechanics. If point charges were defined
  in the PDB file (see @code{PDBCoordinates}), they will be output
  in the file '@code{SystemName_classical.xyz}'.
@end itemize

@node Velocities, Mesh, Coordinates, Input file options
@subsection Velocities

@itemize @bullet
@item @vindex @code{XYZVelocities} :
@code{XYZVelocities} (string, 'velocities.xyz') :
  @code{octopus} will try to read the starting velocities of the atoms from the XYZ file 
  @code{XYZVelocities}.

@item @vindex @code{Velocities}
@code{Velocities} (block data) :
  If @code{XYZVelocities} is not present, @code{octopus} will try fetch the initial 
  atomic velocities from this block. If this block is not present, @code{octopus}
  will reset the initial velocities to zero. The format of this block can be
  illustrated by this example:
  @example
    %Velocities
      'C'  | -1.7 | 0.0 | 0.0
      'O'  |  1.7 | 0.0 | 0.0
    %
  @end example
  It describes one Carbon and one Oxygen moving at the relative
  velocity of @code{3.4}, velocity units.
@end itemize
Note: it is important to maintain for the velocities the ordering 
in which the species were defined in the coordinates specifications.

@c **********************************************************************
@node Mesh, States, Velocities, Input file options
@subsection Mesh

@code{octopus} uses a grid in real space to solve the Kohn-Sham equations.
The grid is equally-spaced, but the spacings can be different for each 
Cartesian direction. The shape of the simulation region may also
be tuned to suit the geometric configuration of the system.

@itemize @bullet

@item @vindex @code{BoxShape}
@code{BoxShape} (integer, sphere) :
It is the shape of the simulation box. The allowed 
values are:
  @itemize @minus
    @item @code{sphere} or @code{1}: A sphere
    @item @code{cylinder} or @code{2}: A cylinder. The cylinder axis will be 
in the z direction
    @item @code{minimum} or @code{3}: Sum of spheres around each atom.
    @item @code{parallelepiped} or @code{4}: As the name indicates.
  @end itemize
For a 1D calculation, it would obviously always be a 1D ``sphere''.

@item @vindex @code{Radius}
@code{Radius} (double, 20.0 a.u.) :
If @code{BoxShape != parallelepiped} defines the radius of the
spheres or of the cylinder. 

@item @vindex @code{Lsize}
@code{Lsize} (block data) :
In case @code{BoxShape = parallelepiped}, this
is assumed to be a block of the form:
  @example
    %Radius
      sizex | sizey | sizez
    %
  @end example
where the @code{size*} are half of the lengths of the box in each direction.

@item @vindex @code{ZLength}
@code{ZLength} (double, 1.0 a.u.) :
If @code{BoxShape == cylinder} is half the total length of the cylinder.

@item @vindex @code{Spacing}
@code{Spacing} (double, 0.6 a.u.) or (block data) :
If the code is compiled in 1D mode or if @code{BoxShape != parallelepiped}
defines the (constant) spacing between points in the grid. Otherwise, it
is assumed to be a block of the form:
  @example
    %Spacing
      spacingx | spacingy | spacingz
    %
  @end example

@item @vindex @code{DerivativesSpace}
@code{DerivativesSpace} (integer, real_space)
Defines in which space gradients and the laplacian are calculated. Allowed values are:
  @itemize @minus
    @item @code{real_space} or @code{0} : Derivatives are calculated in real-space
      using finite differences. The order of the derivative can be set with
      @code{OrderDerivatives}.
    @item @code{fourier_space} or @code{1} : Derivatives are calculated in
      reciprocal space. Obviously this case implies cyclic boundary conditions,
      so be careful.
  @end itemize

@item @vindex @code{OrderDerivatives}
@code{OrderDerivatives} (integer, 4) :
If @code{DerivativesSpace == real_space} use a finite difference discretisation
of this order for the derivatives, that is a @code{OrderDerivatives*2 + 1} formula.
See (MISSING ARTICLE) for details.

@item @vindex @code{DoubleFFTParameter}
@code{DoubleFFTParameter} (real, 2.0):
For solving Poisson equation in Fourier space, and for applying the local potential
in Fourier space, an auxiliary cubic mess is built. This mesh will be larger than
the circunscript cube to the usual mesh by a factor @code{DoubleFFTParameter}. See
the section that refers to Poisson equation, and to the local potential for details.

@end itemize


@c **********************************************************************
@node States, Hamiltonian, Mesh, Input file options
@subsection States
@itemize @bullet

@item @vindex @code{SpinComponents}
@code{SpinComponents} (integer, 1) :
Defines the spin mode @code{octopus} will run in. Valid modes are:
  @itemize @minus
    @item @code{1} : Spin-unpolarised calculation.
    @item @code{2} : Spin-polarised calculation (collinear spin). This mode
will double the number of wave-functions necessary for a spin-unpolarised 
calculation.
    @item @code{3} : Non-collinear spin. This mode will double the number 
of wave-functions necessary for a spin-unpolarised calculation, and each of
the wave-functions will be a 2-spinor.
  @end itemize

@item @vindex @code{NumberKPoints}
@code{NumberKPoints} (integer, 1) :
If @code{octopus} was compiled for periodic systems, the number of
@emph{k} points to use in the calculation. If @code{NumberKPoints == 1},
use only the Gamma point. (Note: current version in fact does not
implement this possibility. Setting this variable to more that 1 may
lead to erroneous results).

@item @vindex @code{ExcessCharge}
@code{ExcessCharge} (double, 1) :
The net charge of the system. A negative value means that we are adding 
electrons, while a positive value means we are taking electrons
from the system.

@item @vindex @code{ExtraStates}
@code{ExtraStates} (integer, 1) :
How many unoccupied states to use in the ground-state
calculation. Note that this number is unrelated to @code{CalculationMode == 4}.

@item @vindex @code{Occupations}
@code{Occupations} (blockdata) :
The occupation numbers of the orbitals can be fixed through the use of this
variable. For example:
  @example
    %Occupations
      2.0 | 2.0 | 2.0 | 2.0 | 2.0
    %
  @end example
would fix the occupations of the five states to @code{2.0}. There must be
as many columns as states in the calculation. If @code{SpinComponents == 2}
this block should contain two lines, one for each spin channel.
This variable is very useful when dealing with highly symmetric small systems
(like an open shell atom), for it allows us to fix the occupation numbers
of degenerate states in order to help @code{octopus} to converge. This is to
be used in conjuction with @code{ExtraStates}. For example, to calculate the
carbon atom, one would do:
  @example
  ExtraStates=2
  %Occupations
      2 | 2/3 | 2/3 | 2/3
    %
  @end example

@item @vindex @code{ElectronicTemperature}
@code{ElectronicTemperature} (double, 0.0)
If @code{Occupations} is not set, @code{ElectronicTemperature} is the
temperature in the Fermi-Dirac function used to distribute the electrons
among the existing states.

@end itemize

@c **********************************************************************
@node Hamiltonian, Exchange and correlation, States, Input file options
@subsection Hamiltonian
@itemize @bullet

@item @vindex @code{NonInteractingElectrons}
@code{NonInteractingElectrons} (logical, false) :
  If @code{true}, treat the electrons as non-interacting, i.e. neglect both
  Hartree and exchange-correlation contributions to the Kohn-Sham potential.
  A probable choice for one-electron problems.

@item @vindex @code{ClassicPotential}
@code{ClassicPotential} (logical, false) :
If @code{true}, add to the external potential the potential generated by 
the point charges read from the PDB input (see @code{PBDCoordinates}).

@item @vindex @code{LocalPotentialSpace}
@code{LocalPotentialSpace} (integer, fourier_space) :
If @code{fourier_space}, generate the local part of the pseudo-potential
in Fourier space; Otherwise do it directly in real space. The auxiliary box defined via
the @code{DoubleFFTParameter} is used for this purpose. 

@item @vindex @code{NonLocalPotentialSpace}
@code{NonLocalPotentialSpace} (integer, real_space) :
If @code{fourier_space} generate the non-local part of the pseudo-potential
in Fourier space; Otherwise do it directly in real space. @emph{Generating
the potential in Fourier space seems to reduce the egg-box effect but this
option has not been extensively tested.}

@item @vindex @code{GridRefinement}
@code{GridRefinement} (integer, 3) :
If @code{NonLocalPotentialSpace == fourier_space}, a grid refinement
technique is applied to reduce the error in the calculation of the nonlocal
projectors. This variable defines the number of
points to interpolate between the normal mesh points, in order to 
apply this  method. @emph{This seems to reduce the egg-box effect but this
option has not been extensively tested.}

@end itemize

@c **********************************************************************
@node Exchange and correlation, SCF, Hamiltonian, Input file options
@subsection Exchange and correlation

The exchange-correlation functional is controlled by the
4 parameters @code{XFamily}, @code{XFunctional},
@code{CFamily} and @code{CFunctional}. Obviously, the @code{X}
parameters control the exchange part of the functional, while the
@code{C} parameters control the correlation. The possible values are:

@vindex @code{XFamily}
@vindex @code{XFunctional}

@itemize @bullet
@item @code{XFamily == 'ZER'} : No exchange.
@item @code{XFamily == 'LDA'} : Local density approximation.
  @itemize @minus
    @item @code{XFunctional == 'NREL'} : Non-relativistic exchange.
    @item @code{XFunctional ==  'REL'} : Relativistic exchange.
  @end itemize
@item @code{XFamily == 'GGA'} : Generalised gradient approximations.
  @itemize @minus
    @item @code{XFunctional ==  'PBE'} :  J.P.Perdew, K.Burke and M.Ernzerhof, 
    	PRL @strong{77}, 3865 (1996)
    @item @code{XFunctional == 'PBER'} : PBE with some relativistic corrections.
    @item @code{XFunctional == 'LB94'} : van Leeuwen and Baerends functional.
  @end itemize
@item @code{XFamily == 'KLI'} : Optimised effective potential method within
  the Krieger, Lee and Iafrate approximation.
  @itemize @minus
    @item @code{XFunctional ==   'X'} : Exact exchange functional.
    @item @code{XFunctional == 'SIC'}: Self interaction corrected LDA.
  @end itemize
@end itemize

And now comes the correlation variables:
@vindex @code{CFamily}
@vindex @code{CFunctional}

@itemize @bullet
@item @code{CFamily == 'ZER'} : No correlation
@item @code{CFamily == 'LDA'} : Local density approximation.
  @itemize @minus
    @item @code{CFunctional ==   'PZ81'} :  Perdew and Zunger, 
      PRB @strong{23}, 5075 (1981)
    @item @code{CFunctional == 'PW92'} : J.P.Perdew and Y.Wang, 
      PRB @strong{45}, 13244 (1992)
  @end itemize
@item @code{CFamily == 'GGA'} : Generalised gradient approximations. 
  @itemize @minus
    @item @code{CFunctional == 'PBE'} : J.P.Perdew, K.Burke and M.Ernzerhof, 
    	PRL @strong{77}, 3865 (1996)
  @end itemize
@item @code{CFamily == 'KLI'}: Optimised effective potential method within
  the Krieger, Lee and Iafrate approximation.
  @itemize @minus
    @item @code{CFunctional == 'SIC'}: Self interaction corrected LDA.
  @end itemize
@end itemize

@c **********************************************************************
@node SCF, Unoccupied States, Exchange and correlation, Input file options
@subsection SCF

The self consistent procedure will stop when the first of the convergence
criteria is fulfilled.
@itemize @bullet
@item @vindex @code{MaximumIter}
@code{MaximumIter} (integer, 200) :
Maximum number of SCF iterations. @code{0} means unlimited.

@item @vindex @code{ConvAbsDens}
@code{ConvAbsDens} (double, 1e-5) :
Absolute convergence of the density. @code{0} means do 
not use this criterion.

@item @vindex @code{ConvRelDens}
@code{ConvRelDens} (double, 0.0) :
Relative convergence of the density. @code{0} means do 
not use this criterion.

@item @vindex @code{ConvAbsEnergy}
@code{ConvAbsEnergy} (double, 0.0) :
Absolute convergence of the total energy. @code{0} means do 
not use this criterion.

@item @vindex @code{ConvRelEnergy}
@code{ConvRelEnergy} (double, 0.0) :
Relative convergence of the total energy. @code{0} means do 
not use this criterion.

@end itemize
There are some more variables controlling the SCF cycle:
@itemize @bullet

@item @vindex @code{LCAOStart}
@code{LCAOStart} (logical, true) :
Before starting a SCF calculation, performs
a LCAO calculation. these should provide @code{octopus} with a good set
of initial wave-functions, and help the convergence of the SCF cycle.
(Up to current version, only a minimal basis set used).

@item @vindex @code{SCFinLCAO}
@code{SCFinLCAO} (logical, false) :
Performs all the SCF cycle restricting the calculation to the LCAO subspace.
This may be useful for systems with convergence problems (first do a 
calculation within the LCAO subspace, then restart from that point for
an unrestricted calculation).

@item @vindex @code{EigenSolver}
@code{EigenSolver} (integer, 0) :
At each SCF cycle step, a diagonalisation of the Hamiltonian is performed.
This variables tells
which eigensolver to use to diagonalise the Kohn-Sham Hamiltonian.
Possible values are:
  @itemize @minus
    @item @code{0} : Conjugated Gradients method I.
    @item @code{1} : Conjugated Gradients method II.
  @end itemize
Method I should be better. Look up the source to know what the differences
are.

In both cases, for the first iterations of the cycle there is no need to
perform a very precise diagonalisation. Because of this, we may define
a varying tolerance, so that at the first iteration a given small 
tolerance is achieved, and then this tolerance is linearly increased
until a given iteration, after which a maximum tolerance is always asked.
Next variables take care of this process. This possiblity is only
available when method 0 is used.

@item @vindex @code{EigenSolverInitTolerance}
@code{EigenSolverInitTolerance} (double, 1.0e-10) :
When @code{EigenSolver == 0} is the initial tolerance for the eigenvectors.

@item @vindex @code{EigenSolverFinalTolerance}
@code{EigenSolverFinalTolerance} (double, 1.0e-14) :
When @code{EigenSolver == 0} is the final tolerance for the eigenvectors.

@item @vindex @code{EigenSolverFinalToleranceIteration}
@code{EigenSolverFinalToleranceIteration} (integer, 7) :
When @code{EigenSolver == 0} determines how many interactions are needed 
to go from @code{EigenSolverInitTolerance} to @code{EigenSolverFinalTolerance}.

@item @vindex @code{EigenSolverMaxIter}
@code{EigenSolverMaxIter} (integer, 25) :
When @code{EigenSolver == 0} determines the maximum number of iterations 
for the eigensolver --- that is, if this number is reached, the diagonalisation
is stopped even if the desired tolerance was not achieved.

@item @vindex @code{NumberCG}
@code{NumberCG} (integer, 3) :
When @code{EigenSolver == 1} determines the number of conjugated gradient 
steps per iteration.

@item @vindex @code{TypeOfMixing}
@code{TypeOfMixing} (integer, 0) :
Selects the mixing procedure for the density during the SCF cycle. Possible
values are:
  @itemize @minus
    @item @code{0} : Linear mixing.
    @item @code{1} : Reserved for Anderson-Pulay mixing; currently not implemented.
    @item @code{2} : Broyden mixing.
  @end itemize

@item @vindex @code{Mixing}
@code{Mixing} (double, 0.3) :
Determines the amount of the new density which is to be mixed
with the old density.

@item @vindex @code{BroydenNumber}
@code{BroydenNumber} (integer, 3) :
Number of steps used by Broyden mixing to extrapolate the new density.

@end itemize

@c **********************************************************************
@node Unoccupied States, Time Dependent, SCF, Input file options
@subsection Unoccupied States

These variables are only used in @code{CalculationMode == 3, 4} (or in 5 and 6
if @code{TDOccupationalAnalysis == 1}.)
@itemize @bullet

@item @vindex @code{UnoccNumberStates}
@code{UnoccNumberStates} (integer, 5) :
  How many unoccupied states to compute.

@item @vindex @code{UnoccMaximumIter}
@code{UnoccMaximumIter} (integer, 200) :
  Maximum number of iterations while calculating the unoccupied states.
  Note that this are @emph{not} SCF iterations, for the density and the 
  Hamiltonian are not updated!

@item @vindex @code{UnoccConv}
@code{UnoccConv} (double, 1e-4) :
  Absolute convergence in the eigenvectors. So don't try to put it too
  good or else you won't converge.
@end itemize

@c **********************************************************************
@node Time Dependent, Photo-electron spectrum, Unoccupied States, Input file options
@subsection Time Dependent
@itemize @bullet

@item @vindex @code{TDMaximumIter}
@code{TDMaximumIter} (integer, 1500) :
Number of time steps.

@item @vindex @code{TDSaveIter}
@code{TDSaveIter} (integer, 100) :
Output stuff every @code{TDSaveIter} steps.

@item @vindex @code{TDEvolutionMethod}
@code{TDEvolutionMethod} (integer, 3) :
Method used to perform the time propagation. Authorised values are:
  @itemize @minus
    @item @code{1} : ``Old-Style'' method. One should check carefully 
the time-step, and it only works with density based functionals.
It is quick per time step, but allows for very small time-steps.
    @item @code{2} : Method designed to enforce the time-reversal symmetry. 
Better time steps. Default.
    @item @code{3} : A modification of previous method to make it faster.
It is based on extrapolation of the time dependent potentials. Due to some
unknown problems, currently being investigated, it is not the default method.
    @item @code{4} : Exponential midpoint rule. In principle, it should  also
respect the time-reversal symmetry.
  @end itemize

@item @vindex @code{TDExponentialMethod}
@code{TDExponentialMethod} (integer, 1) :
Method used to numerically calculate the exponential of the hamiltonian,
a core part of the calculation in any of the previously described methods
to perform the evolution.
  @itemize @minus
    @item @code{1} : N-th order expansion of the exponential.
    @item @code{2} : Lanczos approximation. Allows for larger time-steps.
However, the larger the time-step, the longer the time per time-step. In
certain cases, if the time-step is too large, the code will emit a warning
whenever it considers that the evolution may not be proberly proceeding --
the Lanczos process did not converge. This possibility is still somehow
experimental. (REFERENCE MISSING).
    @item @code{3} : Split-operator.
    @item @code{4} : Suzuki-Trotter (REFERENCE MISSING). This is a higher-order
split-operator based method.
    @item @code{5} : N-th order Chebyshev expansion. In principle, the Chebyshev expansion
of the exponential represents it more accurately than the canonical expansion
(method 1). This is only true for high orders, though.
  @end itemize

@item @vindex @code{TDExpOrder}
@code{TDExpOrder} (integer, 4) :
For @code{TDExponentialMethod} equal @code{1} or @code{5}, the order to which
the exponential is expanded. For the Lanczos approximation, it is the maximum
Lanczos-subspace dimension.

@item @vindex @code{TDLanczosTol}
@code{TDLanczosTol} (real, 1e-4) :
An internal tolerance variable for the Lanczos method. The smaller, the more
precise the exponential is calculated.

@item @vindex @code{TDTimeStep}
@code{TDTimeStep} (double, 0.07 a.u.) :
  Time step for the propagation.

@item @vindex @code{TDLasers}
@code{TDLasers} (block data) :
Each line of the block describes a laser pulse applied to the system. 
The syntax is:
  @example
    %TDLasers
      polx | poly | polz | A0 | omega0 | envelope | tau0 | t0
    %
  @end example
where @code{pol} is the (complex) polarisation of the laser field, @code{A0}
the amplitude, @code{envelope} the envelope function, @code{t0} the 
middle (maximum) of the pulse and @code{omega0} the frequency of 
the pulse. The meaning of @code{tau0} depends on the envelope function. 
The possible values for @code{envelope} are:
  @itemize @minus
    @item @code{1} : Gaussian envelope. @code{tau0} is the standard deviation 
      of the pulse.
    @item @code{2} : Cosinoidal envelope. @code{tau0} is half the total length
      of the pulse.
    @item @code{3} : Ramp. In this case there is an extra parameter 
      @code{tau1}. @code{tau0} is the length of the constant part of the ramp,
      and @code{tau1} is the raising (decaying) time. @code{tau1} should be
      an extra field after @code{t0}
    @item @code{4} : Shape is read from a file.
  @end itemize

If @code{envelope=4}, the @code{t0} parameter is substituted by a string that
determines the name of the file. The format of this file should be three
columns of real numbers:
time, field and phase. Atomic units are assumed. The values for the laser field
that the program will use are interpolated / extrapolated from this numerically
defined function.

@item @vindex @code{TDGauge}
@code{TDGauge} (integer, 0) :
In which gauge to treat the laser. Options are:
@itemize @minus
    @item @code{1} : Length gauge.
    @item @code{2} : Velocity gauge.
  @end itemize

@item @vindex @code{TDOutputLaser}
@code{TDOutputLaser} (logical, false) :
If @code{true}, @code{octopus} outputs the laser field to the file '@code{laser.out}'.

@item @vindex @code{TDDeltaStrength}
@code{TDDeltaStrength} (double, 0.0 a.u.)
When no laser is applied, a delta (in time) electric field with
strength @code{TDDeltaStrength} is applied. This is used to calculate
the linear optical spectra.

@item @vindex @code{TDPolarization}
@code{TDPolarization} (block data)
The (real) polarisation of the delta electric field. The format of the
block is:
  @example
    %TDPolarization
      polx | poly | polz
    %
  @end example

@item @vindex @code{TDAbsorbingBoundaries}
@code{TDAbsorbingBoundaries} (integer, 0) :
To improve the quality of the spectra by avoiding the formation of 
standing density waves, one can make the boundaries of the simulation 
box absorbing. The possible values for this parameter are:
  @itemize @minus
    @item @code{0} : No absorbing boundaries.
    @item @code{1} : A sin@math{^2} imaginary potential is added at the boundaries.
    @item @code{2} : A mask is applied to the wave-functions at the boundaries.
  @end itemize

@item @vindex @code{TDABWidth}
@code{TDABWidth} (real, 0.4 a.u.) :
Width of the region used to apply the absorbing boundaries.

@item @vindex @code{TDABHeight}
@code{TDABHeight} (real, -0.2 a.u.) :
When @code{TDAbsorbingBoundaries == 1}, is the height of the imaginary 
potential.

@item @vindex @code{TDDipoleLmax}
@code{TDDipoleLmax} (integer , 1) :
Maximum multi-pole of the density output to the file '@code{Sysname}.mult' 
during a time-dependent simulation.

@item @vindex @code{TDOccupationalAnalysis}
@code{TDOccupationalAnalysis} (logical, false) :
If true, outputs the projections of the time-dependent Kohn-Sham
wave-functions onto the static (zero time) wave-functions to the
file '@code{Sysname}.proj'.

@item
@code{MoveIons} (integer, 0) : 
What kind of simulation to perform. Possible values are:
  @itemize @minus
    @item @code{0} : Do not move the ions.
    @item @code{1} : Steepest descents.
    @item @code{2} : Damped Newtonian dynamics using Verlet.
    @item @code{3} : Newtonian dynamics using Verlet.
    @item @code{4} : Newtonian dynamics using velocity Verlet.
    @item @code{5} : Minimisation using conjugated gradients.
  @end itemize
But in fact, for a time-dependent simulation can only takes the values 
@code{0}, @code{3}, and @code{4}. The rest are
ignored in present version.

@end itemize


@c **********************************************************************
@node Photo-electron spectrum, Geometry optimization, Time Dependent, Input file options
@subsection Photo-electron spectrum
@itemize @bullet

@item @vindex @code{CalcPES_rc}
@code{CalcPES_rc} (logical, false) :
  If @code{true}, store the wave functions in specific points in order to 
calculate the photo-electron spectrum in a point far in the box as proposed in 
A. Pohl, P.-G. Reinhard, and E. Suraud Phys. Rev. Lett. @strong{84}, 5090 (2000).


@item @vindex @code{PES_rc_points}
@code{PES_rc_points} (block data) :
  List of points where to calculate the photo-electron spectrum a la Suraud.
  The exact syntax is:
  @example
    %TDPES_rc_points
      x1 | y1 | z1
    %
  @end example

@item @vindex @code{CalcPES_mask}
@code{CalcPES_mask} (logical, false)
  If @code{true}, calculate the photo-electron spectrum using the mask method
  (M. Marques, D. Varsano, H. Appel, E.K.U. Gross and A. Rubio to be submitted). 
  In order for this to work, masking boundaries are necessary 
  (@code{TDAbsorbingBoundaries == 2}).

@end itemize


@c **********************************************************************
@node Geometry optimization, Function output for visualization, Photo-electron spectrum, Input file options
@subsection Geometry optimization
@itemize @bullet

@item @vindex @code{GOMethod}
@code{GOMethod} (integer, 1)
  Method by which the minimization is performed. Its possible values are
  @code{1} for a simple steepest descent, @code{2} for
  Polak-Ribiere conjugate-gradients, @code{3} for Fletcher-Reeves conjugate gradient
  and @code{4} for Broyden-Fletcher-Goldfarb-Shanno conjugate gradient. This latter
  one should be the most sophisticated and fast one.

@item @vindex @code{GOTolerance}
@code{GOTolerance} (real, 0.0001)
  Convergence criterium to stop the minimization. In units of force; minimization
  is stopped when all forces on ions are smaller.

@item @vindex @code{GOMaxIter}
@code{GOMaxIter} (integer, 200)
  Even if previous convergence criterium is not satisfied, minimization will stop
  after this number of iterations.

@end itemize


@c **********************************************************************
@node Function output for visualization, Spectrum calculations, Geometry optimization, Input file options
@subsection Function output for visualization
Every given number of time iterations, or after ground-state calculations, some
of the functions that characterise the system may be written to disk
so that they may be analized. Files are written within ``static'' output directory
after the self-consistent field, or within ``td.x'' directories, during evolution,
where ``x'' stands for the iteration number at which each write is done.
@itemize @bullet

@item @vindex @code{OutputKSPotential}
@code{OutputKSPotential} (logical, false)
 Prints out Kohn-Sham potential, separated by parts. File names would be ``v0'' for 
 the local part, ``vc'' for the classical potential (if it exists), ``vh'' for the
 Hartree potential, and ``vxc-x'' for each of the exchange and correlation potentials
 of a give spin channel, where ``x'' stands for the spin channel.

@item @vindex @code{OutputDensity}
@code{OutputDensity} (logical, false)
 Prints out the density. Filename would be ``density-x'', where ``x'' stands for 
 the spin channel.

@item @vindex @code{OutputWfs}
@code{OutputWfs} (logical, false)
 Prints out wave-functions. Which wavefunctions are to be printed is specified
 by the variable @code{OutputWfsNumber} -- see below. Filenames would be
 ``wf-k-p-i'', where k stands for the @emph{k} number, p for the state, and
 i for the spin channel.

@item @vindex @code{OutputWfsNumber}
@code{OutputWfsNumber} (string, "1-1024")
  Which wavefunctions to print, in list form, i.e., "1-5" to print the first five states,
  "2,3" to print the second and the third state, etc.

@item @vindex @code{OutputELF}
@code{OutputELF} (logical, false)
 Prints out the electron localization function, ELF. Filename would be ``elf-i'', where
 i stands for the spin channel.

@end itemize

How are they printed? This is controlled by the next set of variables:

@itemize @bullet

@item @vindex @code{OutputPlaneX}
@code{OutputPlaneX} (logical, false)
A plane slice at x=0 is printed. The string ``.x=0'' is appended to previous file names.

@item @vindex @code{OutputPlaneY}
@code{OutputPlaneY} (logical, false)
A plane slice at y=0 is printed. The string ``.y=0'' is appended to previous file names.

@item @vindex @code{OutputPlaneZ}
@code{OutputPlaneZ} (logical, false)
A plane slice at y=0 is printed. The string ``.z=0'' is appended to previous file names.

@item @vindex @code{OutputDX}
@code{OutputDX} (logical, false)
For printing all the three dimensional information, the open source program visualization
tool OpenDX (http://www.opendx.org/) is used. The string ``.general'' is appended to 
previous file names. However, this feature is still in developing proccess. More 
information in future releases of this manual, or else ask directly to @code{octopus-users@@tddft.org}.

@end itemize

How often are they printed? At a given time-step, two conditions must be fulfilled
in order to output the desired functions. First, the iteration number must be a
multiple of @code{TDSaveIter}. Second, it must be a multiple of:

@itemize @bullet

@item @vindex @code{OutputEvery}
@code{OutputEvery} (integer, 1000)

@end itemize

@c **********************************************************************
@node Spectrum calculations, Varia, Function output for visualization, Input file options
@subsection Spectrum calculations
Once @code{octopus} has been run, results must be analyzed somehow. The most common
thing is to Fourier-transform something to calculate spectra. This may be done through
some utilities (@code{strength-function}, @code{hs-from-mult}, @code{hs-from-acc} which
are described in section ``External utilities.'' Common options read by these utilities are:
@itemize @bullet

@item @vindex @code{SpecTransMode}
@code{SpecTransMode} (string, 'sin')
  What kind of Fourier transform is calculated. 'sin' and 'cos' are the valid options,
  with obvious meanings.

@item @vindex @code{SpecDampMode}
@code{SpecDampMode} (string, 'exp')
  A damping function may be applied to the input fuction before processing the Fourier
  transform. This function may be an exponential or a polynomial: 'exp' or 'pol'. If
  this variable is not present or has any other value, no damping function is applied.

@item @vindex @code{SpecDampFactor}
@code{SpecDampFactor} (real, 0.0)
  If @code{SpecDampMode} is set to `exp', the damping parameter of the exponential
  is fixed through this variable.

@item @vindex @code{SpecStartTime}
@code{SpecStartTime} (real, 0.0)
  Processing is done for the given function in a time-window that starts at the
  value of this variable.

@item @vindex @code{SpecEndTime}
@code{SpecEndTime} (real, -1.0)
  Processing is done for the given function in a time-window that ends at the
  value of this variable.

@item @vindex @code{SpecEnergyStep}
@code{SpecEnergyStep} (real, 0.05)
  Sampling rate for the spectrum.

@item @vindex @code{SpecMinEnergy}
@code{SpecMinEnergy} (real, 0.0)
  The Fourier transform is calculated for energies bigger than this value.

@item @vindex @code{SpecMaxEnergy}
@code{SpecMaxEnergy} (real, 20.0)
  The Fourier transform is calculated for energies smaller than this value.

@item @vindex @code{HSPolarization}
@code{HSPolarization} (string, 'z')
  For the utilities @code{hs-from-acc}, and @code{hs-from-mult}, the polarization
  of the laser pulse must be specified. Valid values are 'x', 'y' and 'z' for 
  lasers linearly polarized along the respective axis, or '+' or '-' for lasers 
  circularly polarized. See the description of @code{hs-from-acc} and @code{hs-from-mult}
  for more details.

@end itemize

@c @c **********************************************************************
@c @node Born-Oppenheimer Dynamics, Varia, Photo-electron spectrum, Input file options
@c @subsection Born-Oppenheimer Dynamics
@c @itemize @bullet
@c 
@c @item @vindex @code{MoveIons}
@c @code{MoveIons} (integer, 0) :
@c   What kind of simulation to perform. Possible values are:
@c   @itemize @minus
@c     @item @code{0} : Do not move the ions.
@c     @item @code{1} : Steepest descents.
@c     @item @code{2} : Damped Newtonian dynamics using Verlet.
@c     @item @code{3} : Newtonian dynamics using Verlet.
@c     @item @code{4} : Newtonian dynamics using velocity Verlet.
@c     @item @code{5} : Minimisation using conjugated gradients.
@c   @end itemize
@c 
@c @item @vindex @code{BOnSteps}
@c @code{BOnSteps} (integer, 1000) :
@c   Number of time-steps to perform during the Born-Oppenheimer simulation.
@c 
@c @item @vindex @code{BOTimeStep}
@c @code{BOTimeStep} (double, 0.1 a.u.) :
@c   Time-step used to integrate the Born-Oppenheimer equations of motion. 
@c   The default value @code{0.1} can safely be increased when performing
@c   steepest descents (@code{MoveIons == 1}).
@c 
@c @item @vindex @code{Gamma}
@c @code{Gamma} (double, 0.4) :
@c   Value for the drag term when performing damped
@c   Newtonian dynamics (@code{MoveIons == 2}).
@c @end itemize

@c **********************************************************************
@node Varia,  , Spectrum calculations, Input file options
@subsection Varia
@itemize @bullet

@item @vindex @code{PoissonSolver}
@code{PoissonSolver} (integer, 3) :
  In 3D defines which method to use in order to solve the Poisson equation.
  Allowed values are:
  @itemize @minus
    @item @code{1} : Conjugated gradient method.
    @item @code{3} : FFTs with spherical cutoff.
  @end itemize
  The value of variable @code{DoubleFFTParameter} is used in case @code{3} method
  is used.

@item @vindex @code{POLStaticField}
@code{POLStaticField} (double, 0.001 a.u.) :
  Magnitude of the static field used to calculate the static polarizability 
  in @code{CalculationMode = 7, 8}.

@item @vindex @code{RecipeLang}
@code{RecipeLang} (string, 'en') :
  In @code{CalculationMode = 99} defines the language in which to print
  the recipe. Allowed values are (for now) @code{'en'} and @code{'es'}.

@end itemize


@c **********************************************************************
@node External utilities, Examples, The input file, Top
@chapter External utilities

A few small programs are generated along with @code{octopus}, for the
purpose of post-processing the generated information. These utilities
should all be run from the directory where @code{octopus} was run, so that
it may see the @code{inp} file, and the directories created by it.

@menu
* strength-function::           
* hs-from-mult::                
* hs-from-acc::                 
* function-to-dx::              
* nbo2xyz::                     
@end menu

@node strength-function, hs-from-mult, External utilities, External utilities
@section @code{strength-function}

This utility generates the dipole strength function of the given system.
Its main input is the @code{td.general/multipoles} file. Output is written
to a file called @code{system.spectrum} where @code{system} is the system
name, as defined in @code{SystemName} variable. This file is made of two
columns: energy (in eV or a.u., depending on the units specified in @code{inp}),
and dipole strength function (in 1/eV, or 1/a.u., idem).

In the @code{inp} file, the user may set the @code{SpecTransformMode} -- this
should be set to 'sin' for proper use --, the @code{SpecDampMode} -- recommended
value is 'pol', which ensures fulfilling of the N-sum rule, 
the @code{SpecStartTime}, the @code{SpecEndTime}, the @code{SpecEnergyStep}, 
the @code{SpecMinEnergy} and the @code{SpecMaxEnergy}.

@node hs-from-mult, hs-from-acc, strength-function, External utilities
@section @code{hs-from-acc}

Calculates the harmonic spectrum, out of the acceleration file. To do.

@node hs-from-acc, function-to-dx, hs-from-mult, External utilities
@section @code{hs-from-mult}

Calculates the harmonic spectrum, out of the multipoles file. To do.

@node function-to-dx, nbo2xyz, hs-from-acc, External utilities
@section @code{function-to-dx}

Outputs functions in OpenDX format, from restart files. To do.

@node nbo2xyz,  , function-to-dx, External utilities
@section @code{nbo2xyz}

Reads out the @code{td.general/coordinates} file, and makes
a movie in XYZ format. To do.


@c **********************************************************************
@node Examples, Options Index, External utilities, Top
@chapter Examples

@menu
* Hello world::                 
* Benzene::                     
@end menu

@node Hello world, Benzene, Examples, Examples
@subsection Hello world

As a first example, we will take a sodium atom.
With your favourite text editor, create
the following input 'inp'.
@example
  SystemName = 'Na'
  CalculationMode = 1
  %Species
    'Na' | 22.989768 | 11 | "tm2" | 0 | 0
  %
  %Coordinates
    'Na' | 0.0 | 0.0 | 0.0 | no
  %
  Radius = 12.0
  Spacing = .6
  TypeOfMixing = 2
@end example


This input file should be essentially self-explanatory. 
Note that a Troullier-Martins pseudopotential file ('Na.vps', or 'Na.ascii') should
be accesible to the program. A sample 'Na.ascii' may be found
in @code{OCTOPUS-HOME/share/PP/TM2}. If @code{octopus} was installed
(@code{make install} was issued after @code{make}), there should be no need
to do anything -- the program should find it. Otherwise, you may as well place it
in the working directory.
Then run @code{octopus} -- for example, do @code{> octopus > out }, so that the 
output is stored in ``out'' file. If everything goes OK, ``out'' should look like
@footnote{
Before this output, a beautiful octopus ascii-art picture may be printed...
}:
@example
Info: Calculation started on 2002/07/10 at 12:35:12
Info: Reading pseudopotential from file:
      '/home/alberto/share/octopus/PP/TM2/Na.ascii'
Info: l =  0 component used as local potential

**********   Pseudopotential Information for: Na   **********
**********   FLAVOUR: TROULLIER-MARTINS.
Z    :    11.0000
Z_val:     1.0000
Exchange/correlation used in generation: ca
Relativistic character of calculations: nrl
Type of core corrections: nc
Signature of pseudopotential:
      ATM3      no_date   Troullier-Martins
Valence configuration in calculations:
 (orbital - occupancy - core radius)
  3s 1.00  r= 2.94
  3p 0.00  r= 2.94
  3d 0.00  r= 2.94
  4f 0.00  r= 2.94
Maximum L-component to consider:  0
Maximum L-component in file:  3
Radial grid parameters ( R(I) = B*[ EXP(A*(I-1)) -1 ] )
             A =   1.250000E-02
             B =   2.253411E-04
Number of radial points:  1054
nrval:  1055
PS-generation cut-off radii: [b]  2.94000  2.94000  2.94000  2.94000
KB-spheres radii:            [b]  0.00000
KB-cosines: [H]
                    0.000000
KB-norms: [1/H]
                    0.000000
Eigenvalues of pseudo-eigenfunctions [H]
                   -0.103582
Atomic radius: [b]          0.000000
*************************************************************

  Type = sphere           Radius [b] =  12.000
  Spacing [b] = ( 0.600, 0.600, 0.600)    volume/point [b^3] =  0.21600
  # inner mesh =  33401   # outer mesh =  18896
Info: Derivatives calculated in real-space
Info: FFTs used in a double box (for poisson | local potential)
      box size = (  81,  81,  81)
      alpha =      2.00000
Info: Using FFTs to solve poisson equation with spherical cutoff.
Info: Exchange and correlation
      Exchange    family    : LDA
                  functional: non-relativistic
      Correlation family    : LDA
                  functional: Perdew-Zunger
Info: Allocating rpsi.
Info: Random generating starting wavefunctions.
Info: Unnormalized total charge =      0.998807
Info: Setting up Hamiltonian.
Info: Performing LCAO calculation.
Info: LCAO basis dimension:      1
Info: SCF using real wavefunctions.
Eigenvalues [H]
   #  Eigenvalue   Occupation      Error (1)
   1    -0.103155     1.000000 (  0.03163190)
Info: iter =    1 abs_dens = 0.52967163E-03 abs_ener = 0.60356585E+00
Eigenvalues [H]
   #  Eigenvalue   Occupation      Error (1)
   1    -0.102979     1.000000 (  0.00157339)
Info: iter =    2 abs_dens = 0.43190643E-03 abs_ener = 0.19440656E-04
Eigenvalues [H]
   #  Eigenvalue   Occupation      Error (1)
   1    -0.102509     1.000000 (  0.00047779)
Info: iter =    3 abs_dens = 0.60478810E-04 abs_ener = 0.57300542E-05
Eigenvalues [H]
   #  Eigenvalue   Occupation      Error (1)
   1    -0.102419     1.000000 (  0.00011716)
Info: iter =    4 abs_dens = 0.24075874E-04 abs_ener = 0.18799904E-06
Eigenvalues [H]
   #  Eigenvalue   Occupation      Error (1)
   1    -0.102437     1.000000 (  0.00000170)
Info: iter =    5 abs_dens = 0.24608978E-06 abs_ener = 0.26917229E-08
Info: SCF converged in    5 iterations
Info: Deallocating rpsi.
Info: Calculation ended on 2002/07/10 at 12:35:34
 STOP
@end example
Take now a look at the 
working directory. It should include the following files:
@example
-rw-rw-r--    1 user  group       177 Jul 10 12:29 inp
-rw-rw-r--    1 user  group      4186 Jul 10 12:35 out
-rw-rw-r--    1 user  group      1626 Jul 10 12:35 out.oct
drwxrwxr-x    2 user  group      4096 Jul 10 12:35 static
drwxrwxr-x    2 user  group      4096 Jul 10 12:35 tmp
@end example

Besides the initial file (@code{inp}) and the @code{out} file, two new
directories appear. In @code{static}, you will find the file @code{info},
with information about the static calculation (it should be hopefully
self-explanatory, otherwise please complain to the authors).
In @code{tmp}, you will find the @code{restart.static}, a binary
file containg restart information about the ground-state, which is used if, for example,
you want to start a time-dependent calculation afterwards.
Finally, you can safely ignore @code{out.oct}: it is an output from 
the liboct library, irrelevant in what concerns physics ;).

@strong{Exercises} :
@itemize @bullet
@item Study how the total energy and eigenvalue of the sodium atom improve
  with the mesh spacing.

@item Calculate the static polarizability of the sodium atom (@code{CalculationMode = 7}).
  Two new files will be generated: @code{restart.pol} that can be used to resume
  the polarizability calculation, and @code{Na.pol} that contains the static polarizability
  tensor. Note that this calculation overwrites @code{tmp/restart.static}, so that
  what now is there is the ground state for the system @emph{with} an external static
  electrical field applied. Delete it since it is useless.

@item Calculate a few unoccupied states (@code{CalculationMode = 3}). The eigenspectrum
  will be in the file @code{eigenvalues}. Why don't we find a Rydberg series in the
  eigenspectrum?

@item Repeat the previous calculation with PBE, LB94, and exact exchange. 
  Don't forget to @strong{move} the file @code{tmp/restart.static} when switching
  between exchange-correlation functionals.

@item Perform a time-dependent evolution (@code{CalculationMode = 5}), to calculate
  the optical spectrum of the Na atom. Use a @code{TDDeltaStrength = 0.05}, polarised
  in the @code{x} direction. The multipole moments of the density are output to
  the file @code{td.general/multipoles}. You can process this file with the utility
  @code{strength-function} to obtain the optical spectrum. 
  If you have computer time to waste, re-run the time-dependent 
  simulation for some other xc choices.

@end itemize

@node Benzene,  , Hello world, Examples
@subsection Benzene

Well, the sodium atom is a bit too trivial. Let's try something harder: benzene.
you will just need the
geometry for benzene to be able to play. Here it is (in @AA{}):
@example
 C  0.000  1.396  0.000
 C  1.209  0.698  0.000
 C  1.209 -0.698  0.000
 C  0.000 -1.396  0.000
 C -1.209 -0.698  0.000
 C -1.209  0.698  0.000
 H  0.000  2.479  0.000
 H  2.147  1.240  0.000
 H  2.147 -1.240  0.000
 H  0.000 -2.479  0.000
 H -2.147 -1.240  0.000
 H -2.147  1.240  0.000
@end example

Follow now the steps of the previous example. Carbon and Hydrogen have a much harder
pseudo-potential than Sodium, so you will probably have to use a tighter
mesh. It also takes much more time...

@c ***************THE END OF THE DOCUMENT********************************
@node    Options Index,  , Examples, Top
@unnumbered Options Index
     
@printindex vr
     
@contents

@bye
@c **********************************************************************
