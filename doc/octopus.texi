\input texinfo @c -*-texinfo-*- 
@c %**start of header
@setfilename octopus.info 
@settitle the @code{octopus} manual
@c %**end of header

@c This is to install octopus into the info main tree.
@dircategory Individual utilities
@direntry
* octopus: (octopus).           The octopus program.
@end direntry


@copying
This manual is for octopus 1.3, a first principles, electronic
structure, excited states, time-dependent density functional
theory program.

Copyright @copyright{} 2002, 2003
Miguel A. L. Marques, Alberto Castro and Angel Rubio





@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.1 or
any later version published by the Free Software Foundation.
@end quotation
@end copying







@titlepage

@title the @code{octopus} manual
@subtitle Electronic Structure
@subtitle Molecular Dynamics
@subtitle Excited-State Dynamics
@subtitle Recipes-Generator
@subtitle March 2002
@sp 4
@image{octosex,8cm,}
@center Male Hapalochlaena lunulata (top),
@center and female Hapalochlaena lunulata (bottom).
@center Photograph by Roy Caldwell.

@sp 2
@author By Miguel A. L. Marques, Alberto Castro and Angel Rubio.

San Sebasti@'an (Spain), Valladolid (Spain), Berlin (Germany).

@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage





@iftex
@headings off
@c @evenheading @thispage{}            @| @thistitle @| @image{octosex,1.7cm}
@c @oddheading  @image{octosex,1.75cm} @| @thischapter  @| @thispage{} 
@evenheading @thispage{}            @| @thistitle @|
@oddheading  @| @thischapter  @| @thispage{} 
@end iftex



@ifnottex
@node Top, Copying, (dir), (dir)
@top octopus
@insertcopying
@end ifnottex

@ifhtml
@image{octosex,8cm}
@center Male Hapalochlaena lunulata (top),
@center and female Hapalochlaena lunulata (bottom).
@center Photograph by Roy Caldwell.
@end ifhtml

@menu
* Copying::                     
* Authors::                     
* Introduction::                
* Installation::                
* The parser::                  
* Input file options::          
* External utilities::          
* Examples::                    
* Options Index::               

@detailmenu
 --- The Detailed Node Listing ---

Introduction

* Description of octopus::      
* Time dependent density functional theory::  

Installation

* Quick instructions::          
* Long instructions::           
* Troubleshooting::             

Input file options

* Generalities::                
* Species Block::               
* Coordinates Description::     
* Mesh::                        
* States::                      
* Hamiltonian::                 
* Exchange and correlation::    
* SCF::                         
* Unoccupied States::           
* Time Dependent::              
* Geometry optimization::       
* Function output for visualization::  
* Spectrum calculations::       
* Varia::                       

Generalities

* SystemName::                  
* Dimensions::                  
* CalculationMode::             
* Units::                       
* UnitsInput::                  
* UnitsOutput::                 
* Verbose::                     
* DebugLevel::                  

Species Block

* Species::                     

Coordinates Description

* PDBCoordinates::              
* XYZCoordinates::              
* Coordinates::                 
* XYZVelocities::               
* Velocities::                  
* RandomVelocityTemp::          

Mesh

* BoxShape::                    
* Radius::                      
* Lsize::                       
* ZLength::                     
* Spacing::                     
* DerivativesSpace::            
* OrderDerivatives::            
* DoubleFFTParameter::          
* FFTOptimize::                 

States

* SpinComponents::              
* NumberKPoints::               
* ExcessCharge::                
* ExtraStates::                 
* Occupations::                 
* ElectronicTemperature::       

Hamiltonian

* NonInteractingElectrons::     
* ClassicPotential::            
* LocalPotentialSpace::         
* RelativisticCorrection::      

Exchange and correlation

* XFunctional::                 
* CFunctional::                 

SCF

* MaximumIter::                 
* ConvAbsDens::                 
* ConvRelDens::                 
* ConvAbsEv::               
* ConvRelEv::               
* LCAOStart::                   
* SCFinLCAO::                   
* EigenSolver::                 
* EigenSolverInitTolerance::    
* EigenSolverFinalTolerance::   
* EigenSolverFinalToleranceIteration::  
* EigenSolverMaxIter::          
* What2Mix::                    
* TypeOfMixing::                
* Mixing::                      
* MixNumberSteps::              

Unoccupied States

* UnoccNumberStates::           
* UnoccMaximumIter::            
* UnoccConv::                   

Time Dependent

* TDMaximumIter::               
* TDTimeStep::                  
* TDExponentialMethod::         
* TDExpOrder::                  
* TDLanczosTol::                
* TDEvolutionMethod::           
* TDLasers::                    
* TDGauge::                     
* TDDeltaStrength::             
* TDPolarization::              
* TDDipoleMax::                 
* TDOutputMultipoles::          
* TDOutputCoordinates::         
* TDOutputGSProjection::        
* TDOutputAcceleration::        
* TDOutputLaser::               
* TDOutputElEnergy::            
* TDOutputOccAnalysis::         
* MoveIons::                    
* AbsorbingBoundaries::         
* ABWidth::                     
* ABHeight::                    

Geometry optimization

* GOMethod::                    
* GOTolerance::                 
* GOMaxIter::                   
* GOStep::                      

Function output for visualization

* OutputKSPotential::           
* OutputDensity::               
* OutputWfs::                   
* OutputWfsNumber::             
* OutputElf::                   
* OutputGeometry::              
* OutputAxisX::                 
* OutputAxisY::                 
* OutputAxisZ::                 
* OutputPlaneX::                
* OutputPlaneY::                
* OutputPlaneZ::                
* OutputDX::                    
* OutputNETCDF::                
* OutputEvery::                 

Spectrum calculations

* SpecTransformNode::           
* SpecDampMode::                
* SpecDampFactor::              
* SpecStartTime::               
* SpecEndTime::                 
* SpecEnergyStep::              
* SpecMinEnergy::               
* SpecMaxEnergy::               
* HSPolarization::              

Varia

* PoissonSolver::               
* POLStaticField::              
* Displacement::                

External utilities

* oct-sf::                      
* oct-rsf::                     
* oct-hs-mult::                 
* oct-hs-acc::                  
* oct-xyz-anim::                
* oct-excite::                  
* oct-broad::                   
* oct-make-st::                 
* oct-choose-st::               
* oct-center-geom::             
* wf.net::                      

Examples

* Hello world::                 
* Benzene::                     

@end detailmenu
@end menu

@c ***************THE BODY OF THE DOCUMENT*******************************

@c ***************COPYING************************************************
@node Copying, Authors, Top, Top
@chapter Copying

This program is ``free''; this means that everyone is free to use it and free to
redistribute it on a free basis.
What is not allowed is to try to prevent others from further sharing
any version of this program that they might get from you.

Specifically, we want to make sure that you have the right to give
away copies of the program, that you receive
source code or else can get it if you want it, that you can change this
program or use pieces of them in new free programs, and that you know
you can do these things.

To make sure that everyone has such rights, we have to forbid you to
deprive anyone else of these rights.  For example, if you distribute
copies of the program, you must give the recipients all
the rights that you have.  You must make sure that they, too, receive or
can get the source code.  And you must tell them their rights.

Also, for our own protection, we must make certain that everyone finds
out that there is no warranty for this program.
If these programs are modified by someone else and passed on, we want
their recipients to know that what they have is not what we distributed,
so that any problems introduced by others will not reflect on our
reputation.

The precise conditions of the license 
are found in the General Public
Licenses that accompany it.

@c ********************AUTHORS, COLLABORATORS AND ACKNOWLEDGEMENTS*******
@node Authors, Introduction, Copying, Top
@chapter Authors, Collaborators and Acknowledgements.

The main developing team of this program is composed of:

@itemize @bullet
@item Miguel A. L. Marques 
(Freie Universit@"at, Berlin, Deutschland), 
@item Angel Rubio, 
(Donostia International Physics Center and Department of Materials Science
UPV/EHU, San Sebasti@'{a}n, Espa@~na), and 
@item Alberto Castro, 
(Universidad de Valladolid, Departamento de
F@'{@dotless{i}}sica Te@'orica, Valladolid, Espa@~na).
@end itemize

@code{octopus} is based on a fixed-nucleus code written by
George F. Bertsch and K. Yabana to perform real-time dynamics in
clusters (Phys Rev B @strong{54}, 4484 (1996))
and on a condensed matter real-space plane-wave based code written 
by A. Rubio, X. Blase and S.G. Louie 
(Phys. Rev. Lett. @strong{77}, 247 (1996)). 
The code was afterwards extended to handle periodic systems by  
G.F. Bertsch, J.I. Iwata, A. Rubio, and K. Yabana
(Phys. Rev. B, @strong{62}, 7998 (2000)). Contemporaneously there was
a major rewrite of the original cluster code to handle a vast majority 
of finite systems. At this point the cluster code was
named ``tddft''.

This version was consequently enhanced and beautified by A. Castro 
(at the time Ph.D. student of A. Rubio), originating a fairly verbose 15,000 
lines of Fortran 90/77. In the year 2000, M. Marques (aka Hyllios, 
aka Ant@'onio de Faria, cors@'ario portugu@^es), joined the A. Rubio group 
in Valladolid as a postdoc. Having to use ``tddft'' for his work, and being 
petulant enough to think he could structure the code better than his 
predecessors, he started a major rewrite of the code together with A. Castro, 
finishing version 0.2 of ``tddft.'' But things were still not perfect: due to 
their limited experience in Fortran 90, and due to the inadequacy of this 
language for anything beyond a HELLO WORLD program, several parts of the code 
were still clumsy. Also the idea of GPLing the almost 20,000 lines arose 
during an alcoholic evening. So after several weeks of fantic coding and 
after getting rid of the Numerical Recipes code that still lingered around, 
@code{octopus} was born.

The present released version has been completely rewritten and keeps
very little relation to the old version (even input and output files) and has
been enhanced with major new flags to perform various excited-state
dynamics in finite and extended systems (one-dimensional periodic
chains). The code will be updated frequently and new versions can 
be found @uref{http://www.tddft.org/programs/octopus, here}.

The main features of the present version are described in detail in
@emph{octopus: a first principles tool for excited states electron-ion
dynamics}, Comp. Phys. Comm. @strong{151}, 60 (2003).
Updated references as well
as results obtained with octopus will be posted regularly to the @code{octopus}
web page. If you find the code useful for you research we would appreciate
if you give reference to this work and previous ones.

If you have some free time, and if you feel like taking a joy ride with
Fortran 90, just drop us an @email{octopus@@tddft.org, email}. You can
also send us patches, comments, ideas, wishes, etc. They will be included
in new releases of octopus.  

@c ********************* INTRODUCTION ***********************************
@node Introduction, Installation, Authors, Top
@chapter Introduction

@ifinfo
[Note to info readers:
The preferred way to read this manual is in its pdf or dvi versions,
since there are quite a few equations that will not print out well
in info format. However, we have tried to make the info format
readable. For this purpose, we have chosen the following convention:
instead of removing the equations in the info files, 
they will show up as the TeX commands that produce them in the printed
documentation]
@end ifinfo

@menu
* Description of octopus::      
* Time dependent density functional theory::  
@end menu

@node  Description of octopus, Time dependent density functional theory, Introduction, Introduction
@section Description of @code{octopus}
     
@code{octopus} @footnote{
@emph{octopus}: Etymology: New Latin @emph{Octopod-}, @emph{Octopus}, 
from Greek @emph{oktOpous}.
Any of a genus (@emph{Octopus}) of cephalopod mollusks that have 
eight muscular arms equipped with two rows of suckers; 
broadly, any octopod excepting the paper nautilus.
Something that resembles an octopus especially in having many 
centrally directed branches.
(Taken from the Merryam-Webster's dictionary.)
}
is a program aimed at the ab initio virtual experimentation on
electron/ion dynamics in external electromagnetic fields of arbitrary
intensity, shape and frequency in  
a hopefully ever increasing range of systems types. Its 
main characteristics are:

@itemize @bullet

@item Electrons are described quantum-mechanically within the
Density-Functional Theory (DFT) for the ground-state whereas the
excitation spectra is computed using time-dependent form (TDDFT)
by performing simulations in time.  

@item The electron-nucleus interaction is described within the
pseudo-potential approximation. Nuclei are described classically
as point particles. 

@item Wave-functions are expanded in a real-space grid. The kinetic
energy operator is computed with a high-order finite difference method.
FFTs are used in part of the calculations.
Time and grid spacing are related by imposing a stable time-evolution.

@item Forces on the ions are computed through the Ehrenfest theorem. 
Extension to quantum mechanical nuclear dynamics is in progress.

@item Allows for spin-polarised calculations as well as 
non-collinear magnetism and spin-orbit effects.

@item Computes photo-electron (energy and angle resolved)
and photo-absorption spectra for different polarised external electromagnetic
fields. Linear response calculations are a simple case of this
general time-evolution procedure (see below).

@item Includes non-linear electronic effects: high-harmonic generation,
interaction with a laser pulse of arbitrary intensity. For the time being
only time- and spatially-dependent electric fields are included, in the future
magnetic fields will be incorporated.

@item Reads different geometry files including protein-data-base (PDB) for
biological calculations (interaction of biomolecules with electromagnetic
fields).

@item It allows for one and two dimesional modes by using for
example the soft-coulomb potential or any other given as input.

@item Laser-pulse optimisation using genetic algorithms (to be done).

@item Utilities to analyse the computed spectra.

@item A very effective and easy-to-use parser to handle the input file.

@end itemize

@node  Time dependent density functional theory,  , Description of octopus, Introduction
@section Time dependent density functional theory

Several reviews of time-dependent density function theory (TDDFT)
and its applications have appeared recently, like the works by 
Gross et al. @footnote{
  Gross, E.K.U., C.A. Ullricht and U.J. Grossmann, 1994, in
  @emph{Density Functional Theory}, (NATOP ASI Series), p.194;
  Gross, E.K.U., F. J. Dobson, and M. Petersilka, 1996, 
  @emph{Density Functional Theory} (Springer, New York).
}, Casida @footnote{
  Casida, M.E., 1995, in @emph{Recent Advances in Density Functional Methods},
  Part I, ed. D.P. Chong (World Scientific, Singapore), p.155;
  Casida, M.E., 1996, in @emph{Recent Developments and Applications of Modern
  Density Functional Theory}, ed. J.M. Seminario (Elsevier Science,
  Amsterdam), p.391
},
Dobson et al, @footnote{
  Dobson, J , G. Vignale and M.P. Das (Eds), 1997a, 
  @emph{Electronic Density Functional Theory: Recent Progress and New Directions}
  (Plenum, New York)  
}
, and Burke et al @footnote{
  Burke, K., M. Petersilka and E.K.U. Gross, 2001, in
  @emph{Recent Advances in Density Functional Methods}, edited by P.
  Fantucci and A. Bencini (World Scientific, Singapure).  
}.

The Hohenberg-Kohn-Sham theory as described is a ground state theory, and
it is hence not meant for the calculation of electronic excitations.
However, one can extend the ideas of static DFT. When one asks for the 
evolution of the system under the influence of a time-dependent external
potential, one should search the extrema of the quantum mechanical
action

@ifnottex
  A = \int_t0^t1 dt  <\psi(t) | i\partial_t -H(t) | \psi>
@end ifnottex
@tex
$$
  A = \int_{t_0}^{t_1} {\rm d}t
  \langle \Psi(t) \vert {\rm i} {\partial \over \partial t} - H(t) \vert
  \Psi(t) \rangle,
$$
@end tex

Theorems have now been established for time-dependent DFT@footnote{
Runge, E. and E. K. U. Gross, 1984, Phys. Rev. Lett. @strong{52} 997.
}
which are parallel to those of static DFT.
The first theorem proves a one-to-one mapping between time-dependent
potentials and time-dependent densities; the second proves the 
stationary-action principle.

The proof of the first theorem is based directly on the evolution of
the time-dependent Schr@"odinger equation from a fixed initial
many-particle state @math{\Psi(t_0)=\Psi_0}
under the influence of a time-dependent potential @math{v(t)}
required to be expandable in a Taylor series around @math{t_0.}
The initial state @math{\Psi_0}
does not need to be the ground state or some other eigenstate of the 
initial potential.  As one does not rely on the adiabatic connection as in standard
zero-temperature many-body perturbation theory the formalism is able to 
handle external perturbations varying fast in time. By virtue of the first 
theorem, the time-dependent density determines the external
potential uniquely up to an additive purely time-dependent function.
On the other hand, the potential determines the time-dependent wave-function,
therefore the expectation value of any quantum mechanical operator
is a unique functional of the density.

The second theorem deals with the variational principle of the action
functional with the initial condition 
@math{\Psi(t_0)=\Psi_0.}
From the previous one-to-one mapping between time-dependent
potentials and densities, the action is a functional of the density
that must have a stationary point at the correct time-dependent
density.
Thus the Euler equation corresponding to the extrema of 
@math{A[\rho],}

@ifnottex
  \delta A[\rho] / \delta \rho(r) = 0,
@end ifnottex
@tex
$$
  {\delta A[\rho] \over \delta \rho({\bf r},t)} =0,
$$ 
@end tex

determines the time-dependent density, just
as in the Hohenberg-Kohn formalism the static ground state
density is given by the minimum of the total energy
(@math{\delta E[\rho]/\delta \rho({\bf r},t)=0}).

Similarly, one can define a time-dependent Kohn-Sham (KS) scheme by
introducing a non-interacting system that reproduces the exact
interacting density @math{\rho({\bf r},t)}.
One gets the following time-dependent KS-equations:

@ifnottex
  ( 1/2 \nabla^2 + V_eff(r,t) ) \psi_i(r,t)  = i \partial_t \psi_i(r,t)
@end ifnottex

@ifnottex
  \rho(r,t) = V_H(r,t) = \sum_i=1^N |\psi_i(r,t)|^2
@end ifnottex
@tex
$$
  \left[ - {1 \over 2} \nabla^2 + V_{\rm eff}({\bf r},t)
  \right] \psi_i({\bf r},t) = {\rm i}{\partial\over\partial t} \psi_i({\bf
  r},t),
$$
$$
  \rho({\bf r},t) = \sum_{i=1}^N \vert \psi_i({\bf r},t) \vert^2
$$
@end tex

where 

@ifnottex
  V_eff(r,t) = V_H(r,t) + V_xc(r,t) + V_ext(r,t)
@end ifnottex
@tex
$$
  V_{\rm eff}({\bf r},t)= V_{\rm H}({\bf r},t) + V_{\rm xc}({\bf r},t)+
  V_{\rm ext}({\bf r},t)
$$
@end tex 

is the effective
time-dependent potential felt by the electrons. It consists of
the sum of the external time-dependent applied field,
the time-dependent Hartree term, plus the  xc potential (defined
through the equivalence between the interacting and fictitious
non-interacting systems). The variational principle yields

@ifnottex
  V_xc(r,t) = \delta A_xc[\rho] / \delta \rho(r,t).
@end ifnottex
@tex 
$$
  V_{\rm xc}({\bf r},t) = 
  {\delta A_{\rm xc}[\rho] \over \delta \rho({\bf r},t)},
$$ 
@end tex

where @math{A_{\rm xc}[\rho]}
is the xc part of the action functional.

The main advantage of the time-dependent KS scheme lies in its
computational simplicity compared to other quantum-chemical models 
such as time-dependent Hartree-Fock or configuration interaction.

@c *************************INSTALLATION*********************************
@node Installation, The parser, Introduction, Top
@chapter Installation

@menu
* Quick instructions::          
* Long instructions::           
* Troubleshooting::             
@end menu

@node Quick instructions, Long instructions, Installation, Installation
@section Quick instructions

For the inpatients, here goes the quick-start: 
@example
prompt> gzip -cd octopus<-version>.tar.gz | tar xvf -
prompt> cd octopus-<version>
prompt> ./configure
prompt> make
prompt> make install
@end example

This will probably @strong{not} work, so before giving up, just read
the following paragraphs.

Also, rpm and deb binaries for linux are supplied on the web-page.

@node Long instructions, Troubleshooting, Quick instructions, Installation
@section Long instructions

The code is written in standard Fortran 90, with some routines written
in C (and in bison, if we count the input parser). To build it
you will need both a C compiler (@code{gcc} works just fine), and a
Fortran 90 compiler. No free-software Fortran 90 compiler is available yet,
so, if you want to chew the @code{octopus}, you will have either
to help the @uref{http://g95.sourceforge.net, g95} project
or use any of the available comercial compilers.

Besides the compiler, you will also need:
@enumerate
@item @code{make}:  most computers have it installed, otherwise just
grab and install the GNU @code{make}.

@item @code{cpp}: The C preprocessor is heavily used in @code{octopus}.
GNU @code{cpp} is just fine, but any @code{cpp} that accepts
the @code{-C} flag (preserve comments) should work just as well.

@item @sc{fftw}: We have relied on this great library to perform the Fast
Fourier Transforms (FFTs). You may grab it from @uref{http://www.fftw.org/, here}.
You may use @sc{fftw} version 2 as well as @sc{fftw} version 3. @code{octopus} will try
first to use the latter one, since it is significantly faster in some
architectures.

@item @sc{lapack/blas}: Required. Our politics is to rely on these two libraries
as much as possible on these libraries for the linear algebra operations. 
If you are running Linux,
there is a fair chance they are already installed in your system. The same
goes to the more heavyweight machines (alphas, IBMs, SGIs, etc.). Otherwise,
just grab the source from @uref{http://www.netlib.org, here}.

@item @sc{gsl}: Finally that someone had the nice idea of making a public scientific
library! @sc{gsl} still needs to grow, but it is already quite useful and impressive.
@code{octopus} uses splines, complex numbers, special functions, etc. from @sc{gsl},
so it is a must! If you don't have it already installed in your system, you can
obtain GSL from @uref{http://sources.redhat.com/gsl/, here}. You will need version 1.0 
or higher.

@item @sc{mpi}: If you want to run @code{octopus} in multi-tentacle (parallel) mode,
you will need an implementation of MPI. 
@uref{http://www-unix.mcs.anl.gov/mpi/mpich/, @sc{mpich}} works just fine in our
Linux boxes.

@end enumerate

First you should obtain the code file, @code{octopus<-version>.tar.gz},
(this you probably have already done). The code is freely available, and
can be downloaded from @uref{http://www.tddft.org/programs/octopus}. There exists
a @code{cvs} server, which you can browse at 
@uref{http://nautilus.fis.uc.pt/cgi-bin/cvsweb.cgi/marques/octopus/}. 
The sources of the cvs version (in general more unstable the the @emph{official}
distribution) may be downloaded by anonymous cvs access:

@example
prompt> cvs -d :pserver:anonymous@@nautilus.fis.uc.pt:/server/cvsroot 
        login

prompt> cvs -d :pserver:anonymous@@nautilus.fis.uc.pt:/server/cvsroot 
        co marques/octopus
@end example


Uncompress
and untar it (@code{gzip -cd octopus<-version>.tar.gz | tar -xvf -}).
In the following, @code{OCTOPUS-HOME} denotes the home directory of
octopus, created by the @code{tar} command.

The @code{OCTOPUS-HOME} contains the following subdirectories:
@itemize @bullet
@item @code{autom4te.cache, build, CVS, debian}: contains files related 
to the building system or the CVS repository. May actually not be there. 
Not of real interest for the plain user.
@item @code{doc}: The documentation of @code{octopus} in @emph{texinfo} format.
@item @code{liboct}: Small C library that handles the interface to
GSL and the parsing of the input file. It also contains some assorted
routines that we didn't want to write in boring Fortran.
@item @code{samples}: Sample input files for @code{octopus}.
@item @code{share}: Made to contain ``auxiliary'' files eventually used by the code;
in practice now it contains the Troullier-Martins and Hartwigsen-Goedecker-Hutter
pseudopotential files.
@item @code{share/util}: Currently, the @emph{utilities} include a couple of IBM
OpenDX networks (@pxref{wf.net}), to visualize wavefunctions, densities, etc.
@item @code{src}: Fortran 90 source files. Note that these have to be preprocessed
before being fed to the Fortran compiler, so do not be scared by
all the # directives.
@end itemize

Before configuring you can (should) setup a couple of options. Although
the configure script tries to guess your system settings for you, we recommend 
that you set explicitly the default Fortran 90 compiler and the compiler options. 
For example, in @code{bash} you would typically do:
@example
export F90=abf90
export F90FLAGS="-O -YEXT_NAMES=LCS -YEXT_SFX=_"
@end example
if you are using the Absoft Fortran 90 compiler on a linux machine.
Also, if you have some of the required libraries in some unusual directories,
these directories may be placed in the variable @code{LDFLAGS} (e.g.,
@code{export LDFLAGS=$LDFLAGS:/opt/lib/}).

You can now run the configure script (@code{./configure}). 
@footnote{
If you downloaded the cvs version, you will not find the @code{configure} script. 
In order to compile the development version you will first have to run the GNU autotools.
This may be done by executing the script @code{./autogen.sh}. 
Note that you need to have working versions of the @code{automake} (1.7.3), 
@code{autoconf} (2.57) and @code{libtool} (1.4.3) programs (the versions we 
currently use are between parentheses). Note that the @code{autogen.sh} script will likely fail if
you have (much) older versions of the autotools.
}
You can use
a fair amount of options to spice @code{octopus} to your own taste.
To obtain a full list just type @code{./configure --help}. Some 
commonly used options include:
@itemize @bullet
@item
@code{--prefix=PREFIX}: Change the base installation dir of @code{octopus}
to @code{PREFIX}. The executable will be installed in @code{PREFIX/bin},
the libraries in @code{PREFIX/lib} and the documentation in @code{PREFIX/info}.
@code{PREFIX} defaults to the home directory of the user who runs @code{configure}.
@item
@code{--enable-fft=fftw2}: Instruct the @code{configure} script to use the @sc{fftw}
library, and specifically to use the @sc{fftw} version 2. You may also
set @code{--enable-fft=fftw3} or even @code{--disable-fft}.
@item
@code{--with-lapack=DIR}: Installation directory of the @sc{lapack} and
@sc{blas} libraries.
@item
@code{--with-gsl-prefix=DIR}: Installation directory of the GSL library. The
libraries are expected to be in @code{DIR/lib} and the include
files in @code{DIR/include}. The value of @code{DIR} is usually found by
issuing the command @code{gsl-config --prefix}. (If the GSL library is
installed, the program @code{gsl-config} should be somewhere.)
@item
@code{--enable-mpi}: Builds the parallel version (MPI) of @code{octopus}.
@item
@code{--enable-complex}: Builds a version with complex wave-functions
for the ground-state calculations (wave-functions are always complex for
the evolution). This is needed when spinors are needed --- e.g. noncollinear
magnetism is going to be considered, or the spin-orbit coupling term will
be used.
@item
@code{--enable-debug}: Builds a version that is able to emit some
debugging information. Useful for developers, or to report bugs. If @code{octopus}
has been built with this option enabled, you may set the variable
@code{Verbose} to ``debug'' level, and set @code{DebugLevel} 
(@pxref{Verbose} and @pxref{DebugLevel}, respectively). 
@end itemize

Run @code{make}, and then @code{make install}. If everything went fine, you
should now be able to taste @code{octopus}. Depending on the options passed to
the configure script, some suffixes or prefixes could be added to the generic
name @code{octopus} --- i.e. @code{zoctopus} for the code compiled for
complex wave-functions, @code{zoctopus-mpi} for a parallel version of the code compiled for
complex wave-function, and so on.

The program has been tested in the following platforms:
@itemize @bullet
@item @code{i686*-linux-gnu}: with the @uref{http://www.absoft.com, Absoft},
  and the @uref{http://www.intel.com/software/products/compilers/, Intel} compiler.
@item @code{alphae*}: both in Linux and in OSF/1 with Compaq's @code{fort} compiler.
@item @code{powerpc-ibm-aix4.3.3.0}: with native @code{xlf90} compiler.
@item @code{cray}: with native f90 compiler.
@end itemize
If you manage to compile/run @code{octopus} on a different platform
or with a different compiler, please let us know so we can update the
list. Patches to solve compiler issues are also welcomed.

Build the documentation in the format you prefer. Since you are reading
this, you already have it in some format. Due to the power of @code{texinfo},
a series of formats are available, namely @code{dvi}, @code{html},
@code{pdf} and @code{info}. The @code{octopus.texi} source code of this
document is in the @code{OCTOPUS-HOME/doc} directory.

@node Troubleshooting,  , Long instructions, Installation
@section Troubleshooting

If you are reading this it is because something went wrong. Let us see
if we can fix it ;)

@strong{Could not find library...}:
This is probably the most common error you can get. @code{octopus} uses
three different libraries, @code{GSL}, @code{FFTW}, and 
@code{BLAS}/@code{LAPACK}. We assume that you have already
installed these libraries but, for some reason, you were not able to
compile the code. So, what went wrong?
@itemize @bullet

@item Did you pass the correct @code{--with-XXXX} (where XXXX is gsl, fftw or
lapack in lowercase) to the configure script? If your libraries are
installed in a non-standard directory (like @code{/opt/lapack}), you will
have to pass the script the location of the library (in this example,
you could try @code{./configure --with-lapack=/opt/lapack}.

@item If you are working on an alpha station, do not forget that the @code{CXML}
library includes @code{BLAS} and @code{LAPACK}, so it can be used by
@code{octopus}. If needed, just set the correct path with @code{--with-lapack}.

@item If the configuration script can not find @code{FFTW}, it is probable that
you did not compile @code{FFTW} with the same Fortran compiler or with the
same compiler options. The basic problem is that Fortran sometimes converts
the function names to uppercase, at other times to lowercase, and it can
add an ``_'' to them, or even two. Obviously all libraries and the program
have to use the same convention, so the best is to compile everything with
the same Fortran compiler/options. If you are a power user, you can check the
convention used by your compiler using the command @code{nm <library>}.

@end itemize

@strong{Whatever went wrong...}:
Up to now, we cannot really make a list of commonly found problems. So if something
else went wrong, please subscribe to @code{octopus-users} mailing list, and ask.


@c *******************DESCRIPTION OF INPUT OPTION************************
@c @node The input file, External utilities, Installation, Top
@c @chapter Description of input options

@c @menu
@c * The parser::                  
@c * Input file options::          
@c @end menu

@c **********************************************************************
@node The parser, Input file options, Installation, Top
@chapter The parser

All input options should be in a file called ``@code{inp}'', in the
directory @code{octopus} is run from. Alternatively, if this file is not
found, standard input is read. For a fairly comprehensive
example, just look at the file @code{OCTOPUS_HOME/samples/inp}

At the beginning of the program @code{liboct} reads the @code{inp}
file, parses it, and generates a list of variables that will be
read by @code{octopus} (note that the input is case independent). 
There are two kind of variables, scalar
values (strings or numbers), and blocks (that you may view as
matrices). A scalar variable @code{var} can be defined by:
@example
var = exp
@end example
@code{var} can contain any alphanumeric character plus ``_'', and 
@code{exp} can be a quote delimited string, a number (integer,
real, or complex), a variable name, or a mathematical expression. 
In the expressions all arithmetic operators are supported 
(``a+b'', ``a-b'', ``a*b'', ``a/b''; for exponentiation the C syntax
``a^b'' is used), and the following functions can be used:
@itemize @bullet
@item @code{sqrt(x)}: The square root of @code{x}.
@item @code{exp(x)}: The exponential of @code{x}.
@item @code{log(x)} or @code{ln(x)}: The natural logarithm of @code{x}.
@item @code{log10(x)}: Base 10 logarithm of @code{x}.
@item @code{sin(x)}, @code{cos(x)}, @code{tan(x)}, @code{cot(x)},
  @code{sec(x)}, @code{csc(x)}: The sinus, co-sinus, tangent, co-tangent,
  secant and co-secant of @code{x}.
@item @code{asin(x)}, @code{acos(x)}, @code{atan(x)}, @code{acot(x)},
  @code{asec(x)}, @code{acsc(x)}: The inverse (arc-) sinus, co-sinus, tangent, co-tangent,
  secant and co-secant of @code{x}.
@item @code{sinh(x)}, @code{cosh(x)}, @code{tanh(x)}, @code{coth(x)},
  @code{sech(x)}, @code{csch(x)}: The hyperbolic sinus, co-sinus, tangent, co-tangent,
  secant and co-secant of @code{x}.
@item @code{asinh(x)}, @code{acosh(x)}, @code{atanh(x)}, @code{acoth(x)},
  @code{asech(x)}, @code{acsch(x)}: The inverse hyperbolic sinus, co-sinus, tangent, co-tangent,
  secant and co-secant of @code{x}.
@end itemize
You can also use any of the predefined variables:
@itemize @bullet
@item @code{pi}: 3.141592653589793, what else is there to say?
@item @code{e}: The base of the natural logarithms.
@item @code{false} or @code{f} or @code{no}: False in all its flavors. For the
  curious, @code{false} is defined as 0.
@item @code{true} or @code{t} or @code{yes}: The truthful companion of @code{false}. For the
  curious, @code{true} is defined as 1.
@end itemize

Blocks are defined as a collection of values, organised in row and column format.
The syntax is the following:
@example
%var
  exp | exp | exp | ...
  exp | exp | exp | ...
  ...
%
@end example
Rows in a block are separated by a newline, while columns are
separated by the character ``|'' or by a tab. There may be any number of lines and any
number of columns in a block. Note also that each line can have a different
number of columns.

If @code{octopus} tries to read a variable that is not defined in the
@code{inp} file, it automatically assigns to it a default value. All
variables read are output to the file ``@code{out.oct}''. If you are
not sure of what the program is reading, just take a look at it.
Everything following the character ``#'' until the end of the line
is considered a comment and is simply cast into oblivion.



@node Input file options, External utilities, The parser, Top
@chapter Input file options

@code{octopus} has quite a few options, that we will subdivide in different groups.
After the name of the option, its type and default value (when applicable)
are given in parenthesis.


@c **********************************************************************
@menu
* Generalities::                
* Species Block::               
* Coordinates Description::     
* Mesh::                        
* States::                      
* Hamiltonian::                 
* Exchange and correlation::    
* SCF::                         
* Unoccupied States::           
* Time Dependent::              
* Geometry optimization::       
* Function output for visualization::  
* Spectrum calculations::       
* Varia::                       
@end menu

@node Generalities, Species Block, Input file options, Input file options
@section Generalities



@menu
* SystemName::                  
* Dimensions::                  
* CalculationMode::             
* Units::                       
* UnitsInput::                  
* UnitsOutput::                 
* Verbose::                     
* DebugLevel::                  
@end menu

@node SystemName, Dimensions, Generalities, Generalities
@subsection @code{SystemName} (string, 'system')
@vindex @code{SystemName}

A string that identifies the current run. This parameter is used 
to build the names of some files generated by @code{octopus}.
   
@node Dimensions, CalculationMode, SystemName, Generalities
@subsection @code{Dimensions} (integer, 3)
@vindex @code{Dimensions}

@code{octopus} can run in 1, 2 or 3 dimensions, depending on the value of this
variable. Note that not all options may be available in all cases.

@node CalculationMode, Units, Dimensions, Generalities
@subsection @code{CalculationMode} (integer, 1)
@vindex @code{CalculationMode}

It defines the type of simulation to perform. Options are:
  @itemize @minus
    @item @code{gs_start} or @code{1}: Start static calculation.
    @item @code{gs} or @code{2}: Resume static calculation.
    @item @code{unocc_start} or @code{3}: Calculate unoccuppied states.
    @item @code{unocc} or @code{4}: Resume calculation of unoccupied states.
    @item @code{td_start} or @code{5}: Start time-dependent propagation.
    @item @code{td} or @code{6}: Resume time-dependent propagation.
    @item @code{pol_start} or @code{7}: Start static polarizability calculation.
    @item @code{pol} or @code{8}: Resume static polarizability calculation.
    @c @item @code{9}: Perform Born-Oppenheimer MD simulation.
    @item @code{geom} or @code{10}: Perform geometry minimization.
    @item @code{phonon} or @code{11}: Calculates the phonon spectrum of the system.
    @item @code{opt_control} or @code{12}: @emph{Optimum control} mode (experimental).
    @item @code{recipe} or @code{99}: Print out an octopus recipe.
  @end itemize

@node Units, UnitsInput, CalculationMode, Generalities
@subsection @code{Units} (string, 'a.u')
@vindex @code{Units}

Atomic units seem to be the preferred system in the atomic and
molecular physics community (despite the opinion of some of the authors
of this program). Internally, the code works in atommic units. However, for input
or output, some people like using eV for energies and @AA{} 
for lengths. This other system of units (the @emph{convenient system}, 
in words of Prof. George F. Bertsch), can also be used. See the Frequently
Asked Questions for some more details.
Valid options are:
@itemize @minus
  @item @code{'a.u'}: atomic units
  @item @code{'eVA'}: electron-volts/@aa{}ngstr@"om
@end itemize

@node UnitsInput, UnitsOutput, Units, Generalities
@subsection @code{UnitsInput} (string, 'a.u.'):
@vindex @code{UnitsInput}

Same as @code{Units}, but only refers to the values in the input file.
That is, if @code{UnitsInput = "eVA"}, all physical values in the input
files will be considered to be in eV and @AA{}.

@node UnitsOutput, Verbose, UnitsInput, Generalities
@subsection @code{UnitsOutput} (string, 'a.u.')
@vindex @code{UnitsOutput}

Same as @code{Units}, but only refers to the values in the output files.
That is, if @code{UnitsOutput = "eVA"}, all physical values in the output
files will be written in eV and @AA{}.

@node Verbose, DebugLevel, UnitsOutput, Generalities
@subsection @code{Verbose} (integer, 30)
@vindex @code{Verbose}

Verbosity level of the program. The higher, the
more verbose @code{octopus} is. Current levels are:
@itemize @minus
@item @code{verbose <=  0}: Silent mode. No output except fatal errors.
@item @code{verbose >   0}: Warnings only.
@item @code{verbose >  20}: Normal program info.
@item @code{verbose > 999}: Debug mode. Issues a message to standard error 
every time the  program enters an (important) subroutine, and 
prints the time it spend upon return.
@end itemize

@node DebugLevel,  , Verbose, Generalities
@subsection @code{DebugLevel} (integer, 3)
@vindex @code{DebugLevel}

In debug mode (@code{Verbose > 999}), it restricts the output 
of entry/exit subroutine information to the required level.

@node Species Block, Coordinates Description, Generalities, Input file options
@section Species Block

@menu
* Species::                     
@end menu

@node Species,  , Species Block, Species Block
@subsection @code{Species} (block data)
@vindex @code{Species}

A specie is by definition an ion (nucleus + core electrons) described
through a pseudo-potential, or a model potential.
The format of this block is different for 1, 2 or 3 dimensions, and
can be best understood through examples. 

@itemize @bullet

@item In 1D, or 2D, e.g.
@example
  %Species
    'H'  | 1.0079 | 1 | "-1/sqrt(x^2 + 1)"
  %
@end example
This defines a species labelled '@code{H}' of weight @code{1.0079},
and valence charge @code{1}. This ``valence charge'' is used to calculate
the number of electrons present in the calculation: as many
as indicated by the valence charges of the species, plus any extra charge
specified by the user (@pxref{States}). Last field may be
any user defined potetial -- use @code{x}, @code{r} (and @code{y} in the 2D case) for the 
position of the electron relative to the species center.
For example. the potential often used in 1D calculations is the soft-Coulomb 
potential -Z/sqrt(x*x + 1).

@item In 3D, e.g.
@example
  %Species
    'O'       | 15.9994 | 8   | "tm2"  | 1 | 1
    'H'       |  1.0079 | 1   | "hgh"  | 0 | 0
    'jelli01' | 23.2    | 8.0 |  5.0
    'point01' | 32.3    | 2.0
    'usdef'   | 1 | 8 | "1/2*r^2"
  %
@end example
In this case, we have 5 ``species'' present:
@itemize @minus
@item Oxygen labelled '@code{O}'. Next number is the atomic mass (in atomic 
mass units), and third field, the atomic number (8, in this case).
Afterwards, "tm2" is the flavour of the pseudopotential: ``tm2'' stands
for Troullier-Martins. This means the pseudopotential will be 
read from an @code{O.ascii} or @code{O.vps} file, either in the working
directory or in the @code{OCTOPUS-HOME/share/PP/TM2} directory.
Next two numbers are the maximum 
@emph{l}-component of the pseudo-potential to consider in the
calculation, and the @emph{l}-component to consider as local.
@item Hydrogen defined in the same way as Oxygen. In this case, however, the
flavour is ``hgh'' standing for Hartwigsen-Goedecker-Hutter. Last two numbers
are irrelevant.
@item All species whose label starts by 'jelli' are jellium spheres.
The other parameters are the weight, the nuclear charge, and the
valence charge of the sphere.
@item All species whose label starts by 'point' are point charges.
The other parameters are the weight and the nuclear charge. In
fact, point charges are implemented as @emph{rather small} jellium
spheres, with zero valence charge.
@item All species whose label starts by 'usdef' are user defined
potentials. The second parameter is the mass, whereas the third parameter
is the 'valence charge', used to calculate the number of electrons.
Finally, the potential itself is defined by the fourth argument.
Use any of the @code{x}, @code{y}, @code{z} or @code{r} variables
to define the potential.

Note that additional pseudopotentials can be downloaded from the
@uref{http://www.tddft.org/programs/octopus/pseudo.php, @code{octopus} homepage}.

@end itemize
@end itemize


@c **********************************************************************
@node Coordinates Description, Mesh, Species Block, Input file options
@section Coordinates Description
@code{octopus} successively tries to read the atomic coordinates from
a PDB file, a XYZ file, or else directly from the @code{inp} file.



@menu
* PDBCoordinates::              
* XYZCoordinates::              
* Coordinates::                 
* XYZVelocities::               
* Velocities::                  
* RandomVelocityTemp::          
@end menu

@node PDBCoordinates, XYZCoordinates, Coordinates Description, Coordinates Description
@subsection @code{PDBCoordinates} (string, 'coords.pdb')
@vindex @code{PDBCoordinates}

Tries to read the atomic coordinates from the file @code{PDBCoordinates}.
The PDB (@uref{http://www.rcsb.org/pdb/,Protein Data Bank}) format is
quite complicated, and it goes well beyond the scope of this manual. You
can find a comprehensive description in 
@uref{http://www.rcsb.org/pdb/docs/format/pdbguide2.2/guide2.2_frame.html}.
From the plethora of instructions defined in the PDB standard, @code{octopus}
only reads 2, @code{ATOM} and @code{HETATOM}. From these fields, it reads:
@itemize @minus
@item columns 13-16 : The specie; in fact @code{octopus} only cares about the first
letter -- 'CA' and 'CB' will both refer to Carbon -- so elements whose
chemical symbol has more than one letter can not be represented in this way.
So, if you want to run mercury ('Hg') please use one of the other two methods
to input the atomic coordinates, @code{XYZCoordinates} or @code{Coordinates}.
@item columns 18-21 : The residue. If residue is 'QM', the atom is treated
in Quantum Mechanics, otherwise it is simply treated as an external classical
point charge. Its charge will be given by columns 61-65.
@item columns 31-54 : The Cartesian coordinates. The Fortran format is
@code{'(3f8.3)'}.
@item columns 61-65 : Classical charge of the atom. The Fortran format is
@code{'(f6.2)'}.
@end itemize

@node XYZCoordinates, Coordinates, PDBCoordinates, Coordinates Description
@subsection @code{XYZCoordinates} (string, 'coords.xyz')
@vindex @code{XYZCoordinates}

If @code{PDBCoordinates} is not present, reads the atomic coordinates
from the XYZ file @code{XYZCoordinates}. The XYZ format is very simple,
as can be seem from this example for the CO molecule (in @AA{}).
@example
2
CO molecule in equilibrium
    C  -0.56415   0.0   0.0
    O   0.56415   0.0   0.0
@end example
The first line of the file has an integer indicating the number of
atoms. The second can contain comments that are simply ignored by 
@code{octopus}. Then there follows one line per each atom, containing
the chemical species and the Cartesian coordinates of the atom.

@node Coordinates, XYZVelocities, XYZCoordinates, Coordinates Description
@subsection @code{Coordinates} (block data)
@vindex @code{Coordinates}

If neither a @code{XYZCoordinates} nor a @code{PDBCoordinates} was found,
@code{octopus} tries to read the coordinates for the atoms from the
block @code{Coordinates}. The format is quite straightforward:
@example
    %Coordinates
      'C' | -0.56415 | 0.0 | 0.0 | no
      'O' |  0.56415 | 0.0 | 0.0 | no
    %
@end example
The first line defines a Carbon atom at coordinates (@code{-0.56415},
@code{0.0}, @code{0.0}), that is @emph{not} allowed to move during
dynamical simulations. The second line has a similar meaning. This
block obviously defines a Carbon monoxide molecule, if the input
units are @AA{}. Note that in this way it is possible to fix some of 
the atoms (this is not possible when specifying the coordinates through
a @code{PDBCoordinates} or @code{XYZCoordinates} file). It is always 
possible to fix @emph{all} atoms using the @code{MoveIons} directive.


@node XYZVelocities, Velocities, Coordinates, Coordinates Description
@subsection @code{Velocities} (string, 'velocities.xyz')
@vindex @code{XYZVelocities}

@code{octopus} will try to read the starting velocities of the atoms from the XYZ file 
@code{XYZVelocities}.

@node Velocities, RandomVelocityTemp, XYZVelocities, Coordinates Description
@subsection @code{Velocities} (block data)
@vindex @code{Velocities}

If @code{XYZVelocities} is not present, @code{octopus} will try to fetch the initial 
atomic velocities from this block. If this block is not present, @code{octopus}
will reset the initial velocities to zero. The format of this block can be
illustrated by this example:
@example
    %Velocities
      'C'  | -1.7 | 0.0 | 0.0
      'O'  |  1.7 | 0.0 | 0.0
    %
@end example
It describes one Carbon and one Oxygen moving at the relative
velocity of @code{3.4}, velocity units.
Note: It is important for the velocities to maintain the ordering 
in which the species were defined in the coordinates specifications.

@node RandomVelocityTemp,  , Velocities, Coordinates Description
@subsection @code{RandomVelocityTemp} (double, 0)
@vindex @code{RandomVelocityTemp}

If this variable is present, @code{octopus} will assign random velocities to the atoms 
following a Bolzmann distribution with temperature @code{RandomVelocityTemp}.



@c **********************************************************************
@node Mesh, States, Coordinates Description, Input file options
@section Mesh

@code{octopus} uses a grid in real space to solve the Kohn-Sham equations.
The grid is equally-spaced, but the spacings can be different for each 
Cartesian direction. The shape of the simulation region may also
be tuned to suit the geometric configuration of the system.


@menu
* BoxShape::                    
* Radius::                      
* Lsize::                       
* ZLength::                     
* Spacing::                     
* DerivativesSpace::            
* OrderDerivatives::            
* DoubleFFTParameter::          
* FFTOptimize::                 
@end menu

@node BoxShape, Radius, Mesh, Mesh
@subsection @code{BoxShape} (integer, sphere)
@vindex @code{BoxShape}

It is the shape of the simulation box. The allowed 
values are:
  @itemize @minus
    @item @code{sphere} or @code{1}: A sphere
    @item @code{cylinder} or @code{2}: A cylinder. The cylinder axis will be 
in the z direction
    @item @code{minimum} or @code{3}: Sum of spheres around each atom.
    @item @code{parallelepiped} or @code{4}: As the name indicates.
  @end itemize
For a 1D calculation, it would obviously always be a 1D ``sphere''.

@node Radius, Lsize, BoxShape, Mesh
@subsection @code{Radius} (double, 20.0 a.u.)
@vindex @code{Radius}

If @code{BoxShape != parallelepiped} defines the radius of the
spheres or of the cylinder. 

@node Lsize, ZLength, Radius, Mesh
@subsection @code{Lsize} (block data)
@vindex @code{Lsize}

In case @code{BoxShape = parallelepiped}, this
is assumed to be a block of the form:
  @example
    %Lsize
      sizex | sizey | sizez
    %
  @end example
where the @code{size*} are half of the lengths of the box in each direction.

@node ZLength, Spacing, Lsize, Mesh
@subsection @code{XLength} (double, 1.0 a.u.)
@vindex @code{XLength}

If @code{BoxShape == cylinder} is half the total length of the cylinder.

@node Spacing, DerivativesSpace, ZLength, Mesh
@subsection @code{Spacing} (double, 0.6 a.u.) or (block data)
@vindex @code{Spacing}

If the code is compiled in 1D mode or if @code{BoxShape != parallelepiped}
defines the (constant) spacing between points in the grid. Otherwise, it
is assumed to be a block of the form:
  @example
    %Spacing
      spacingx | spacingy | spacingz
    %
  @end example

@node DerivativesSpace, OrderDerivatives, Spacing, Mesh
@subsection @code{DerivativesSpace} (integer, real_space)
@vindex @code{DerivativesSpace}

Defines in which space gradients and the Laplacian are calculated. Allowed values are:
  @itemize @minus
    @item @code{real_space} or @code{0}: Derivatives are calculated in real-space
      using finite differences. The order of the derivative can be set with
      @code{OrderDerivatives}.
    @item @code{fourier_space} or @code{1}: Derivatives are calculated in
      reciprocal space. Obviously this case implies cyclic boundary conditions,
      so be careful.
  @end itemize

@node OrderDerivatives, DoubleFFTParameter, DerivativesSpace, Mesh
@subsection @code{OrderDerivatives} (integer, 4)
@vindex @code{OrderDerivatives}

If @code{DerivativesSpace == real_space} use a finite difference discretisation
of this order for the derivatives, that is a @code{OrderDerivatives*2 + 1} formula.
See (MISSING ARTICLE) for details.

@node DoubleFFTParameter, FFTOptimize, OrderDerivatives, Mesh
@subsection @code{DoubleFFTParameter} (real, 2.0)
@vindex @code{DoubleFFTParameter}

For solving Poisson equation in Fourier space, and for applying the local potential
in Fourier space, an auxiliary cubic mesh is built. This mesh will be larger than
the circumscribed cube to the usual mesh by a factor @code{DoubleFFTParameter}. See
the section that refers to Poisson equation, and to the local potential for details.

@node FFTOptimize,  , DoubleFFTParameter, Mesh
@subsection @code{FFTOptimize} (logical, true)
@vindex @code{FFTOptimize}

Should @code{octopus} optimize the FFT dimension? In some cases, namely when using
the split-operator, or Suzuki-Trotter propagators, this option should be turned off.



@c **********************************************************************
@node States, Hamiltonian, Mesh, Input file options
@section States


@menu
* SpinComponents::              
* NumberKPoints::               
* ExcessCharge::                
* ExtraStates::                 
* Occupations::                 
* ElectronicTemperature::       
@end menu

@node SpinComponents, NumberKPoints, States, States
@subsection @code{SpinComponents} (integer, 1)
@vindex @code{SpinComponents}

Defines the spin mode @code{octopus} will run in. Valid modes are:
  @itemize @minus
    @item @code{unpolarized} or @code{1}: Spin-unpolarised calculation.
    @item @code{polarized} or @code{2}: Spin-polarised calculation (collinear spin). This mode
will double the number of wave-functions necessary for a spin-unpolarised 
calculation.
    @item @code{non_collinear} or @code{3}: Non-collinear spin. This mode will double the number 
of wave-functions necessary for a spin-unpolarised calculation, and each of
the wave-functions will be a 2-spinor.
  @end itemize

@node NumberKPoints, ExcessCharge, SpinComponents, States
@subsection @code{NumberKPoints} (integer, 1)
@vindex @code{NumberKPoints}

If @code{octopus} was compiled for periodic systems, the number of
@emph{k} points to use in the calculation. If @code{NumberKPoints == 1},
use only the Gamma point. (Note: current version in fact does not
implement this possibility. Setting this variable to more that 1 may
lead to erroneous results.)

@node ExcessCharge, ExtraStates, NumberKPoints, States
@subsection @code{ExcessCharge} (double, 1)
@vindex @code{ExcessCharge}

The net charge of the system. A negative value means that we are adding 
electrons, while a positive value means we are taking electrons
from the system.

@node ExtraStates, Occupations, ExcessCharge, States
@subsection @code{ExtraStates} (integer, 1)
@vindex @code{ExtraStates}

How many unoccupied states to use in the ground-state
calculation. Note that this number is unrelated to @code{CalculationMode == 4}.

@node Occupations, ElectronicTemperature, ExtraStates, States
@subsection @code{Occupations} (block data)
@vindex @code{Occupations}

The occupation numbers of the orbitals can be fixed through the use of this
variable. For example:
  @example
    %Occupations
      2.0 | 2.0 | 2.0 | 2.0 | 2.0
    %
  @end example
would fix the occupations of the five states to @code{2.0}. There must be
as many columns as states in the calculation. If @code{SpinComponents == 2}
this block should contain two lines, one for each spin channel.
This variable is very useful when dealing with highly symmetric small systems
(like an open shell atom), for it allows us to fix the occupation numbers
of degenerate states in order to help @code{octopus} to converge. This is to
be used in conjuction with @code{ExtraStates}. For example, to calculate the
carbon atom, one would do:
  @example
  ExtraStates=2
  %Occupations
      2 | 2/3 | 2/3 | 2/3
    %
  @end example

@node ElectronicTemperature,  , Occupations, States
@subsection @code{ElectronicTemperature} (double, 0.0)
@vindex @code{ElectronicTemperature}

If @code{Occupations} is not set, @code{ElectronicTemperature} is the
temperature in the Fermi-Dirac function used to distribute the electrons
among the existing states.


@c **********************************************************************
@node Hamiltonian, Exchange and correlation, States, Input file options
@section Hamiltonian


@menu
* NonInteractingElectrons::     
* ClassicPotential::            
* LocalPotentialSpace::         
* RelativisticCorrection::      
@end menu

@node NonInteractingElectrons, ClassicPotential, Hamiltonian, Hamiltonian
@subsection @code{NonInteractingElectrons} (logical, false)
@vindex @code{NonInteractingElectrons}

If @code{true}, treat the electrons as non-interacting, i.e. neglect both
Hartree and exchange-correlation contributions to the Kohn-Sham potential.
A probable choice for one-electron problems.

@node ClassicPotential, LocalPotentialSpace, NonInteractingElectrons, Hamiltonian
@subsection @code{ClassicPotential} (logical, false)
@vindex @code{ClassicPotential}

If @code{true}, add to the external potential the potential generated by 
the point charges read from the PDB input (see @code{PBDCoordinates}).

@node LocalPotentialSpace, RelativisticCorrection, ClassicPotential, Hamiltonian
@subsection @code{LocalPotentialSpace} (integer, fourier_space)
@vindex @code{LocalPotentialSpace}

If @code{fourier_space}, generate the local part of the pseudo-potential
in Fourier space; Otherwise do it directly in real space. The auxiliary box defined via
the @code{DoubleFFTParameter} is used for this purpose. 

@node RelativisticCorrection,  , LocalPotentialSpace, Hamiltonian
@subsection @code{RelativisticCorrection} (integer, 0)
@vindex @code{RelativisticCorrection}

The default value means that @emph{no} relativistic correction is used. To
include spin-orbit coupling turn @code{RelativisticCorrection} to @code{spin_orbit} or @code{1} 
(this will only work when using an executable compiled for complex wave-functions.)



@c **********************************************************************
@node Exchange and correlation, SCF, Hamiltonian, Input file options
@section Exchange and correlation

The exchange-correlation functional is controlled by the
parameters @code{XFunctional}, and @code{CFunctional}. 
The possible values are:

@menu
* XFunctional::                 
* CFunctional::                 
@end menu

@node XFunctional, CFunctional, Exchange and correlation, Exchange and correlation
@subsection @code{XFunctional} (string, 'LDA')
@vindex @code{XFunctional}

@itemize @bullet
@item @code{XFunctional == 'ZER'}: No exchange.
@item @code{XFunctional == 'LDA'}: Local density approximation.
@item @code{XFunctional == 'RLDA'}: Relativistic LDA.
@item @code{XFunctional == 'PBE'}:  J.P.Perdew, K.Burke and M.Ernzerhof, 
    	PRL @strong{77}, 3865 (1996).
@item @code{XFunctional == 'RPBE'}: PBE with some relativistic corrections.
@item @code{XFunctional == 'LB94'}: van Leeuwen and Baerends functional.
@item @code{XFunctional == 'EXX'}: Exact exchange functional in the KLI approximation.
@item @code{XFunctional == 'SIC'}: Self interaction corrected LDA in the KLI approximation.
@end itemize


@node CFunctional,  , XFunctional, Exchange and correlation
@subsection @code{CFunctional} (string, 'PZ81')
@vindex @code{CFunctional}

@itemize @bullet
@item @code{CFunctional == 'ZER'}: No correlation.
@item @code{CFunctional ==   'PZ81'}:  Perdew and Zunger, 
      PRB @strong{23}, 5075 (1981).
@item @code{CFunctional == 'PW92'}: J.P.Perdew and Y.Wang, 
      PRB @strong{45}, 13244 (1992).
@item @code{CFunctional == 'PBE'}: J.P.Perdew, K.Burke and M.Ernzerhof, 
    	PRL @strong{77}, 3865 (1996).
@item @code{CFunctional == 'SIC'}: Self interaction corrected LDA in the KLI approximation.
@end itemize

@c **********************************************************************
@node SCF, Unoccupied States, Exchange and correlation, Input file options
@section SCF

The self consistent procedure will stop when the first of the convergence
criteria is fulfilled.

@menu
* MaximumIter::                 
* ConvAbsDens::                 
* ConvRelDens::                 
* ConvAbsEv::               
* ConvRelEv::               
* LCAOStart::                   
* SCFinLCAO::                   
* EigenSolver::                 
* EigenSolverInitTolerance::    
* EigenSolverFinalTolerance::   
* EigenSolverFinalToleranceIteration::  
* EigenSolverMaxIter::          
* What2Mix::                    
* TypeOfMixing::                
* Mixing::                      
* MixNumberSteps::              
@end menu

@node MaximumIter, ConvAbsDens, SCF, SCF
@subsection @code{MaximumIter} (integer, 200)
@vindex @code{MaximumIter}

Maximum number of SCF iterations. @code{0} means unlimited.

@node ConvAbsDens, ConvRelDens, MaximumIter, SCF
@subsection @code{ConvAbsDens} (double, 1e-5)
@vindex @code{ConvAbsDens}

Absolute convergence of the density. @code{0} means do 
not use this criterion.

@node ConvRelDens, ConvAbsEv, ConvAbsDens, SCF
@subsection @code{ConvRelDens} (double, 0.0)
@vindex @code{ConvRelDens}

Relative convergence of the density. @code{0} means do 
not use this criterion.

@node ConvAbsEv, ConvRelEv, ConvRelDens, SCF
@subsection @code{ConvAbsEv} (double, 0.0)
@vindex @code{ConvAbsEv}

Absolute convergence of the eigenvalues. @code{0} means do 
not use this criterion.

@node ConvRelEv, LCAOStart, ConvAbsEv, SCF
@subsection @code{ConvRelEnergy} (double, 0.0)
@vindex @code{ConvRelEnergy}

Relative convergence of the eigenvalues. @code{0} means do 
not use this criterion.

@node LCAOStart, SCFinLCAO, ConvRelEv, SCF
@subsection @code{LCAOStart} (logical, true)
@vindex @code{LCAOStart}

Before starting a SCF calculation, performs
a LCAO calculation. These should provide @code{octopus} with a good set
of initial wave-functions, and help the convergence of the SCF cycle.
(Up to current version, only a minimal basis set used.)

@node SCFinLCAO, EigenSolver, LCAOStart, SCF
@subsection @code{SCFinLCAO} (logical, false)
@vindex @code{SCFinLCAO}

Performs all the SCF cycle restricting the calculation to the LCAO subspace.
This may be useful for systems with convergence problems (first do a 
calculation within the LCAO subspace, then restart from that point for
an unrestricted calculation).

@node EigenSolver, EigenSolverInitTolerance, SCFinLCAO, SCF
@subsection @code{EigenSolver} (integer, 0):
@vindex @code{EigenSolver}

At each SCF cycle step, a diagonalisation of the Hamiltonian is performed.
This variable chooses the eigensolver used to diagonalise the Kohn-Sham Hamiltonian.
Possible values are:
  @itemize @minus
    @item @code{cg} or @code{0}: Conjugated Gradients method.
    @item @code{lanczos} or @code{2}: Block-Lanczos method.
  @end itemize
Look up the source to know what the differences are.

In both cases, for the first iterations of the cycle there is no need to
perform a very precise diagonalisation. Because of this, we may define
a varying tolerance, so that at the first iteration a given small 
tolerance is achieved, and then this tolerance is linearly increased
until a given iteration, after which a maximum tolerance is always asked.
Next variables take care of this process. 

@node EigenSolverInitTolerance, EigenSolverFinalTolerance, EigenSolver, SCF
@subsection @code{EigenSolverInitTolerance} (double, 1.0e-3)
@vindex @code{EigenSolverInitTolerance}

This is the initial tolerance for the eigenvectors. 

@node EigenSolverFinalTolerance, EigenSolverFinalToleranceIteration, EigenSolverInitTolerance, SCF
@subsection @code{EigenSolverFinalTolerance} (double, 1.0e-5)
@vindex @code{EigenSolverFinalTolerance}

This is the final tolerance for the eigenvectors.

@node EigenSolverFinalToleranceIteration, EigenSolverMaxIter, EigenSolverFinalTolerance, SCF
@subsection @code{EigenSolverFinalToleranceIteration} (integer, 7)
@vindex @code{EigenSolverFinalToleranceIteration}

Determines how many interactions are needed 
to go from @code{EigenSolverInitTolerance} to @code{EigenSolverFinalTolerance}.

@node EigenSolverMaxIter, What2Mix, EigenSolverFinalToleranceIteration, SCF
@subsection @code{EigenSolverMaxIter} (integer, 25)
@vindex @code{EigenSolverMaxIter}

It determines the maximum number of iterations 
for the eigensolver (per state) --- that is, if this number is reached, the diagonalisation
is stopped even if the desired tolerance was not achieved.

@node What2Mix, TypeOfMixing, EigenSolverMaxIter, SCF
@subsection @code{What2Mix} (integer, 0)
@vindex @code{What2Mix}

Selects what should be mixed during the SCF cycle. Possible
values are:
  @itemize @minus
    @item @code{density} or @code{0}: Density
    @item @code{potential} or @code{1}: Potential
  @end itemize

@node TypeOfMixing, Mixing, What2Mix, SCF
@subsection @code{TypeOfMixing} (integer, 2)
@vindex @code{TypeOfMixing}

Selects the mixing procedure to be used during the SCF cycle. Possible
values are:
  @itemize @minus
    @item @code{linear} or @code{0}: Linear mixing.
    @item @code{gr_pulay} or @code{1}: Guaranteed-reduction Pulay (GR-Pulay).
    @item @code{broyden} or @code{2}: Broyden mixing.
  @end itemize

@node Mixing, MixNumberSteps, TypeOfMixing, SCF
@subsection @code{Mixing} (double, 0.3)
@vindex @code{Mixing}

Determines the amount of the new density/potential which is to be mixed
with the old one. Used only by linear mixing and Broyden mixing.

@node MixNumberSteps,  , Mixing, SCF
@subsection @code{MixNumberSteps} (integer, 3)
@vindex @code{MixNumberSteps}

Number of steps used by Broyden mixing or GR-Pulay mixing to extrapolate the new 
density/potential.



@c **********************************************************************
@node Unoccupied States, Time Dependent, SCF, Input file options
@section Unoccupied States

These variables are only used in @code{CalculationMode == 3, 4} (or in 5 and 6
if @code{TDOccupationalAnalysis == 1}).


@menu
* UnoccNumberStates::           
* UnoccMaximumIter::            
* UnoccConv::                   
@end menu

@node UnoccNumberStates, UnoccMaximumIter, Unoccupied States, Unoccupied States
@subsection @code{UnoccNumberStates} (integer, 5)
@vindex @code{UnoccNumberStates}

How many unoccupied states to compute.

@node UnoccMaximumIter, UnoccConv, UnoccNumberStates, Unoccupied States
@subsection @code{UnoccMaximumIter} (integer, 200)
@vindex @code{UnoccMaximumIter}

Maximum number of iterations while calculating the unoccupied states.
Note that these are @emph{not} SCF iterations, for the density and the 
Hamiltonian are not updated!

@node UnoccConv,  , UnoccMaximumIter, Unoccupied States
@subsection @code{UnoccConv} (double, 1e-4)
@vindex @code{UnoccConv}

Absolute convergence in the eigenvectors. So don't try to put it too
good or else you won't converge.


@c **********************************************************************
@node Time Dependent, Geometry optimization, Unoccupied States, Input file options
@section Time Dependent


When @code{CalculationMode = 5,6}, @code{octopus} performs the time propagation
of the electronic orbitals and -- if required -- of the ionic positions. This latter
task does not pose major algorithmical problems (the usual Verlet algorithms deal
with that task); however the best way to propagate a Schr@"odinger-like equation
is still unclear. Due to this fact, we provide with a rather excessive selection
of possibilities for that purpose. Before describing the set of variables necessary
to specify the way in which the time evolution is to be performed, it is worth making
a brief introduction to the problem.

We are concerned with a set of Schr@"odinger-like equations for the electronic orbitals:
@tex
$$
  i{\partial \psi_i \over \partial t} = H(t)\psi_i(t)\,,
$$
$$
  \psi_i(t=0) = \psi_i^0\,.
$$
@end tex
@ifnottex

  i@{\partial psi_i \over \partial t@} = H(t)\psi_i(t)\,,

  \psi_i(t=0) = \psi_i^0\,.

@end ifnottex
Being the equation linear, one may formally define a linear ``evolution'' operator, which
trasforms the initial vector into the solution at time @math{T}:
@tex
$$
\psi_i(T) = U(T, 0)\psi_i^0
$$
@end tex
@ifnottex

\psi_i(T) = U(T, 0)\psi_i^0

@end ifnottex
Moreover, there is a formal exact expression for the evolution operator:
@tex
$$
\psi_i(T) = T\exp\lbrace -i\!\!\int_0^{T}d\tau H(\tau)\rbrace \psi_i^0\,.
$$
@end tex
@ifnottex

\psi_i(T) = T\exp\lbrace -i\!\!\int_0^@{T@}d\tau H(\tau)\rbrace \psi_i^0\,.

@end ifnottex
where @math{T\exp} is the time-ordered exponential. If the Hamiltonian conmutes with itself at
different times, we can drop the time-ordering product, and leave a simple exponential.
If the Hamiltonian is time-independent -- which makes it trivially self commuting, 
the solution is then simply written as:
@tex
$$
\psi_i(T) = \exp\lbrace -iTH\rbrace \psi_i^0\,.
$$
@end tex
@ifnottex

\psi_i(T) = \exp\lbrace -iTH\rbrace \psi_i^0\,.

@end ifnottex
Unfortunately, this is not the case in general. We have to find an algorithm
able to cope with time-dependent Hamiltonians, such as the self-consistent
time-dependent Kohn-Sham operator, which is built ``self consistently'' from
the varying electronic density.

The first step is to perform a time-discretization: the full propagation between
@math{0} and @math{T} is decomposed as:
@tex
$$
U(T,0) = \prod_{i=0}^{N-1}U(t_i+\delta t,t_i)\,,
$$
@end tex
@ifnottex

U(T,0) = \prod_@{i=0@}^@{N-1@}U(t_i+\delta t,t_i)\,,

@end ifnottex
where @math{t_0=0}, @math{t_N=T}, @math{\delta t = T/N}. So at each time
step we are dealing with the problem of performing the short-time propagation:
@tex
$$
\psi_i(t+\delta t) = U(t+\delta t, t)\psi_i(t) = 
T\exp\lbrace -i\!\!\int_{t}^{t+\delta t}\!\!\!\!\!\!\!\!\!d\tau\,H(\tau)\rbrace \psi(t)\,.
$$
@end tex
@ifnottex

\psi_i(t+\delta t) = U(t+\delta t, t)\psi_i(t) = 
T\exp\lbrace -i\!\!\int_@{t@}^@{t+\delta t@}\!\!\!\!\!\!\!\!\!d\tau\,H(\tau)\rbrace \psi(t)\,.

@end ifnottex
In this way, one can monitor the evolution in the interior of @math{[0,t]}. 
In fact, the possibility of monitoring the evolution is generally
a requirement; this requirement
imposes a natural restriction on the maximum size of @math{\delta t}: if 
@math{\omega_{\rm max}} is the
maximum frequency that we want to discern, @math{\delta t} should be no larger than 
@math{\approx 1/\omega_{\rm max}}.
Below this @math{\delta t_{\rm max}}, we are free to choose @math{\delta t} considering performance reasons:
Technically, the reason for the discretization is twofold: the time-dependence of 
@math{H} is alleviated,
and the norm of the exponential argument is reduced 
(the norm increases linearly with @math{\delta t}).

Since we cannot drop the time-ordering product, the
desired algorithm
cannot be reduced, in principle, to the calculation of the action of the exponential of an operator
over the initial vector.
Some algorithms tailored to approximate the evolution operator, 
in fact, do not even require to peform such operator exponentials. 
Most of them, however, do rely on the calculation of one or more exponentials, such as the ones
used by @code{octopus}. This is why in principle we need to specify two different 
issues: the ``evolution
method'', and the ``exponential method''. In other words: we need an algorithm
to approximate the evolution operator @math{U(t+\delta t, t)} -- which will be
specified by variable @code{TDEvolutionMethod} (@pxref{TDEvolutionMethod}) -- 
and, if this algorithm requires it,
we will also need an algorithm to approximate the exponential of a matrix
operator @math{\exp\lbrace A\rbrace} -- which will be specified by variable
@code{TDExponentialMethod} (@pxref{TDExponentialMethod}).


@menu
* TDMaximumIter::               
* TDTimeStep::                  
* TDExponentialMethod::         
* TDExpOrder::                  
* TDLanczosTol::                
* TDEvolutionMethod::           
* TDLasers::                    
* TDGauge::                     
* TDDeltaStrength::             
* TDPolarization::              
* TDDipoleMax::                 
* TDOutputMultipoles::          
* TDOutputCoordinates::         
* TDOutputGSProjection::        
* TDOutputAcceleration::        
* TDOutputLaser::               
* TDOutputElEnergy::            
* TDOutputOccAnalysis::         
* MoveIons::                    
* AbsorbingBoundaries::         
* ABWidth::                     
* ABHeight::                    
@end menu

@node TDMaximumIter, TDTimeStep, Time Dependent, Time Dependent
@subsection @code{TDMaximumIter} (integer, 1500)
@vindex @code{TDMaximumIter}

Number of time steps in which the total integration time is divided;
in previous notation, @math{N}.

@node TDTimeStep, TDExponentialMethod, TDMaximumIter, Time Dependent
@subsection @code{TDTimeStep} (double, 0.07 a.u.)
@vindex @code{TDTimeStep}

Time-step for the propagation;
in previous notation, @math{\delta t}.

@node TDExponentialMethod, TDExpOrder, TDTimeStep, Time Dependent
@subsection @code{TDExponentialMethod} (integer, 3)
@vindex @code{TDExponentialMethod}

Method used to numerically calculate the exponential of the Hamiltonian,
a core part of the full algorithm used to approximate the evolution
operator, specified through the variable @code{TDEvolutionMethod} (@pxref{TDEvolutionMethod}).
In the case of using the Magnus method, described below, the action of the exponential
of the Magnus operator is also calculated through the algorithm specified
by this variable.

@itemize @minus

@item @code{split} or @code{0}: Split-operator (SO).

It is important to distinguish between applying the split operator method
to calculate the exponential of the Hamiltonian at a given time -- which
is what this variable is referring to -- from the split operator method
as an algorithm to approximate the full evolution operator @math{U(t+\delta t, t)},
and which will be described below as one of the possibilities
of the variable @code{TDEvolutionMethod}.
The equation that describes the split operator scheme is well known:
@tex
$$
\exp_{\rm SO} (-i \delta t H) = \exp (-i \delta t/2 V) \exp (-i \delta t T) \exp (-i \delta t/2 V)\,.
$$
@end tex
@ifnottex

\exp_@{\rm SO@} (-i \delta t H) = \exp (-i \delta t/2 V) \exp (-i \delta t T) \exp (-i \delta t/2 V)\,.

@end ifnottex

Note that this is a ``kinetic referenced SO'', since the kinetic term is sandwiched in the
middle. This is so because in @code{octopus}, the states spend most of its time in real-space; doing
it ``potential referenced'' would imply 4 FFTs instead of 2.
This split-operator technique may be used in combination with, for example,
the exponential midpoint rule as a means to approximate the evolution operator.
In that case, the potential operator @code{V} that appears in the equation would be
calculated at time @math{t+\delta t/2}, that is, in the middle of the time-step.
However, note that if the split-operator method is invoked as a means to approximate
the evolution operator (@code{TDEvolutionMethod = 0}), a different procedure is taken -- it
will be described below --, and in fact the variable @code{TDExponentialMethod} has no
effect at all.

@item @code{suzuki-trotter} or @code{1}: Suzuki-Trotter (ST). 

This is a higher-order SO based algorithm. See O. Sugino and Y. Miyamoto,
Phys. Rev. B @strong{59}, 2579 (1999). Allows for larger time-steps,
but requires five times more time than the normal SO.

The considerations made above for the SO algorithm about the distinction
between using the method as a means to approximate @code{U(t+\delta t)} or as a
means to approximate the exponential also apply here. Setting @code{TDEvolutionMethod = 1}
enforces the use of the ST as an algorithm to approximate the full evolution operator,
which is slightly different (see below).

@item @code{lanczos} or @code{2}: Lanczos approximation (LAN).

Allows for larger time-steps.
However, the larger the time-step, the longer the computational time per time-step. 
In certain cases, if the time-step is too large, the code will emit a warning
whenever it considers that the evolution may not be properly proceeding --
the Lanczos process did not converge. The method consists in a Krylov
subspace approximation of the action of the exponential
(see M. Hochbruck and C. Lubich, SIAM J. Numer. Anal. @strong{34}, 1911 (1997) for details). 
Two more variables control the performance of the method: the maximum dimension
of this subspace (controlled by variable @code{TDExpOrder}), and
the stopping criterium (controlled by variable @code{TDLanczosTol}).
The smaller the stopping criterium, the more precisely the exponential
is calculated, but also the larger the dimension of the Arnoldi
subspace. If the maximum dimension allowed by @code{TDExpOrder} is not
enough to meet the criterium, the above-mentioned warning is emitted.

@item @code{standard} or @code{3}: N-th order standard expansion of the exponential (STD). 

This method amounts to a straightforward application of the definition of
the exponential of an operator, in terms of it Taylor expansion.
@tex
$$
\exp_{\rm STD} (-i\delta t H) = \sum_{i=0}^{k} {(-i\delta t)^i\over{i!}} H^i.
$$
@end tex
@ifnottex

\exp_@{\rm STD@} (-i\delta t H) = \sum_@{i=0@}^@{k@} @{(-i\delta t)^i\over@{i!@}@} H^i.

@end ifnottex

The order @math{k} is determined by variable @code{TDExpOder} (@pxref{TDExpOrder}).
Some numerical considerations (by Jeff Giansiracusa and George F. Bertsch;
see @uref{http://www.phys.washington.edu/~bertsch/num3.ps})
suggest the 4th order as especially suitable and stable.

@item @code{chebyshev} or @code{4}: N-th order Chebyshev expansion (CHEB). 

In principle, the Chebyshev expansion
of the exponential represents it more accurately than the canonical or standard expansion. 
As in the latter case, @code{TDExpOrder} determines the order of the expansion.

There exists a closed analytical form for the coefficients of the exponential in terms
of Chebyshev polynomials:
@tex
$$
\exp_{\rm CHEB} \left( -i\delta t H \right) = \sum_{k=0}^{\infty} (2-\delta_{k0})(-i)^{k}
J_k(\delta t) T_k(H),
$$
@end tex
@ifnottex

\exp_@{\rm CHEB@} \left( -i\delta t H \right) = \sum_@{k=0@}^@{\infty@} (2-\delta_@{k0@})(-i)^@{k@}
J_k(\delta t) T_k(H),

@end ifnottex

where @math{J_k} are the Bessel functions of the first kind, and H has te be previously
scaled to @math{[-1,1]}.
See H. Tal-Ezer and R. Kosloff, J. Chem. Phys. @strong{81},
3967 (1984); R. Kosloff, Annu. Rev. Phys. Chem. @strong{45}, 145 (1994);
C. W. Clenshaw, MTAC @strong{9}, 118 (1955).

@end itemize

@node TDExpOrder, TDLanczosTol, TDExponentialMethod, Time Dependent
@subsection @code{TDExpOrder} (integer, 4)
@vindex @code{TDExpOrder}

For @code{TDExponentialMethod} equal @code{standard} or @code{chebyshev}, the order to which
the exponential is expanded. For the Lanczos approximation, it is the maximum
Lanczos-subspace dimension.

@node TDLanczosTol, TDEvolutionMethod, TDExpOrder, Time Dependent
@subsection @code{TDLanczosTol} (real, 5e-4)
@vindex @code{TDLanczosTol}

An internal tolerance variable for the Lanczos method. The smaller, the more
precisely the exponential is calculated, and also the bigger the dimension
of the Krylov subspace needed to perform the algorithm. One should carefully
make sure that this value is not too big, or else the evolution will be
wrong.

@node TDEvolutionMethod, TDLasers, TDLanczosTol, Time Dependent
@subsection @code{TDEvolutionMethod} (integer, 2)
@vindex @code{TDEvolutionMethod}

This variable determines which algorithm will be used to approximate
the evolution operator @math{U(t+\delta t, t)}. That is, known
@math{\psi(\tau)} and @math{H(\tau)} for @math{tau \le t},
calculate @math{t+\delta t}. Note that in general the Hamiltonian
is not known at times in the interior of the interval @math{[t,t+\delta t]}.
This is due to the self-consistent nature of the time-dependent Kohn-Sham problem:
the Hamiltonian at a given time @math{\tau} is built from the
``solution'' wavefunctions at that time.

Some methods, however, do require the knowledge of the Hamiltonian at some
point of the interval @math{[t,t+\delta t]}. This problem is solved by making
use of extrapolation: given a number @math{l} of time steps previous to time
@math{t}, this information is used to build the Hamiltonian at arbitrary times
within @math{[t,t+\delta t]}. To be fully precise, one should then proceed
@emph{self-consistently}: the obtained Hamiltonian at time @math{t+\delta t}
may then be used to interpolate the Hamiltonian, and repeat the evolution
algorithm with this new information. Whenever iterating the procedure does
not change the solution wave-functions, the cycle is stopped. In practice,
in @code{octopus} we perform a second-order extrapolation without
self-consistente check, except for the first two iterations, where obviously
the extrapolation is not reliable.

@itemize @bullet

@item @code{split} or @code{0}: Split Operator (SO). 

This is one of the most traditional methods. It splits the full Hamiltonian
into a kinetic and a potential part, performing the first in Fourier-space,
and the latter in real space. The necessary transformations are performed
with the FFT algorithm.
@tex
$$
U_{\rm SO}(t+\delta t, t) = \exp \lbrace - {i \over 2}\delta t T \rbrace
             \exp \lbrace -i\delta t V^* \rbrace
             \exp \lbrace - {i \over 2}\delta t T \rbrace
$$
@end tex
@ifnottex

U_@{\rm SO@}(t+\delta t, t) = \exp \lbrace - @{i \over 2@}\delta t T \rbrace
             \exp \lbrace -i\delta t V^* \rbrace
             \exp \lbrace - @{i \over 2@}\delta t T \rbrace

@end ifnottex
Since those three exponentials may be calculated exactly, one does not
need to use any of the methods specified by variable @code{TDExponentialMethod}
to perform them. 

The key point is the specification of @math{V^*}. Let @math{V(t)} be divided into
@math{V_{\rm int}(t)}, the ``internal'' potential which depends self-consistently
on the density, and @math{V_{\rm ext}(t)}, the external potential that we know
at all times since it is imposed to the system by us (e.g. a laser field):
@math{V(t)=V_{\rm int}(t)+V_{\rm ext}(t)}. Then we define to be @math{V^*} to
be the sum of @math{V_{\rm ext}(t+\delta t/2)} and the internal potential built
from the wavefunctions @emph{after} applying the right-most kinetic term
of the equation, @math{\exp \lbrace -i\delta t/2 T \rbrace}.

It may the be demonstrated that the order of the error of the algorithm is the
same that the one that we would have by making use of the Exponential Midpoint Rule
(EM, described below), the SO algorithm to calculate the action of the 
exponential of the Hamiltonian, and a full self-consistent procedure.


@item @code{suzuki-trotter} or @code{1}: Suzuki-Trotter (ST).

This is the generalization of the Suzuki-Trotter algorithm, described
as one of the choices of the @code{TDExponentialMethod} (@pxref{TDExponentialMethod}),
to time-dependent problem. Consult the paper by O. Sugino and M. Miyamoto,
Phys. Rev. B @strong{59}, 2579 (1999), for details.

It requires of Hamiltonian extrapolations.

@item @code{etrs} or @code{2}: Enforced Time-Reversal Symmetry (ETRS).

The idea is to make use of the time-reversal symmetry from the beginning:

@tex
$$
\exp \left(-i\delta t/2 H_{n}\right)\psi_n = exp \left(i\delta t/2 H_{n+1}\right)
\psi_{n+1},
$$
@end tex
@ifnottex

\exp \left(-i\delta t/2 H_@{n@}\right)\psi_n = exp \left(i\delta t/2 H_@{n+1@}\right)
\psi_@{n+1@},

@end ifnottex
and then invert to obtain:
@tex
$$
\psi_{n+1} = \exp \left(-i\delta t/2 H_{n+1}\right) exp \left(-i\delta t/2 H_{n}\right)
\psi_{n}.
$$
@end tex
@ifnottex

\psi_@{n+1@} = \exp \left(-i\delta t/2 H_@{n+1@}\right) exp \left(-i\delta t/2 H_@{n@}\right)
\psi_@{n@}.

@end ifnottex
But we need to know @math{H_{n+1}}, which can only be known exactly through the solution
@math{\psi_{n+1}}. What we do is to estimate it by performing a single exponential:
@math{\psi^{*}_{n+1}=\exp \left( -i\delta t H_{n} \right) \psi_n}, and then
@math{H_{n+1} = H[\psi^{*}_{n+1}]}. Thus no extrapolation is performed in this case.


@item @code{aetrs} or @code{3}: Approximated Enforced Time-Reversal Symmetry (AETRS).

A modification of previous method to make it faster.
It is based on extrapolation of the time-dependent potentials. It is faster
by about 40%.

The only difference is the procedure to estimate @math{H_{n+1}}: in this case
it is extrapolated trough a second-order polynomial by making use of the
Hamiltonian at time @math{t-2\delta t}, @math{t-\delta t} and @math{t}.

@item @code{exp_mid} or @code{4}: Exponential Midpoint Rule (EM).

This is maybe the simplest method, but is is very well grounded theretically:
it is unitary (if the exponential is performed correctly) and preserves
time symmetry (if the self-consistency problem is dealt with correctly).
It is defined as:
@tex
$$
U_{\rm EM}(t+\delta t, t) = \exp \left( -i\delta t H_{t+\delta t/2}\right)\,.
$$
@end tex
@ifnottex

U_@{\rm EM@}(t+\delta t, t) = \exp \left( -i\delta t H_@{t+\delta t/2@}\right)\,.

@end ifnottex


@item @code{magnus} or @code{5}: Magnus Expansion (M4).
This is the most sophisticated approach. It is a fourth order scheme (feature
that shares with the ST scheme; the other schemes are in principle second order).
It is tailored for making use of very large time steps, or equivalently,
dealing with problem with very high-frequency time dependence.
It is still in a experimental state; we are not yet sure of when it is
advantageous.

@end itemize


This proliferation of methods is certainly excessive; The reason for it is that 
the propagation algorithm is currently a topic of active development. We
hope that in the future the optimal schemes are clearly identified. In the
mean time, if you don't feel like testing, use the default choices and
make sure the time step is small enough.




@node TDLasers, TDGauge, TDEvolutionMethod, Time Dependent
@subsection @code{TDLasers} (block data)
@vindex @code{TDLasers}

Each line of the block describes a laser pulse applied to the system. 
The syntax is:
  @example
    %TDLasers
      polx | poly | polz | A0 | omega0 | envelope | tau0 | t0
    %
  @end example
where @code{pol} is the (complex) polarisation of the laser field, @code{A0}
the amplitude, @code{envelope} the envelope function, @code{t0} the 
middle (maximum) of the pulse and @code{omega0} the frequency of 
the pulse. The meaning of @code{tau0} depends on the envelope function. 
The possible values for @code{envelope} are:

@itemize @minus
@item @code{1}: Gaussian envelope. @code{tau0} is the standard deviation 
of the pulse. 
@tex
$$
E(t) = {\tt A0}\exp \left(  -{(t-{\tt t0})^2 \over 2*{\tt tau0}^2} \right).
$$
@center @image{gaussian,4cm,}
@end tex
@item @code{2}: Cosinoidal envelope. @code{tau0} is half the total length
of the pulse.
@tex
$$
E(t) = {\tt A0}\cos \left( {\pi \over 2} {(t - 2{\tt tau0} - {\tt t0)} \over {\tt tau0}} \right),\;\;\;
|t-{\tt t0}| < {\tt tau0}.
$$
@center @image{cosine,4cm,}
@end tex
@item @code{3}: Ramp. In this case there is an extra parameter 
@code{tau1}. @code{tau0} is the length of the constant part of the ramp,
and @code{tau1} is the raising (decaying) time. @code{tau1} should be
an extra field after @code{t0}.
@tex
@center @image{ramp,4cm,}
@end tex

@item @code{10}: Shape is read from a file.
@end itemize

If @code{envelope=10}, the @code{t0} parameter is substituted by a string that
determines the name of the file. The format of this file should be three
columns of real numbers:
time, field and phase. Atomic units are assumed. The values for the laser field
that the program will use are interpolated / extrapolated from this numerically
defined function.

@node TDGauge, TDDeltaStrength, TDLasers, Time Dependent
@subsection @code{TDGauge} (integer, 0)
@vindex @code{TDGauge}

In which gauge to treat the laser. Options are:
@itemize @minus
    @item @code{length} or @code{1}: Length gauge.
    @item @code{velocity} or @code{2}: Velocity gauge.
@end itemize

@node TDDeltaStrength, TDPolarization, TDGauge, Time Dependent
@subsection @code{TDDeltaStrength} (double, 0.0 a.u.)
@vindex @code{TDDeltaStrength}

When no laser is applied, a delta (in time) electric field with
strength @code{TDDeltaStrength} is applied. This is used to calculate
the linear optical spectra.

@node TDPolarization, TDDipoleMax, TDDeltaStrength, Time Dependent
@subsection @code{TDPolarization} (block data)
@vindex @code{TDPolarization}

The (real) polarisation of the delta electric field. The format of the
block is:
  @example
    %TDPolarization
      polx | poly | polz
    %
  @end example
In order to calculate dichroism the polarisation has to be generalized to
complex. Also some input/output and the @code{strength-function} utility have
to be changed. It is a nice little project if someone is interested in
getting into @code{octopus}.

@node TDDipoleMax, TDOutputMultipoles, TDPolarization, Time Dependent
@subsection @code{TDDipoleLmax} (integer , 1)
@vindex @code{TDDipoleLmax}

Maximum multi-pole of the density output to the file @code{td.general/multipoles} 
during a time-dependent simulation.

@node TDOutputMultipoles, TDOutputCoordinates, TDDipoleMax, Time Dependent
@subsection @code{TDOutputMultipoles} (logical, true)
@vindex @code{TDOutputMultipoles}

If true, outputs the multipole moments of the density to the file @code{td.general/multipoles}.
This is required to, e.g., calculate optical absorption spectra of finite systems.

@node TDOutputCoordinates, TDOutputGSProjection, TDOutputMultipoles, Time Dependent
@subsection @code{TDOutputCoordinates} (logical, @code{MoveIons} > 0 )
@vindex @code{TDOutputCoordinates}

If true (and if the atoms are allowed to move), outputs the coordinates, velocities,
and forces of the atoms to the the file @code{td.general/coordinates}.

@node TDOutputGSProjection, TDOutputAcceleration, TDOutputCoordinates, Time Dependent
@subsection @code{TDOutputGSProjection} (logical, false)
@vindex @code{TDOutputGSProjection}

If true, outputs the projection of the time-dependent Kohn-Sham Slater determinant
onto the ground-state to the file @code{td.general/gs_projection}. As the calculation
of the projection is fairly heavy, this is only done every @code{OutputEvery} 
iterations.

@node TDOutputAcceleration, TDOutputLaser, TDOutputGSProjection, Time Dependent
@subsection @code{TDOutputAcceleration} (logical, false)
@vindex @code{TDOutputAcceleration}

When @emph{true} outputs the acceleration, calculated from Ehrenfest theorem,
in the file @code{td.general/acceleration}. This file can then be
processed by the utility "hs-from-acc" in order to obtain the harmonic spectrum.

@node TDOutputLaser, TDOutputElEnergy, TDOutputAcceleration, Time Dependent
@subsection @code{TDOutputLaser} (logical, true)
@vindex @code{TDOutputLaser}

If @code{true}, @code{octopus} outputs the laser field to the file ``@code{td.general/laser}''.

@node TDOutputElEnergy, TDOutputOccAnalysis, TDOutputLaser, Time Dependent
@subsection @code{TDOutputElEnergy} (logical, false)
@vindex @code{TDOutputElEnergy}

If @code{true}, @code{octopus} outputs the different components of the electronic energy
to the file @code{td.general/el_energy}.

@node TDOutputOccAnalysis, MoveIons, TDOutputElEnergy, Time Dependent
@subsection @code{TDOutputOccAnalysis} (logical, false)
@vindex @code{TDOutputOccAnalysis}

If true, outputs the projections of the time-dependent Kohn-Sham
wave-functions onto the static (zero time) wave-functions to the
file @code{td.general/projections.XXX}.

@node MoveIons, AbsorbingBoundaries, TDOutputOccAnalysis, Time Dependent
@subsection @code{MoveIons} (integer, 0)
@vindex @code{MoveIons}

What kind of simulation to perform. Possible values are:
@itemize @minus
@item @code{no} or @code{0}: Do not move the ions.
@item @code{verlet} or @code{3}: Newtonian dynamics using Verlet.
@item @code{vel_verlet} or @code{4}: Newtonian dynamics using velocity Verlet.
@end itemize

@node AbsorbingBoundaries, ABWidth, MoveIons, Time Dependent
@subsection @code{AbsorbingBoundaries} (integer, 0)
@vindex @code{AbsorbingBoundaries}

To improve the quality of the spectra by avoiding the formation of 
standing density waves, one can make the boundaries of the simulation 
box absorbing. The possible values for this parameter are:
  @itemize @minus
    @item @code{no} or @code{0}: No absorbing boundaries.
    @item @code{sin2} or @code{1}: A sin@math{^2} imaginary potential is added at the boundaries.
    @item @code{mask} or @code{2}: A mask is applied to the wave-functions at the boundaries.
  @end itemize

@node ABWidth, ABHeight, AbsorbingBoundaries, Time Dependent
@subsection @code{ABWidth} (real, 0.4 a.u.):
@vindex @code{ABWidth}

Width of the region used to apply the absorbing boundaries.

@node ABHeight,  , ABWidth, Time Dependent
@subsection @code{ABHeight} (real, -0.2 a.u.)
@vindex @code{ABHeight}

When @code{AbsorbingBoundaries == 1}, is the height of the imaginary 
potential.




@c **********************************************************************
@c If somebody wants to put this back in, just do it. But since I think it
@c if more fair not to document this stuff yet.
@c @node Photo-electron spectrum, Geometry optimization, Time Dependent, Input file options
@c @section Photo-electron spectrum
@c @itemize @bullet

@c @item @vindex @code{CalcPES_rc}
@c @code{CalcPES_rc} (logical, false):
@c  If @code{true}, store the wave functions in specific points in order to 
@c calculate the photo-electron spectrum in a point far in the box as proposed in 
@c A. Pohl, P.-G. Reinhard, and E. Suraud Phys. Rev. Lett. @strong{84}, 5090 (2000).


@c @item @vindex @code{PES_rc_points}
@c @code{PES_rc_points} (block data):
@c  List of points where to calculate the photo-electron spectrum a la Suraud.
@c  The exact syntax is:
@c  @example
@c    %TDPES_rc_points
@c      x1 | y1 | z1
@c    %
@c  @end example

@c @item @vindex @code{CalcPES_mask}
@c @code{CalcPES_mask} (logical, false)
@c  If @code{true}, calculate the photo-electron spectrum using the mask method
@c  (M. Marques, D. Varsano, H. Appel, E.K.U. Gross and A. Rubio to be submitted). 
@c  In order for this to work, masking boundaries are necessary 
@c  (@code{AbsorbingBoundaries == 2}).

@c end itemize


@c **********************************************************************
@node Geometry optimization, Function output for visualization, Time Dependent, Input file options
@section Geometry optimization


@menu
* GOMethod::                    
* GOTolerance::                 
* GOMaxIter::                   
* GOStep::                      
@end menu

@node GOMethod, GOTolerance, Geometry optimization, Geometry optimization
@subsection @code{GOMethod} (integer, 1)
@vindex @code{GOMethod}

  Method by which the minimization is performed. The only possible value is
  @code{steep} (simple steepest descent).

@node GOTolerance, GOMaxIter, GOMethod, Geometry optimization
@subsection @code{GOTolerance} (real, 0.0001)
@vindex @code{GOTolerance}

  Convergence criterium to stop the minimization. In units of force; minimization
  is stopped when all forces on ions are smaller.

@node GOMaxIter, GOStep, GOTolerance, Geometry optimization
@subsection @code{GOMaxIter} (integer, 200)
@vindex @code{GOMaxIter}

  Even if previous convergence criterium is not satisfied, minimization will stop
  after this number of iterations.

@node GOStep,  , GOMaxIter, Geometry optimization
@subsection @code{GOStep} (double, 0.5)
@vindex @code{GOStep}

Initial step for the geometry optimizer.




@c **********************************************************************
@node Function output for visualization, Spectrum calculations, Geometry optimization, Input file options
@section Function output for visualization

Every given number of time iterations, or after ground-state calculations, some
of the functions that characterise the system may be written to disk
so that they may be analized. Files are written within ``static'' output directory
after the self-consistent field, or within ``td.x'' directories, during evolution,
where ``x'' stands for the iteration number at which each write is done.
Note that if you wish to plot any function (@code{OutputKSPotential = yes}, etc.),
at least one of the output formats should be enabled (@code{OutputPlaneX = yes},
@code{OutputDX = yes}, @code{OutputNETCDF = yes}, etc.). [This is not necessary
if you wish to plot the geometry (@code{OutputGeometry = yes})]. Note further
that the data written by @code{OutputAxisX}, @code{OutputPlaneX} etc. has
always the (side) length of the longest axis; this is independent from the
 chosen geometry. Data points which are inexistent in the actual geometry
have the value zero in those files.


@menu
* OutputKSPotential::           
* OutputDensity::               
* OutputWfs::                   
* OutputWfsNumber::             
* OutputElf::                   
* OutputGeometry::              
* OutputAxisX::                 
* OutputAxisY::                 
* OutputAxisZ::                 
* OutputPlaneX::                
* OutputPlaneY::                
* OutputPlaneZ::                
* OutputDX::                    
* OutputNETCDF::                
* OutputEvery::                 
@end menu

@node OutputKSPotential, OutputDensity, Function output for visualization, Function output for visualization
@subsection @code{OutputKSPotential} (logical, false)
@vindex @code{OutputKSPotential}

Prints out Kohn-Sham potential, separated by parts. File names would be ``v0'' for 
the local part, ``vc'' for the classical potential (if it exists), ``vh'' for the
Hartree potential, and ``vxc-x'' for each of the exchange and correlation potentials
of a give spin channel, where ``x'' stands for the spin channel.

@node OutputDensity, OutputWfs, OutputKSPotential, Function output for visualization
@subsection @code{OutputDensity} (logical, false)
@vindex @code{OutputDensity}

Prints out the density. The output file is called ``density-i'', where ``i'' stands for 
the spin channel.

@node OutputWfs, OutputWfsNumber, OutputDensity, Function output for visualization
@subsection @code{OutputWfs} (logical, false)
@vindex @code{OutputWfs}

Prints out wave-functions. Which wavefunctions are to be printed is specified
by the variable @code{OutputWfsNumber} -- see below. The output file is called
``wf-k-p-i'', where k stands for the @emph{k} number, p for the state, and
i for the spin channel.

@node OutputWfsNumber, OutputElf, OutputWfs, Function output for visualization
@subsection @code{OutputWfsNumber} (string, "1-1024")
@vindex @code{OutputWfsNumber}

Which wavefunctions to print, in list form, i.e., "1-5" to print the first
five states, "2,3" to print the second and the third state, etc.

@node OutputElf, OutputGeometry, OutputWfsNumber, Function output for visualization
@subsection @code{OutputELF} (logical, false)
@vindex @code{OutputELF}

  Prints out the electron localization function, ELF. The output file is called
  ``elf-i'', where i stands for the spin channel.

@node OutputGeometry, OutputAxisX, OutputElf, Function output for visualization
@subsection @code{OutputGeometry} (logical, false)
@vindex @code{OutputGeometry}

If true @code{octopus} outputs a XYZ file called 
``geometry.xyz'' containing the coordinates of the atoms
treated within Quantum Mechanics. If point charges were defined
in the PDB file (see @code{PDBCoordinates}), they will be output
in the file ``geometry_classical.xyz''.

@node OutputAxisX, OutputAxisY, OutputGeometry, Function output for visualization
@subsection @code{OutputAxisX} (logical, false)
@vindex @code{OutputAxisX}

The values of the function on the @math{x} axis are printed. The string ``.y=0,z=0'' is appended
to previous file names.

@node OutputAxisY, OutputAxisZ, OutputAxisX, Function output for visualization
@subsection @code{OutputAxisY} (logical, false)
@vindex @code{OutputAxisY}

The values of the function on the @math{y} axis are printed. The string ``.x=0,z=0'' is appended
to previous file names.

@node OutputAxisZ, OutputPlaneX, OutputAxisY, Function output for visualization
@subsection @code{OutputAxisZ} (logical, false)
@vindex @code{OutputAxisZ}

The values of the function on the @math{z} axis are printed. The string ``.x=0,y=0'' is appended
to previous file names.

@node OutputPlaneX, OutputPlaneY, OutputAxisZ, Function output for visualization
@subsection @code{OutputPlaneX} (logical, false)
@vindex @code{OutputPlaneX}

A plane slice at @math{x=0} is printed. The string ``.x=0'' is appended
to previous file names.

@node OutputPlaneY, OutputPlaneZ, OutputPlaneX, Function output for visualization
@subsection @code{OutputPlaneY} (logical, false)
@vindex @code{OutputPlaneY}

A plane slice at @math{y=0} is printed. The string ``.y=0'' is appended
to previous file names.

@node OutputPlaneZ, OutputDX, OutputPlaneY, Function output for visualization
@subsection @code{OutputPlaneZ} (logical, false)
@vindex @code{OutputPlaneZ}

A plane slice at @math{y=0} is printed. The string ``.z=0'' is appended to
previous file names.

@node OutputDX, OutputNETCDF, OutputPlaneZ, Function output for visualization
@subsection @code{OutputDX} (logical, false)
@vindex @code{OutputDX}

For printing all the three dimensional information, the open source program
visualization tool OpenDX (@uref{http://www.opendx.org/}) is used. The string
``.dx'' is appended to previous file names.  @xref{wf.net}.

@node OutputNETCDF, OutputEvery, OutputDX, Function output for visualization
@subsection @code{OutputNETCDF} (logical, false)
@vindex @code{OutputNETCDF}

Outputs in NetCDF (@uref{http://www.unidata.ucar.edu/packages/netcdf/}) format. This file
can then be read, for example, by OpenDX. The string ``.ncdf'' is appended to previous file names. 

@node OutputEvery,  , OutputNETCDF, Function output for visualization
@subsection @code{OutputEvery} (integer, 1000)
@code{OutputEvery}
The output is saved when the iteration number is a multiple of the
@code{OutputEvery} variable.


@c **********************************************************************
@node Spectrum calculations, Varia, Function output for visualization, Input file options
@section Spectrum calculations
Once @code{octopus} has been run, results must be analyzed somehow. The most common
thing is to Fourier-transform something to calculate spectra. This may be done through
some utilities (@code{strength-function}, @code{hs-from-mult}, @code{hs-from-acc} which
are described in section ``External utilities.'' Common options read by these utilities are:

@menu
* SpecTransformNode::           
* SpecDampMode::                
* SpecDampFactor::              
* SpecStartTime::               
* SpecEndTime::                 
* SpecEnergyStep::              
* SpecMinEnergy::               
* SpecMaxEnergy::               
* HSPolarization::              
@end menu

@node SpecTransformNode, SpecDampMode, Spectrum calculations, Spectrum calculations
@subsection @code{SpecTransformMode} (string, 'sin')
@vindex @code{SpecTransformMode}

What kind of Fourier transform is calculated. 'sin' and 'cos' are the valid options,
with obvious meanings.

@node SpecDampMode, SpecDampFactor, SpecTransformNode, Spectrum calculations
@subsection @code{SpecDampMode} (string, 'exp')
@vindex @code{SpecDampMode}

A damping function may be applied to the input fuction before processing the Fourier
transform. This function may be an exponential, a third order polynomial (fit
to be one at @math{t=0}, and also its derivative,  and null at @math{t=T}), 
or a gaussian: ``exp'' or ``pol'' or
``gau''. It amounts to applying a convolution of the signal in Fourier space,
either with a Lorentzian function (for the exponential), with a Gaussian function (for
the Gaussian), or with some other function (in the case of the third order polynomial.
If this variable is not present or has any other value, no damping function is applied.

@node SpecDampFactor, SpecStartTime, SpecDampMode, Spectrum calculations
@subsection @code{SpecDampFactor} (real, 0.0)
@vindex @code{SpecDampFactor}

If @code{SpecDampMode} is set to ``exp'', the damping parameter of the exponential
is fixed through this variable.

@node SpecStartTime, SpecEndTime, SpecDampFactor, Spectrum calculations
@subsection @code{SpecStartTime} (real, 0.0)
@vindex @code{SpecStartTime}

Processing is done for the given function in a time-window that starts at the
value of this variable.

@node SpecEndTime, SpecEnergyStep, SpecStartTime, Spectrum calculations
@subsection @code{SpecEndTime} (real, -1.0)
@vindex @code{SpecEndTime}

Processing is done for the given function in a time-window that ends at the
value of this variable.

@node SpecEnergyStep, SpecMinEnergy, SpecEndTime, Spectrum calculations
@subsection @code{SpecEnergyStep} (real, 0.05)
@vindex @code{SpecEnergyStep}

Sampling rate for the spectrum.

@node SpecMinEnergy, SpecMaxEnergy, SpecEnergyStep, Spectrum calculations
@subsection @code{SpecMinEnergy} (real, 0.0)
@vindex @code{SpecMinEnergy}

The Fourier transform is calculated for energies bigger than this value.

@node SpecMaxEnergy, HSPolarization, SpecMinEnergy, Spectrum calculations
@subsection @code{SpecMaxEnergy} (real, 20.0)
@vindex @code{SpecMaxEnergy}

The Fourier transform is calculated for energies smaller than this value.

@node HSPolarization,  , SpecMaxEnergy, Spectrum calculations
@subsection @code{HSPolarization} (string, 'z')
@vindex @code{HSPolarization}

For the utilities @code{hs-from-acc}, and @code{hs-from-mult}, the polarization
of the laser pulse must be specified. Valid values are ``x'', ``y'' and ``z'' for 
lasers linearly polarized along the respective axis, or ``+'' or ``-'' for lasers 
circularly polarized. See the description of @code{hs-from-acc} and @code{hs-from-mult}
for more details.



@c @c **********************************************************************
@c @node Born-Oppenheimer Dynamics, Varia, Photo-electron spectrum, Input file options
@c @subsection Born-Oppenheimer Dynamics
@c @itemize @bullet
@c 
@c @item @vindex @code{MoveIons}
@c @code{MoveIons} (integer, 0):
@c   What kind of simulation to perform. Possible values are:
@c   @itemize @minus
@c     @item @code{0}: Do not move the ions.
@c     @item @code{1}: Steepest descents.
@c     @item @code{2}: Damped Newtonian dynamics using Verlet.
@c     @item @code{3}: Newtonian dynamics using Verlet.
@c     @item @code{4}: Newtonian dynamics using velocity Verlet.
@c     @item @code{5}: Minimisation using conjugated gradients.
@c   @end itemize
@c 
@c @item @vindex @code{BOnSteps}
@c @code{BOnSteps} (integer, 1000):
@c   Number of time-steps to perform during the Born-Oppenheimer simulation.
@c 
@c @item @vindex @code{BOTimeStep}
@c @code{BOTimeStep} (double, 0.1 a.u.):
@c   Time-step used to integrate the Born-Oppenheimer equations of motion. 
@c   The default value @code{0.1} can safely be increased when performing
@c   steepest descents (@code{MoveIons == 1}).
@c 
@c @item @vindex @code{Gamma}
@c @code{Gamma} (double, 0.4):
@c   Value for the drag term when performing damped
@c   Newtonian dynamics (@code{MoveIons == 2}).
@c @end itemize

@c **********************************************************************
@node Varia,  , Spectrum calculations, Input file options
@section Varia

@menu
* PoissonSolver::               
* POLStaticField::              
* Displacement::                
@end menu

@node PoissonSolver, POLStaticField, Varia, Varia
@subsection @code{PoissonSolver} (integer, 3)
@vindex @code{PoissonSolver}

In 3D defines which method to use in order to solve the Poisson equation.
Allowed values are:
@itemize @minus
@item @code{cg} or @code{0}: Conjugated gradient method.
@item @code{fft} or @code{3}: FFTs with spherical cutoff.
@end itemize
The value of variable @code{DoubleFFTParameter} is used in case @code{3} method is used.

@node POLStaticField, Displacement, PoissonSolver, Varia
@subsection @code{POLStaticField} (double, 0.001 a.u.)
@vindex @code{POLStaticField}

Magnitude of the static field used to calculate the static polarizability 
in @code{CalculationMode = 7, 8}.

@node Displacement,  , POLStaticField, Varia
@subsection @code{Displacement} (double, 0.01 a.u.)
@vindex @code{Displacement}

When calculating phonon properties (@code{CalculationMode = 11}) @code{Displacement}
controls how much the atoms are to be moved in order to calculate the dynamical matrix.




@c **********************************************************************
@node External utilities, Examples, Input file options, Top
@chapter External utilities

A few small programs are generated along with @code{octopus}, for the
purpose of post-processing the generated information. These utilities
should all be run from the directory where @code{octopus} was run, so that
it may see the @code{inp} file, and the directories created by it.

@menu
* oct-sf::                      
* oct-rsf::                     
* oct-hs-mult::                 
* oct-hs-acc::                  
* oct-xyz-anim::                
* oct-excite::                  
* oct-broad::                   
* oct-make-st::                 
* oct-choose-st::               
* oct-center-geom::             
* wf.net::                      
@end menu

@node oct-sf, oct-rsf, External utilities, External utilities
@section @code{oct-sf}

This utility generates the dipole strength function of the given system.
Its main input is the @code{td.general/multipoles} file. Output is written
to a file called @code{spectrum}. This file is made of two
columns: energy (in eV or a.u., depending on the units specified in @code{inp}),
and dipole strength function (in 1/eV, or 1/a.u., idem).

In the @code{inp} file, the user may set the @code{SpecTransformMode} -- this
should be set to ``sin'' for proper use --, the @code{SpecDampMode} -- recommended
value is ``pol'', which ensures fulfilling of the N-sum rule, 
the @code{SpecStartTime}, the @code{SpecEndTime}, the @code{SpecEnergyStep}, 
the @code{SpecMinEnergy} and the @code{SpecMaxEnergy}.

@node oct-rsf, oct-hs-mult, oct-sf, External utilities
@section @code{oct-rsf}

@node oct-hs-mult, oct-hs-acc, oct-rsf, External utilities
@section @code{oct-hs-mult}

Calculates the harmonic spectrum, out of the multipoles file. To do.

@node oct-hs-acc, oct-xyz-anim, oct-hs-mult, External utilities
@section @code{oct-hs-acc}

Calculates the harmonic spectrum, out of the acceleration file. To do.

@node oct-xyz-anim, oct-excite, oct-hs-acc, External utilities
@section @code{oct-xyz-anim}

Reads out the @code{td.general/coordinates} file, and makes
a movie in XYZ format. To do.

@node  oct-excite, oct-broad, oct-xyz-anim, External utilities
@section @code{oct-excite}

Calculates the excitation spectrum within linear response. This utility can
output just the difference of eigenvalues by setting @code{LinEigenvalues},
the excitations using M. Petersilka formula (@code{LinPetersilka}), or
M. Casida (@code{LinCasida}). This utility requires that a calculation
of unoccupied states (@code{CalculationMode} = 3, 4) has been done before,
and it outputs the results to the sub-directory "linear".

@node  oct-broad, oct-make-st, oct-excite, External utilities
@section @code{oct-broad}

Generates a spectrum by broadening the excitations obtained by the @code{excitations} 
utility. The parameters of the spectrum can be set using the variables
@code{LinBroadening}, @code{MinEnergy}, @code{MaxEnergy}, and @code{EnergyStep}.

@node  oct-make-st, oct-choose-st, oct-broad, External utilities
@section @code{oct-make-st}

@code{make_st} reads @code{tmp/restart.static} and replaces some of the
Kohn-Sham states by Gaussians wave packets. The states which should be replaced are 
given in the @code{%MakeStates} section in the @code{inp} file and written to 
@code{tmp/restart.static.new}. (You probably want to copy that file to 
@code{tmp/restart.static} and use then @code{CalculationMode=5} or @code{6}.)

@vindex MakeStates
@example
%MakeStates
  ik | ist | idim | type | sigma | x0 | k
%
@end example

The first values stand for

@itemize @bullet
@item @math{ik}: The @math{k} point (or the spin, if @code{spin-components=2}) of the state
@item @math{ist}: The state to be replaced
@item @math{idim}: The component of the state (if the wave functions have more than one component, i.e. when @code{spin-components=3} is used).
@item The @math{type} of the wave packet; currently only @code{1} (Gaussian) is available
@end itemize

The next items depend on the type chosen.
For a Gaussian wave packet, defined as

@ifnottex
 psi(x) = 1/sigma sqrt(1/2pi) exp(ik(x-x0)) exp(-(x-x0)^2/(2 sigma^2)),
@end ifnottex
@tex
$$
 \psi_0(x) = {1\over \sqrt{2\pi}\sigma} {\rm e}^{{\rm i} k (x-x_0)}{\rm e}^{-{(x-x_0)^2\over 2\sigma^2}},
$$
@end tex

they are:

@itemize @bullet
@item @math{\sigma} the width of the Gaussian
@item @math{k}: the @strong{k} vector. In 3D use @code{k1|k2|k3}.
@item @math{x_0}: the coordinate where the Gaussian is initially centred. In 3D use @code{x01|x02|x03}.
@end itemize


@node  oct-choose-st, oct-center-geom, oct-make-st, External utilities
@section @code{oct-choose-st}

@code{choose_st} is used to choose the states used for optimum control (@code{CalculationMode=12}). You probably want to calculate unoccuppied states (@code{CalculationMode=12}) first since @code{choose_st} reads @code{tmp/restart.static} and writes the choosen states to the @code{opt-control} sub-directory. The following parameters are read from the @code{inp}ut file:

@itemize @bullet

@item @vindex @code{ChooseStates}
@code{ChooseStates} (integer, 1-4024):
  The states which should be written.

@item @vindex @code{ChooseStatesFilename}
@code{ChooseStatesFilename} (string, 'wf.initial'):
  The file name to which the state(s) should be written.
  For optimum control you only need 'wf.initial' and 'wf.final'.
@end itemize

@node oct-center-geom, wf.net, oct-choose-st, External utilities
@section @code{oct-center-geom}

It centers the molecular geometry.

@node wf.net,  , oct-center-geom, External utilities
@section @code{wf.net}

This is an OpenDX network, aimed at the visualization of wave-functions.
To be able to use it, you need to have properly installed the OpenDX
program (get it at opendx.org), as well as the Chemistry extensions
obtainable at the Cornell Theory Center
(http://www.tc.cornell.edu/Services/Vis/dx/index.asp).
Once these are working, you may follow a small tutorial on @code{wf.net}
by following next steps:

@itemize o

@item Place in a directory the program wf.net, the (needed) auxiliary file
wf.cfg, and the sample inp file that can all be found in @code{OCTOPUS-HOME}/util.

@item Run @code{octopus}. The inp file used prescribes the calculation of the
C atom in its ground state, in spin-polarized mode. It also prescribes that the
wave-functions should be written in ``dx'' format. At the end, these should be written
in subdirectory ``static'': wf-00x-00y-1.dx, where x runs from 1 to 2 (spin
quantum number) and y runs from 1 to 4 (wave-function index).

@item Run the OpenDX program. Click on ``Run Visual Programs'' on the DX main menu,
and select the program @code{wf.net}. The program will be executed, and several windows
should open. One of them should be called ``Application Comment''. It contains
a small tutorial. Follow it from now on.

@end itemize

@c **********************************************************************
@node Examples, Options Index, External utilities, Top
@chapter Examples

@menu
* Hello world::                 
* Benzene::                     
@end menu

@node Hello world, Benzene, Examples, Examples
@subsection Hello world

As a first example, we will take a sodium atom.
With your favourite text editor, create
the following input ``inp''.
@example
  SystemName = 'Na'
  CalculationMode = 1
  %Species
    'Na' | 22.989768 | 11 | "tm2" | 0 | 0
  %
  %Coordinates
    'Na' | 0.0 | 0.0 | 0.0 | no
  %
  Radius = 12.0
  Spacing = .6
  TypeOfMixing = 2
@end example


This input file should be essentially self-explanatory. 
Note that a Troullier-Martins pseudopotential file (``Na.vps'', or ``Na.ascii'') should
be accesible to the program. A sample ``Na.ascii'' may be found
in @code{OCTOPUS-HOME/share/PP/TM2}. If @code{octopus} was installed
(@code{make install} was issued after @code{make}), there should be no need
to do anything -- the program should find it. Otherwise, you may as well place it
in the working directory.
Then run @code{octopus} -- for example, do @code{octopus > out }, so that the 
output is stored in ``out'' file. If everything goes OK, ``out'' should look like
@footnote{
Before this output, a beautiful octopus ascii-art picture may be printed...
}:
@example
                    Running octopus, version 1.1
             (build time - Fri Mar 14 14:23:49 CET 2003)

Info: Calculation started on 2003/03/17 at 03:49:56
Info: Reading pseudopotential from file:
      '/home/marques/share/octopus/PP/TM2/Na.ascii'
      Calculating atomic pseudo-eigenfunctions for specie Na....
      Done.
Info: l =  0 component used as local potential
  Type = sphere           Radius [b] =  12.000
  Spacing [b] = ( 0.600, 0.600, 0.600)    volume/point [b^3] =  0.21600
  # inner mesh =  33401   # outer mesh =  18896
Info: Derivatives calculated in real-space
Info: Local Potential in Reciprocal Space.
Info: FFTs used in a double box (for poisson | local potential)
      box size = (  81,  81,  81)
      alpha =      2.00000
Info: Using FFTs to solve poisson equation with spherical cutoff.
Info: Exchange and correlation
      Exchange    family    : LDA 
                  functional: non-relativistic  
      Correlation family    : LDA 
                  functional: Perdew-Zunger 
Info: Allocating rpsi.
Info: Random generating starting wavefunctions.
Info: Unnormalized total charge =      0.998807
Info: Renormalized total charge =      1.000000
Info: Setting up Hamiltonian.
Info: Performing LCAO calculation.
Info: LCAO basis dimension:      1
      (not considering spin or k-points)
Eigenvalues [H]
   #   Eigenvalue    Occupation      Error (1)
   1    -0.102098       1.000000
Info: SCF using real wavefunctions.
Info: Broyden mixing used. It can (i) boost your convergence,
      (ii) do nothing special, or (iii) totally screw up the run.
      Good luck!
Info: Converged =     0
Eigenvalues [H]
   #   Eigenvalue    Occupation      Error (1)
   1    -0.102975       1.000000      (2.8E-02)
Info: iter =    1 abs_dens = 0.53E-03 abs_ener = 0.60E+00

Info: Converged =     0
Eigenvalues [H]
   #   Eigenvalue    Occupation      Error (1)
   1    -0.102477       1.000000      (1.4E-03)
Info: iter =    2 abs_dens = 0.43E-03 abs_ener = 0.65E-05

Info: Converged =     1
Eigenvalues [H]
   #   Eigenvalue    Occupation      Error (1)
   1    -0.102419       1.000000      (5.1E-04)
Info: iter =    3 abs_dens = 0.39E-04 abs_ener = 0.20E-06

Info: Converged =     1
Eigenvalues [H]
   #   Eigenvalue    Occupation      Error (1)
   1    -0.102436       1.000000      (8.5E-05)
Info: iter =    4 abs_dens = 0.24E-04 abs_ener = 0.52E-08

Info: Converged =     1
Eigenvalues [H]
   #   Eigenvalue    Occupation      Error (1)
   1    -0.102437       1.000000      (1.5E-06)
Info: iter =    5 abs_dens = 0.14E-05 abs_ener = 0.36E-10

Info: SCF converged in    5 iterations
Info: Deallocating rpsi.
Info: Calculation ended on 2003/03/17 at 03:50:04
@end example
Take now a look at the 
working directory. It should include the following files:
@example
-rw-rw-r--    1 user  group       177 Jul 10 12:29 inp
-rw-rw-r--    1 user  group      4186 Jul 10 12:35 out
-rw-rw-r--    1 user  group      1626 Jul 10 12:35 out.oct
drwxrwxr-x    2 user  group      4096 Jul 10 12:35 static
drwxrwxr-x    2 user  group      4096 Jul 10 12:35 tmp
@end example

Besides the initial file (@code{inp}) and the @code{out} file, two new
directories appear. In @code{static}, you will find the file @code{info},
with information about the static calculation (it should be hopefully
self-explanatory, otherwise please complain to the authors).
In @code{tmp}, you will find the @code{restart.static}, a binary
file containg restart information about the ground-state, which is used if, for example,
you want to start a time-dependent calculation afterwards.
Finally, you can safely ignore @code{out.oct}: it is an output from 
the liboct library, irrelevant for what concerns physics ;).

@strong{Exercises}:
@itemize @bullet
@item Study how the total energy and eigenvalue of the sodium atom improve
  with the mesh spacing.

@item Calculate the static polarizability of the sodium atom (@code{CalculationMode = 7}).
  Two new files will be generated: @code{restart.pol} that can be used to resume
  the polarizability calculation, and @code{Na.pol} that contains the static polarizability
  tensor. Note that this calculation overwrites @code{tmp/restart.static}, so that
  what now is there is the ground state for the system @emph{with} an external static
  electrical field applied. Delete it since it is useless.

@item Calculate a few unoccupied states (@code{CalculationMode = 3}). The eigenspectrum
  will be in the file @code{eigenvalues}. Why don't we find a Rydberg series in the
  eigenspectrum?

@item Repeat the previous calculation with PBE, LB94, and exact exchange. 
  Don't forget to @strong{move} the file @code{tmp/restart.static} when switching
  between exchange-correlation functionals.

@item Perform a time-dependent evolution (@code{CalculationMode = 5}), to calculate
  the optical spectrum of the Na atom. Use a @code{TDDeltaStrength = 0.05}, polarised
  in the @code{x} direction. The multipole moments of the density are output to
  the file @code{td.general/multipoles}. You can process this file with the utility
  @code{strength-function} to obtain the optical spectrum. 
  If you have computer time to waste, re-run the time-dependent 
  simulation for some other xc choices.

@end itemize

@node Benzene,  , Hello world, Examples
@subsection Benzene

Well, the sodium atom is a bit too trivial. Let's try something harder: benzene.
you will just need the
geometry for benzene to be able to play. Here it is (in @AA{}):
@example
 C  0.000  1.396  0.000
 C  1.209  0.698  0.000
 C  1.209 -0.698  0.000
 C  0.000 -1.396  0.000
 C -1.209 -0.698  0.000
 C -1.209  0.698  0.000
 H  0.000  2.479  0.000
 H  2.147  1.240  0.000
 H  2.147 -1.240  0.000
 H  0.000 -2.479  0.000
 H -2.147 -1.240  0.000
 H -2.147  1.240  0.000
@end example

Follow now the steps of the previous example. Carbon and Hydrogen have a much harder
pseudo-potential than Sodium, so you will probably have to use a tighter
mesh. It also takes much more time...

@c ***************THE END OF THE DOCUMENT********************************
@node    Options Index,  , Examples, Top
@unnumbered Options Index
     
@printindex vr
     
@contents

@bye
@c **********************************************************************
