This is octopus.info, produced by makeinfo version 4.8 from
octopus.texi.

   This manual is for octopus 1.99devel, a first principles, electronic
structure, excited states, time-dependent density functional theory
program.

   Copyright (C) 2002, 2003, 2004 Miguel A. L. Marques, Alberto Castro
and Angel Rubio

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.1 or any later version published by the Free Software
     Foundation.

INFO-DIR-SECTION Individual utilities
START-INFO-DIR-ENTRY
* octopus: (octopus).           The octopus program.
END-INFO-DIR-ENTRY


File: octopus.info,  Node: Top,  Next: Authors,  Prev: (dir),  Up: (dir)

octopus
*******

This manual is for octopus 1.99devel, a first principles, electronic
structure, excited states, time-dependent density functional theory
program.

   Copyright (C) 2002, 2003, 2004 Miguel A. L. Marques, Alberto Castro
and Angel Rubio

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.1 or any later version published by the Free Software
     Foundation.

* Menu:

* Authors::                     The authors of the thing, and the collaborators.
* Copying::                     The licence.
* Installation::                How to install the program.
* The parser::                  The input file syntax.
* Description::                 How the code works in general terms.
* Input Variables::             The options to put in the input file.
* Undocumented Variables::      The variables that we did not have time to document.
* External utilities::          External Utilities
* Examples::                    Some examples.
* Options Index::               An index with all the options.












 --- The Detailed Node Listing ---

Installation

* Quick instructions::
* Long instructions::
* Different octopus executables::
* Troubleshooting::

Description

* Mesh::
* Run Mode SCF::
* Run Mode Unoccupied States::
* Run Mode Time Dependent::
* Function output for visualization::
* Spectrum calculations::

Input Variables

* Generalities::
* Hamiltonian::
* SCF::
* Spectrum Calculations::
* States::
* System::
* Time Dependent::
* Unoccupied States::

Generalities

* Debug::
* IO::
* Parallel::
* Units::

Hamiltonian

* Poisson::
* XC::
* Casida::
* General::
* Curvilinear::
* Derivatives::
* FFTs::
* Simulation Box::

Poisson

* Multigrid::

Curvilinear

* Gygi::

SCF

* Convergence::
* EigenSolver::
* Mixing::

System

* Coordinates::
* Species::
* Velocities::

External utilities

* oct-sf::
* oct-rsf::
* oct-hs-mult::
* oct-hs-acc::
* oct-xyz-anim::
* oct-excite::
* oct-broad::
* oct-make-st::
* oct-center-geom::
* wf.net::

Examples

* Hello world::
* Benzene::


File: octopus.info,  Node: Authors,  Next: Copying,  Prev: Top,  Up: Top

1 Authors
*********



The main developing team of this program is composed of:

   * Miguel A. L. Marques (Donostia International Physics Center, San
     Sebastia'n, Espan~a)

   * Angel Rubio, (Donostia International Physics Center and Department
     of Materials Science UPV/EHU, San Sebastia'n, Espan~a), and

   * Alberto Castro, (alberto.castro@tddft.org, Theoretische Physik,
     Freie Universita"t Berlin, Berlin 14195, Deutschland).

   Other contributors are:
   * Micael Oliveira: mixing, and a lot of stuff.

   * Carlo Andrea Rozzi - infinite systems (almost done!)

   * Sebastien Hamel    - paralel version of oct-excite.

   `octopus' is based on a fixed-nucleus code written by George F.
Bertsch and K. Yabana to perform real-time dynamics in clusters (Phys
Rev B *54*, 4484 (1996)) and on a condensed matter real-space
plane-wave based code written by A. Rubio, X. Blase and S.G. Louie
(Phys. Rev. Lett. *77*, 247 (1996)).  The code was afterwards extended
to handle periodic systems by G.F. Bertsch, J.I. Iwata, A. Rubio, and
K. Yabana (Phys. Rev. B, *62*, 7998 (2000)). Contemporaneously there was
a major rewrite of the original cluster code to handle a vast majority
of finite systems. At this point the cluster code was named "tddft".

   This version was consequently enhanced and beautified by A. Castro
(at the time Ph.D. student of A. Rubio), originating a fairly verbose
15,000 lines of Fortran 90/77. In the year 2000, M. Marques (aka
Hyllios, aka Anto'nio de Faria, corsa'rio portugue^s), joined the A.
Rubio group in Valladolid as a postdoc. Having to use "tddft" for his
work, and being petulant enough to think he could structure the code
better than his predecessors, he started a major rewrite of the code
together with A. Castro, finishing version 0.2 of "tddft." But things
were still not perfect: due to their limited experience in Fortran 90,
and due to the inadequacy of this language for anything beyond a HELLO
WORLD program, several parts of the code were still clumsy. Also the
idea of GPLing the almost 20,000 lines arose during an alcoholic
evening. So after several weeks of fantic coding and after getting rid
of the Numerical Recipes code that still lingered around, `octopus' was
born.

   The present released version has been completely rewritten and keeps
very little relation to the old version (even input and output files)
and has been enhanced with major new flags to perform various
excited-state dynamics in finite and extended systems (one-dimensional
periodic chains). The code will be updated frequently and new versions
can be found here (http://www.tddft.org/programs/octopus).

   The main features of the present version are described in detail in
_octopus: a first principles tool for excited states electron-ion
dynamics_, Comp. Phys. Comm. *151*, 60 (2003).  Updated references as
well as results obtained with octopus will be posted regularly to the
`octopus' web page. If you find the code useful for you research we
would appreciate if you give reference to this work and previous ones.

   If you have some free time, and if you feel like taking a joy ride
with Fortran 90, just drop us an email <octopus@tddft.org>. You can
also send us patches, comments, ideas, wishes, etc. They will be
included in new releases of octopus.



File: octopus.info,  Node: Copying,  Next: Installation,  Prev: Authors,  Up: Top

2 Copying
*********

The `octopus'  Copying Conditions
*********************************

This program is "free"; this means that everyone is free to use it and
free to redistribute it on a free basis.  What is not allowed is to try
to prevent others from further sharing any version of this program that
they might get from you.

   Specifically, we want to make sure that you have the right to give
away copies of the program, that you receive source code or else can
get it if you want it, that you can change this program or use pieces
of them in new free programs, and that you know you can do these things.

   To make sure that everyone has such rights, we have to forbid you to
deprive anyone else of these rights.  For example, if you distribute
copies of the program, you must give the recipients all the rights that
you have.  You must make sure that they, too, receive or can get the
source code.  And you must tell them their rights.

   Also, for our own protection, we must make certain that everyone
finds out that there is no warranty for this program.  If these
programs are modified by someone else and passed on, we want their
recipients to know that what they have is not what we distributed, so
that any problems introduced by others will not reflect on our
reputation.

   The precise conditions of the license are found in the General Public
Licenses that accompany it.


File: octopus.info,  Node: Installation,  Next: The parser,  Prev: Copying,  Up: Top

3 Installation
**************

Maybe somebody else installed the `octopus'  for you. In that case, the
files should be under some directory that we can call `PREFIX': the
executables in `PREFIX/bin' (e.g. if `PREFIX=/usr/local', the main
`octopus' executable is then `/usr/local/bin/octopus'); the
documentation in `info' format in `PREFIX/info' (so that you may see it
by typing `info -f PREFIX/info/octopus.info' if the `info' program is
installed in your system); some sample files in
`PREFIX/share/octopus/samples'; the pseudopotential files that
`octopus'  will need in `PREFIX/share/octopus/PP', etc.

   However, you may be unlucky and that is not the case. In the
following we will try to help you with the, still rather unfriendly,
task of compiling and installing the `octopus'  .

* Menu:

* Quick instructions::
* Long instructions::
* Different octopus executables::
* Troubleshooting::


File: octopus.info,  Node: Quick instructions,  Next: Long instructions,  Prev: Installation,  Up: Installation

3.1 Quick instructions
======================

For the inpatients, here goes the quick-start:
     prompt> gzip -cd octopus<-version>.tar.gz | tar xvf -
     prompt> cd octopus-<version>
     prompt> ./configure
     prompt> make
     prompt> make install

   This will probably *not* work, so before giving up, just read the
following paragraphs.

   Also, rpm and deb binaries for linux are supplied on the web-page.


File: octopus.info,  Node: Long instructions,  Next: Different octopus executables,  Prev: Quick instructions,  Up: Installation

3.2 Long instructions
=====================

The code is written in standard Fortran 90, with some routines written
in C (and in bison, if we count the input parser). To build it you will
need both a C compiler (`gcc' works just fine), and a Fortran 90
compiler. No free-software Fortran 90 compiler is available yet, so, if
you want to chew the `octopus', you will have either to help the g95
(http://g95.sourceforge.net) or gfortran (http://gcc.gnu.org/fortran)
projects, or use any of the available comercial compilers.

   Besides the compiler, you will also need:
  1. `make':  most computers have it installed, otherwise just grab and
     install the GNU `make'.

  2. `cpp': The C preprocessor is heavily used in `octopus'.  GNU `cpp'
     is just fine, but any `cpp' that accepts the `-C' flag (preserve
     comments) should work just as well.

  3. FFTW: We have relied on this great library to perform the Fast
     Fourier Transforms (FFTs). You may grab it from here
     (http://www.fftw.org/).  You may use FFTW version 2 as well as
     FFTW version 3. `octopus' will try first to use the latter one,
     since it is significantly faster in some architectures.

  4. LAPACK/BLAS: Required. Our politics is to rely on these two
     libraries as much as possible on these libraries for the linear
     algebra operations.  If you are running Linux, there is a fair
     chance they are already installed in your system. The same goes to
     the more heavyweight machines (alphas, IBMs, SGIs, etc.).
     Otherwise, just grab the source from here (http://www.netlib.org).

  5. GSL: Finally that someone had the nice idea of making a public
     scientific library! GSL still needs to grow, but it is already
     quite useful and impressive.  `octopus' uses splines, complex
     numbers, special functions, etc. from GSL, so it is a must! If you
     don't have it already installed in your system, you can obtain GSL
     from here (http://sources.redhat.com/gsl/). You will need version
     1.0 or higher.

  6. MPI: If you want to run `octopus' in multi-tentacle (parallel)
     mode, you will need an implementation of MPI.  MPICH
     (http://www-unix.mcs.anl.gov/mpi/mpich/) works just fine in our
     Linux boxes.


   First you should obtain the code file, `octopus<-version>.tar.gz',
(this you probably have already done). The code is freely available, and
can be downloaded from `http://www.tddft.org/programs/octopus'. There
exists a `cvs' server, which you can browse at
`http://nautilus.fis.uc.pt/cgi-bin/cvsweb.cgi/marques/octopus/'.  The
sources of the cvs version (in general more unstable the the _official_
distribution) may be downloaded by anonymous cvs access:

     prompt> cvs -d :pserver:anonymous@nautilus.fis.uc.pt:/server/cvsroot
             login

     prompt> cvs -d :pserver:anonymous@nautilus.fis.uc.pt:/server/cvsroot
             co marques/octopus

   Uncompress and untar it (`gzip -cd octopus<-version>.tar.gz | tar
-xvf -').  In the following, `OCTOPUS-HOME' denotes the home directory
of octopus, created by the `tar' command.

   The `OCTOPUS-HOME' contains the following subdirectories:
   * `autom4te.cache, build, CVS, debian': contains files related to
     the building system or the CVS repository. May actually not be
     there.  Not of real interest for the plain user.

   * `doc': The documentation of `octopus' in _texinfo_ format.

   * `liboct': Small C library that handles the interface to GSL and
     the parsing of the input file. It also contains some assorted
     routines that we didn't want to write in boring Fortran.

   * `share/PP': Pseudopotentials.  In practice now it contains the
     Troullier-Martins and Hartwigsen-Goedecker-Hutter pseudopotential
     files.

   * `share/util': Currently, the _utilities_ include a couple of IBM
     OpenDX networks (`wf.net'), to visualize wavefunctions, densities,
     etc.

   * `share/samples': A couple of sample input files.

   * `src': Fortran 90 source files. Note that these have to be
     preprocessed before being fed to the Fortran compiler, so do not
     be scared by all the # directives.

   Before configuring you can (should) setup a couple of options.
Although the configure script tries to guess your system settings for
you, we recommend that you set explicitly the default Fortran compiler
and the compiler options.  For example, in `bash' you would typically
do:
     export FC=abf90
     export FCFLAGS="-O -YEXT_NAMES=LCS -YEXT_SFX=_"
   if you are using the Absoft Fortran 90 compiler on a linux machine.
Also, if you have some of the required libraries in some unusual
directories, these directories may be placed in the variable `LDFLAGS'
(e.g., `export LDFLAGS=$LDFLAGS:/opt/lib/').

   The configuration script will try to find out which compiler you are
using.  Unfortunately, and due to the nature of the primitive language
that `octopus' is programmed in, the automatic test fails very often.
Often it is better to set the variable `FCFLAGS' by hand. These are
some of the options reported to work:
`intel ifc (PIV)'
     `-u -zero -fpp1 -nbs -i_dynamic -pc80 -pad -align  -unroll -O3 -r8
     -ip -tpp7 -xW'

`absoft (i386)'
     `-O3 -YEXT_NAMES=LCS -YEXT_SFX=_'

`absoft (opteron)'
     `-O3 -mcmodel=medium -m64 -cpu:host -YEXT_NAMES=LCS -YEXT_SFX=_'

`NAG (opteron)'
     `-colour -kind=byte -mismatch_all -abi=64 -ieee=full -O4
     -Ounroll=4'

`pgi (opteron)'
     `-fast -mcmodel=medium -O4'

`alpha'
     `-align dcommons -fast -tune host -arch host -noautomatic'

`xlf (IBM)'
     `-bmaxdata:0x80000000 -qmaxmem=-1 -qsuffix=f=f90 -Q -O5 -qstrict
     -qtune=auto -qarch=auto -qhot -qipa'

`sgi'
     `-O3 -INLINE -n32 -LANG:recursive=on'

   You can now run the configure script (`./configure').  (1) You can
use a fair amount of options to spice `octopus' to your own taste.  To
obtain a full list just type `./configure --help'. Some commonly used
options include:
   * `--prefix=PREFIX': Change the base installation dir of `octopus'
     to `PREFIX'. The executable will be installed in `PREFIX/bin', the
     libraries in `PREFIX/lib' and the documentation in `PREFIX/info'.
     `PREFIX' defaults to the home directory of the user who runs
     `configure'.  (2)

   * `--with-fft=fftw2': Instruct the `configure' script to use the FFTW
     library, and specifically to use the FFTW version 2. You may also
     set `--with-fft=fftw3' or even `--disable-fft', although this last
     option is dis-encouraged.

   * `--with-fft-lib=<lib>': Instruct the `configure' script to look
     for the FFTW library exactly in the way that it is specified in
     the `<lib>' argument, i.e `--with-fft-lib='-L/opt/lib -lfftw3''.

   * `--with-blas=<lib>': Instruct the `configure' script to look for
     the BLAS library in the way that it is specified in the `<lib>'
     argument.

   * `--with-lapack=<lib>': Instruct the `configure' script to look for
     the BLAS library in the way that it is specified in the `<lib>'
     argument.

   * `--with-gsl-prefix=DIR': Installation directory of the GSL
     library. The libraries are expected to be in `DIR/lib' and the
     include files in `DIR/include'. The value of `DIR' is usually
     found by issuing the command `gsl-config --prefix'. (If the GSL
     library is installed, the program `gsl-config' should be
     somewhere.)

   * `--with-netcdf=<lib>': NETCDF library. This is a recommended
     library, although not necessary.

   In addition to these options, several other options have to be
passed to build different executables of octopus (parallel, debugging
version, etc) - *Note Different octopus executables::.

   Run `make', and then `make install'. If everything went fine, you
should now be able to taste `octopus'. Depending on the options passed
to the configure script, some suffixes could be added to the generic
name `octopus' -- i.e. `octopus_cmplx' for the code compiled for
complex wave-functions, `octopus_cmplx_mpi' for a parallel version of
the code compiled for complex wave-function, and so on.

   Depending on the value given to the `--prefix=PREFIX' given, the
executables will reside in `PREFIX/bin', the info file with the
documentation in `PREFIX/info' (so that it may be viewed running `info
-f PREFIX/info/octopus.info'), and the auxiliary files will be copied
to `PREFIX/share/octopus'. The sample input files will be copied to
`PREFIX/share/octopus/samples'.

   The program has been tested in the following platforms:
   * `i686*-linux-gnu': with the Absoft (http://www.absoft.com),   and
     the Intel (http://www.intel.com/software/products/compilers/)
     compiler.

   * `alphae*': both in Linux and in OSF/1 with Compaq's `fort'
     compiler.

   * `powerpc-ibm-aix4.3.3.0': with native `xlf90' compiler.

   * `cray': with native f90 compiler.

   * `opteron': with NAG, PGI, and ABSOFT compilers.

   * `SGI': with native compiler.
   If you manage to compile/run `octopus' on a different platform or
with a different compiler, please let us know so we can update the
list. Patches to solve compiler issues are also welcomed.

   Build the documentation in the format you prefer. Since you are
reading this, you already have it in some format (but maybe not the
correct version).  Due to the power of `texinfo', a series of formats
are available, namely `dvi', `html', `pdf' and `info'. The
`octopus.texi' source code of this document is in the
`OCTOPUS-HOME/doc' directory.

   ---------- Footnotes ----------

   (1) If you downloaded the cvs version, you will not find the
`configure' script.  In order to compile the development version you
will first have to run the GNU autotools.  This may be done by
executing the `autoreconf' perl script (a part of the `autoconf'
distribution).  Note that you need to have working versions of the
`automake' (1.8.5), `autoconf' (2.59) and `libtool' (1.5.6) programs
(the versions we currently use are between parentheses). Note that the
`autoreconf' script will likely fail if you have (much) older versions
of the autotools.

   (2) You may fine-tune further the instalation by making use of a set
of standard options (`--exec-prefix, --bindir, --datadir,
--program-prefix', etc) that are described in the output of
`./configure --help'


File: octopus.info,  Node: Different octopus executables,  Next: Troubleshooting,  Prev: Long instructions,  Up: Installation

3.3 Different octopus executables
=================================

By performing the standard install, you will get an executable called
`octopus', and a set of utility programs called `oct-'_something_.
However, the code may be compiled differently in order to profit from
special feautures (e.g parallel executables, etc). The following is a
list of the options that have to be passed to the `configure' script in
order to obtain these different executables.

   * `--enable-complex': Builds a version with complex wave-functions
     for the ground-state calculations (wave-functions are always
     complex for the evolution). This is needed when spinors are needed
     -- e.g. noncollinear magnetism is going to be considered, or the
     spin-orbit coupling term will be used. The suffix `_cmplx' is
     appended to the `octopus' executable name.

   * `--enable-debug': Builds a version that is able to emit some
     debugging information. Useful for developers, or to report bugs.
     If `octopus' has been built with this option enabled, you may set
     the variable `Verbose' to "debug" level, and set `DebugLevel' The
     suffix `_debug' is appended to the `octopus' executable name.

   * `--enable-single': Builds a version that works in single precision
     mode, rather than in the standard double precision. It will work
     faster.  Unfortunately we are not yet fully sure of the proper
     functioning of the code in this manner.  The suffix `_single' is
     appended to the `octopus' executable name.

   * `--enable-mpi': Builds the parallel version (MPI) of `octopus'.
     The suffix `_mpi' is appended to the `octopus' executable name.



File: octopus.info,  Node: Troubleshooting,  Prev: Different octopus executables,  Up: Installation

3.4 Troubleshooting
===================

If you are reading this it is because something went wrong. Let us see
if we can fix it ;)

   *Could not find library...*: This is probably the most common error
you can get. `octopus' uses three different libraries, GSL, FFTW, and
BLAS/LAPACK. We assume that you have already installed these libraries
but, for some reason, you were not able to compile the code. So, what
went wrong?
   * Did you pass the correct `--with-XXXX' (where XXXX is gsl, fftw or
     lapack in lowercase) to the configure script? If your libraries are
     installed in a non-standard directory (like `/opt/lapack'), you
     will have to pass the script the location of the library (in this
     example, you could try `./configure --with-lapack='-L/opt/lapack
     -llapack''.

   * If you are working on an alpha station, do not forget that the
     `CXML' library includes `BLAS' and `LAPACK', so it can be used by
     `octopus'. If needed, just set the correct path with
     `--with-lapack'.

   * If the configuration script can not find `FFTW', it is probable
     that you did not compile `FFTW' with the same Fortran compiler or
     with the same compiler options. The basic problem is that Fortran
     sometimes converts the function names to uppercase, at other times
     to lowercase, and it can add an "_" to them, or even two.
     Obviously all libraries and the program have to use the same
     convention, so the best is to compile everything with the same
     Fortran compiler/options. If you are a power user, you can check
     the convention used by your compiler using the command `nm
     <library>'.


   *Whatever went wrong...*: Up to now, we cannot really make a list of
commonly found problems. So if something else went wrong, please
subscribe to `octopus-users' mailing list, and ask.


File: octopus.info,  Node: The parser,  Next: Description,  Prev: Installation,  Up: Top

4 The parser
************

All input options should be in a file called "`inp'", in the directory
`octopus' is run from. Alternatively, if this file is not found,
standard input is read. For a fairly comprehensive example, just look
at the file `OCTOPUS_HOME/share/samples/Na2' -- if you installed the
code (you did the `make install'), this file will also be in
`PREFIX/share/octopus/samples/Na2'.

   At the beginning of the program `liboct' reads the input file,
parses it, and generates a list of variables that will be read by
`octopus' (note that the input is case independent).  There are two
kind of variables, scalar values (strings or numbers), and blocks (that
you may view as matrices). A scalar variable `var' can be defined by:
     var = exp
   `var' can contain any alphanumeric character plus "_", and `exp' can
be a quote delimited string, a number (integer, real, or complex), a
variable name, or a mathematical expression.  In the expressions all
arithmetic operators are supported ("a+b", "a-b", "a*b", "a/b"; for
exponentiation the C syntax "a^b" is used), and the following functions
can be used:
   * `sqrt(x)': The square root of `x'.

   * `exp(x)': The exponential of `x'.

   * `log(x)' or `ln(x)': The natural logarithm of `x'.

   * `log10(x)': Base 10 logarithm of `x'.

   * `sin(x)', `cos(x)', `tan(x)', `cot(x)',   `sec(x)', `csc(x)': The
     sinus, co-sinus, tangent, co-tangent,   secant and co-secant of
     `x'.

   * `asin(x)', `acos(x)', `atan(x)', `acot(x)',   `asec(x)',
     `acsc(x)': The inverse (arc-) sinus, co-sinus, tangent, co-tangent,
      secant and co-secant of `x'.

   * `sinh(x)', `cosh(x)', `tanh(x)', `coth(x)',   `sech(x)',
     `csch(x)': The hyperbolic sinus, co-sinus, tangent, co-tangent,
     secant and co-secant of `x'.

   * `asinh(x)', `acosh(x)', `atanh(x)', `acoth(x)',   `asech(x)',
     `acsch(x)': The inverse hyperbolic sinus, co-sinus, tangent,
     co-tangent,   secant and co-secant of `x'.
   You can also use any of the predefined variables:
   * `pi': 3.141592653589793, what else is there to say?

   * `e': The base of the natural logarithms.

   * `false' or `f' or `no': False in all its flavors. For the
     curious, `false' is defined as 0.

   * `true' or `t' or `yes': The truthful companion of `false'. For the
      curious, `true' is defined as 1.

   Blocks are defined as a collection of values, organised in row and
column format.  The syntax is the following:
     %var
       exp | exp | exp | ...
       exp | exp | exp | ...
       ...
     %
   Rows in a block are separated by a newline, while columns are
separated by the character "|" or by a tab. There may be any number of
lines and any number of columns in a block. Note also that each line
can have a different number of columns.

   If `octopus' tries to read a variable that is not defined in the
input file, it automatically assigns to it a default value. All
variables read are output to the file "`out.oct'". If you are not sure
of what the program is reading, just take a look at it.  Everything
following the character "#" until the end of the line is considered a
comment and is simply cast into oblivion.


File: octopus.info,  Node: Description,  Next: Input Variables,  Prev: The parser,  Up: Top

5 Description
*************

* Menu:

* Mesh::
* Run Mode SCF::
* Run Mode Unoccupied States::
* Run Mode Time Dependent::
* Function output for visualization::
* Spectrum calculations::


File: octopus.info,  Node: Mesh,  Next: Run Mode SCF,  Prev: Description,  Up: Description

5.1 Mesh
========

`octopus' uses a grid in real space to solve the Kohn-Sham equations.
The grid is equally-spaced, but the spacings can be different for each
Cartesian direction. The shape of the simulation region may also be
tuned to suit the geometric configuration of the system.


File: octopus.info,  Node: Run Mode SCF,  Next: Run Mode Unoccupied States,  Prev: Mesh,  Up: Description

5.2 Run Mode SCF
================

The ground-state electronic density in a Kohn-Sham (KS) based
electronic structure code such as `octopus'  is obtained after a
self-consistent process that attempts to solve the KS equations.  In
essence, the problem is the following: at a given iteration step, one
departs from an approximated solution - some KS eigenfunctions
\psi^inp_j, eigenvalues \epsilon^inp_j and density \rho^inp, which
determines a KS "input" Hamiltonian. By diagonalizing this Hamiltonian,
one obtains the corresponding "output" eigenfunctions, eigenvalues, and
density.  This cycle is considered to be closed, and the solution
achieved, when some convergence criterion is fulfilled.  In our case,
we have allowed for four different criteria, to be defined below.  The
self consistent procedure will stop when the first of the convergence
criteria is fulfilled, or either when a a maximum number of iterations
has been performed.


File: octopus.info,  Node: Run Mode Unoccupied States,  Next: Run Mode Time Dependent,  Prev: Run Mode SCF,  Up: Description

5.3 Run Mode Unoccupied States
==============================

These variables are only used in `CalculationMode == unocc,
unocc_start'. The purpose of these run modes is to calculate higher
lying Kohn-Sham orbitals. For that purpose, it reads the restart
information from a converged previous ground-state calculation, and
builds the corresponding Hamiltonian. Then, it calculates the
eigenvalues and eigenfunctions that are requested by the user.

   Note: These variables are also used in `CalculationMode = td' or
`td_start' if `TDOccupationalAnalysis == 1').


File: octopus.info,  Node: Run Mode Time Dependent,  Next: Function output for visualization,  Prev: Run Mode Unoccupied States,  Up: Description

5.4 Run Mode Time Dependent
===========================

When `CalculationMode = (td | td_start)', the code performs the time
propagation of the electronic orbitals and - if required - of the ionic
positions. This latter task does not pose major algorithmical problems
(the usual Verlet algorithms deal with that task); however the best way
to propagate a Schro"dinger-like equation is still unclear. Due to this
fact, we provide with a rather excessive selection of possibilities for
that purpose. Before describing the set of variables necessary to
specify the way in which the time evolution is to be performed, it is
worth making a brief introduction to the problem.

   We are concerned with a set of Schro"dinger-like equations for the
electronic orbitals:

   i{\partial psi_i \over \partial t} = H(t)\psi_i(t)\,,

   \psi_i(t=0) = \psi_i^0\,.

   Being the equation linear, one may formally define a linear
"evolution" operator, which trasforms the initial vector into the
solution at time T:

   \psi_i(T) = U(T, 0)\psi_i^0

   Moreover, there is a formal exact expression for the evolution
operator:

   \psi_i(T) = T\exp\lbrace -i\!\!\int_0^{T}d\tau H(\tau)\rbrace
\psi_i^0\,.

   where T\exp is the time-ordered exponential. If the Hamiltonian
conmutes with itself at different times, we can drop the time-ordering
product, and leave a simple exponential.  If the Hamiltonian is
time-independent - which makes it trivially self commuting, the
solution is then simply written as:

   \psi_i(T) = \exp\lbrace -iTH\rbrace \psi_i^0\,.

   Unfortunately, this is not the case in general. We have to find an
algorithm able to cope with time-dependent Hamiltonians, such as the
self-consistent time-dependent Kohn-Sham operator, which is built "self
consistently" from the varying electronic density.

   The first step is to perform a time-discretization: the full
propagation between 0 and T is decomposed as:

   U(T,0) = \prod_{i=0}^{N-1}U(t_i+\delta t,t_i)\,,

   where t_0=0, t_N=T, \delta t = T/N. So at each time step we are
dealing with the problem of performing the short-time propagation:

   \psi_i(t+\delta t) = U(t+\delta t, t)\psi_i(t) = T\exp\lbrace
-i\!\!\int_{t}^{t+\delta t}\!\!\!\!\!\!\!\!\!d\tau\,H(\tau)\rbrace
\psi(t)\,.

   In this way, one can monitor the evolution in the interior of [0,t].
In fact, the possibility of monitoring the evolution is generally a
requirement; this requirement imposes a natural restriction on the
maximum size of \delta t: if \omega_\rm max is the maximum frequency
that we want to discern, \delta t should be no larger than \approx
1/\omega_\rm max.  Below this \delta t_\rm max, we are free to choose
\delta t considering performance reasons: Technically, the reason for
the discretization is twofold: the time-dependence of H is alleviated,
and the norm of the exponential argument is reduced (the norm increases
linearly with \delta t).

   Since we cannot drop the time-ordering product, the desired algorithm
cannot be reduced, in principle, to the calculation of the action of
the exponential of an operator over the initial vector.  Some
algorithms tailored to approximate the evolution operator, in fact, do
not even require to peform such operator exponentials.  Most of them,
however, do rely on the calculation of one or more exponentials, such
as the ones used by `octopus'. This is why in principle we need to
specify two different issues: the "evolution method", and the
"exponential method". In other words: we need an algorithm to
approximate the evolution operator U(t+\delta t, t) - which will be
specified by variable `TDEvolutionMethod' - and, if this algorithm
requires it, we will also need an algorithm to approximate the
exponential of a matrix operator \exp\lbrace A\rbrace - which will be
specified by variable `TDExponentialMethod'.


File: octopus.info,  Node: Function output for visualization,  Next: Spectrum calculations,  Prev: Run Mode Time Dependent,  Up: Description

5.5 Function output for visualization
=====================================

Every given number of time iterations, or after ground-state
calculations, some of the functions that characterise the system may be
written to disk so that they may be analized. Files are written within
"static" output directory after the self-consistent field, or within
"td.x" directories, during evolution, where "x" stands for the
iteration number at which each write is done.  Note that if you wish to
plot any function (`OutputKSPotential = yes', etc.), at least one of
the output formats should be enabled (`OutputPlaneX = yes', `OutputDX =
yes', `OutputNETCDF = yes', etc.). [This is not necessary if you wish
to plot the geometry (`OutputGeometry = yes')]. Note further that the
data written by `OutputAxisX', `OutputPlaneX' etc. has always the
(side) length of the longest axis; this is independent from the  chosen
geometry. Data points which are inexistent in the actual geometry have
the value zero in those files.


File: octopus.info,  Node: Spectrum calculations,  Prev: Function output for visualization,  Up: Description

5.6 Spectrum calculations
=========================

Once `octopus' has been run, results must be analyzed somehow. The most
common thing is to Fourier-transform something to calculate spectra.
This may be done through some utilities (`strength-function',
`hs-from-mult', `hs-from-acc' which are described in section "External
utilities." Common options read by these utilities are:


File: octopus.info,  Node: Input Variables,  Next: Undocumented Variables,  Prev: Description,  Up: Top

6 Input Variables
*****************

`octopus' has quite a few options, that we will subdivide in different
groups.  After the name of the option, its type and default value (when
applicable) are given in parenthesis.

* Menu:

* Generalities::
* Hamiltonian::
* SCF::
* Spectrum Calculations::
* States::
* System::
* Time Dependent::
* Unoccupied States::


File: octopus.info,  Node: Generalities,  Next: Hamiltonian,  Prev: Input Variables,  Up: Input Variables

6.1 Generalities
================

   * *CalculationMode*
     _Section_: Generalities
     _Default_: gs
     Decides what kind of calculation is to be performed

     _Options_:
        - *gs* (01):  Calculation of the ground state

        - *unocc* (02):  Calculation of unoccupied/virtual KS states

        - *td* (03):  Time-dependent calculation

        - *pol* (04):  Calculation of the static polarizability

        - *geom* (05):  Optimization of the geometry

        - *phonons* (06):  Calculation of the vibrational modes

        - *opt_control* (07):  Optimal control.

        - *pol_lr* (08):  Linear-response calculation of the
          polarizability

        - *casida* (09):  Excitations via linear-response TDDFT

        - *wave_matching* (10):  Wave-matching a la Heiko

        - *bo* (98):  Born-Oppenheimer-like Molecular Dynamics

        - *recipe* (99):  Prints out a tasty recipe

   * *Dimensions*
     _Section_: Generalities
     _Default_: 3
     octopus can run in 1, 2 or 3 dimensions, depending on the value of
     this  variable. Note that not all input variables may be available
     in all cases.

     _Options_:
        - *1*:  The system is 1-dimensional

        - *2*:  The system is 2-dimensional

        - *3*:  The system is 3-dimensional


* Menu:

* Debug::
* IO::
* Parallel::
* Units::


File: octopus.info,  Node: Debug,  Next: IO,  Prev: Generalities,  Up: Generalities

6.1.1 Debug
-----------

   * *DebugLevel*
     _Section_: Generalities::Debug
     _Default_: 1
     This variable decides wether or not to enter debug-mode. In
     debugging mode,  the program prints to standard error when it
     enters and exits the subroutines,  what is the memory it is using
     (only, for the moment being, in Linux systems),  and some other
     information. Useful for developers, and mandatory if you want  to
     send a bug report to the developers and being considered.   You
     have two options: (i) setting it to zero - or less than zero, in
     which  case you do not run in debugging mode (this is the
     default), or (ii) setting  it to a positive number. In this case
     the entries and exits to nested subroutines  are only printed down
     to the level that is given in this variable.

   * *ProfilingMode*
     _Section_: Generalities::Debug
     _Default_: no
     Use this variable to run octopus in profiling mode. In this mode
     octopus records time spent in certain areas of the code and  the
     number of times this code is executed. These numbers  are written
     in './profiling.NNN/profiling.nnn' with nnn being the  node number
     (000 in serial) and NNN the number of processors.   This is mainly
     for development purposes. Note, however, that  octopus should be
     compiled with -disable-debug to do proper  profiling.



File: octopus.info,  Node: IO,  Next: Parallel,  Prev: Debug,  Up: Generalities

6.1.2 IO
--------

   * *FlushMessages*
     _Section_: Generalities::IO
     _Default_: no
     In addition to writing to stdout and stderr, the code messages may
     also be  flushed to "messages.stdout" and "messages.stderr", if
     this variable is  set to yes.

   * *WorkDir*
     _Section_: Generalities::IO
     _Default_: "."
     By default, all files are written and read from the working
     directory,  i.e. the directory from which the executable was
     launched. This behavior can  be changed by setting this variable:
     if you give it a name (other than ".")   the files are written and
     read in that directory.

   * *stderr*
     _Section_: Generalities::IO
     _Default_: "-"
     The standard error by default goes to, well, to standard error.
     This can  be changed by setting this variable: if you give it a
     name (other than "-")  the output stream is printed in that file
     instead.

   * *stdout*
     _Section_: Generalities::IO
     _Default_: "-"
     The standard output by default goes to, well, to standard output.
     This can  be changed by setting this variable: if you give it a
     name (other than "-")  the output stream is printed in that file
     instead.



File: octopus.info,  Node: Parallel,  Next: Units,  Prev: IO,  Up: Generalities

6.1.3 Parallel
--------------

   * *ParallelizationGroupRanks*
     _Section_: Generalities::Parallel
     Specifies the size of the groups used for the parellization. For
     example  (n_d, n_s, n_k) means we have n_p*n_s*n_k processors and
     that the k-points  should be divided in n_k groups, the states in
     n_s groups, and each state  in n_d domains.

   * *ParallelizationStrategy*
     _Section_: Generalities::Parallel
     _Default_: par_domains + par_states + par_kpoints
     Specifies what kind of parallelization strategy octopus should use.
     The values can be combined, for example "par_domains + par_states"
     means a combined paralellization in domains and states

     _Options_:
        - *serial*:  Octopus will run in serial.

        - *par_domains* (1):  Octopus will run parallel in domains.

        - *par_states* (2):  Octopus will run parallel in states.

        - *par_kpoints* (4):  Octopus will run parallel in
          k-points/spin.



File: octopus.info,  Node: Units,  Prev: Parallel,  Up: Generalities

6.1.4 Units
-----------

   * *Units*
     _Section_: Generalities::Units
     _Default_: "a.u"
     Atomic units seem to be the preferred system in the atomic and
     molecular physics community (despite the opinion of some of the
     authors  of this program). Internally, the code works in atomic
     units. However,  for input or output, some people like using eV
     for energies and AA for  lengths. This other system of units can
     also be used.

     _Options_:
        - *"a.u"*:  Atomic units

        - *"eVA"*:  Electron-volts for energy, Angstrom for length.

   * *UnitsInput*
     _Section_: Generalities::Units
     _Default_: "a.u"
     Same as "Units", but only refers to the values in the input files.
     That  is, if UnitsInput = "eVA", all physical values in the input
     files  will be considered to be in eV and Angstroms.

   * *UnitsOutput*
     _Section_: Generalities::Units
     _Default_: "a.u"
     Same as "Units", but only refers to the values in the output
     files.  That  is, if UnitsInput = "eVA", all physical values in
     the output files  will be considered to be in eV and Angstroms.



File: octopus.info,  Node: Hamiltonian,  Next: SCF,  Prev: Generalities,  Up: Input Variables

6.2 Hamiltonian
===============

   * *AtomsMagnetDirection*
     _Section_: Hamiltonian
     This option is only used when GuessMagnetDensity is set to
     user_defined. It provides a direction for each atoms magnetization
     vector when building the guess density. In order to do that the
     user should  specify the coordinates of a vector that has the
     desired direction. The norm  of the vector is ignored. Note that
     it is necessaty to maintain the  ordering in which the species
     were defined in the coordinates specifications.

     For spin-polarized calculations the vectors should have only one
     component and  for non-collinear spin calculations they should
     have three components.

   * *ClassicPotential*
     _Section_: Hamiltonian
     If true, add to the external potential the potential generated by
     the point charges read from the PDB input (see PBDCoordinates).

   * *GuessMagnetDensity*
     _Section_: Hamiltonian
     _Default_: ferromagnetic
     The guess density for the SCF cycle is just the sum of all the
     atomic densities.   When performing spin-polarized or
     non-collinear spin calculations this option sets  the guess
     magnetization density.

     For anti-ferromagnetic configurations the user_defined option
     should be used.

     Note that if the paramagnetic option is used the final
     ground-state will also be  paramagnetic, but the same is not true
     for the other options.

     _Options_:
        - *paramagnetic* (1):  Magnetization density is zero.

        - *ferromagnetic* (2):  Magnetization density is the sum of the
          atomic magnetization densities.

        - *random*:  Each atomic magnetization density is randomly
          rotated.

        - *user_defined*:  The atomic magnetization densities are
          rotated so that the magnetization  vector has the same
          direction as a vector provided by the user. In this case,
          the AtomsMagnetDirection block has to be set.

   * *MultigridLevels*
     _Section_: Hamiltonian
     Number of levels in the grid hierachy used for multigrid.

     _Options_:
        - *max_levels*:  Calculate the optimous number of levels for
          the grid. Positive  numbers indicate an absolute numbers of
          levels, negative  numbers are substracted to maximum number
          of levels posible for  the grid been used. A value of 1 means
          using only the  relaxation operator in the finest grid.
          Default is the maximun  number of levels.

   * *NonInteractingElectrons*
     _Section_: Hamiltonian
     _Default_: no
     Sometimes it may be helpful to treat the electrons as
     non-interacting particles,  i.e., not to take into account Hartree
     and exchange-correlation effects between  the electrons. This
     variable may be used to toogle this behavior on and off

     _Options_:
        - *no*:  Electrons are treated as *interacting* particles

        - *yes* (1):  Electrons are handled as *non-interacting*
          paticles

   * *RelativisticCorrection*
     _Section_: Hamiltonian
     _Default_: non_relativistic
     The default value means that _no_ relativistic correction is used.
     To  include spin-orbit coupling turn RelativisticCorrection to
     spin_orbit  (this will only work when using an executable compiled
     for complex wave-functions,  and if SpinComponents has been set to
     non_collinear, which ensures  the use of spinors).

     _Options_:
        - *non_relativistic*:  No relativistic corrections.

        - *spin_orbit* (1):  Spin-Orbit.

        - *app_zora* (2):  Approximated ZORA (Not implemented)

        - *zora* (3):  ZORA (Not implemented)


* Menu:

* Poisson::
* XC::
* Casida::
* General::
* Curvilinear::
* Derivatives::
* FFTs::
* Simulation Box::


File: octopus.info,  Node: Poisson,  Next: XC,  Prev: Hamiltonian,  Up: Hamiltonian

6.2.1 Poisson
-------------

   * *PoissonSolver*
     _Section_: Hamiltonian::Poisson
     _Default_: fft
     Defines which method to use in order to solve the Poisson equation.
     The default for 1D and 2D is the direct evaluation of the Hartree
     potential.

     _Options_:
        - *direct1D* (-1):  Direct evaluation of the Hartree potential
          (in 1D)

        - *direct2D* (-2):  Direct evaluation of the Hartree potential
          (in 2D)

        - *fft*:  FFTs using spherical cutoff (in 2D or 3D; uses FFTW)

        - *fft_cyl* (1):  FFTs using cylindrical cutoff (in 3D; uses
          FFTW)

        - *fft_pla* (2):  FFTs using planar cutoff (in 3D; uses FFTW)

        - *fft_nocut* (3):  FFTs without using a cutoff (in 3D; uses
          FFTW)

        - *fft_corrected* (4):  FFTs + corrections

        - *cg* (5):  Conjugated gradients

        - *cg_corrected* (6):  Corrected conjugated gradients

        - *multigrid* (7):  Multigrid method

   * *PoissonSolverMaxMultipole*
     _Section_: Hamiltonian::Poisson
     Order of the multipolar expansion for boundary  corrections.
     Default is 4 for cg_corrected and multigrid and 2  for
     fft_corrected.

   * *PoissonSolverThreshold*
     _Section_: Hamiltonian::Poisson
     The tolerance for the poisson solution, used by the cg and
     multigrid solvers. Default is $10^{-5}$.


* Menu:

* Multigrid::


File: octopus.info,  Node: Multigrid,  Prev: Poisson,  Up: Poisson

6.2.1.1 Multigrid
.................

   * *PoissonSolverMGMaxCycles*
     _Section_: Hamiltonian::Poisson::Multigrid
     _Default_: 20
     Maximum number of multigrid cycles that are performed if
     convergence is not achieved

   * *PoissonSolverMGPostsmoothingSteps*
     _Section_: Hamiltonian::Poisson::Multigrid
     _Default_: 3
     Number of gauss-seidel smoothing steps after coarse level
     correction in multigrid Poisson solver

   * *PoissonSolverMGPresmoothingSteps*
     _Section_: Hamiltonian::Poisson::Multigrid
     _Default_: 3
     Number of gauss-seidel smoothing steps before coarse level
     correction in multigrid Poisson solver.

   * *PoissonSolverMGRelaxationMethod*
     _Section_: Hamiltonian::Poisson::Multigrid
     _Default_: Gauss-Seidel
     Method used from fine to relax, i.e. to solve the linear system
     approximately, in  the multigrid procedure that solve Poisson
     equation. For the moment, the option  conjugate gradients is
     experimental. For curvilinear coordinates the default is
     Gauss-Jacobi

     _Options_:
        - *gauss-seidel* (1):  Gauss-Seidel

        - *gauss-jacobi* (2):  Gauss-Jacobi

        - *cg* (5):  Conjugate-gradients

   * *PoissonSolverMGRestrictionMethod*
     _Section_: Hamiltonian::Poisson::Multigrid
     _Default_: fullweight
     Method used from fine to coarse grid transfer

     _Options_:
        - *injection* (1):  Injection

        - *fullweight* (2):  Fullweight restriction



File: octopus.info,  Node: XC,  Next: Casida,  Prev: Poisson,  Up: Hamiltonian

6.2.2 XC
--------

   * *CFunctional*
     _Section_: Hamiltonian::XC
     _Default_: lda_c_pz
     Defines the correlation functional

     _Options_:
        - *gga_c_pbe* (102):  Perdew, Burke & Ernzerhof correlation

        - *lda_c_pw* (10):  LDA: Perdew & Wang

        - *lda_c_ob_pw* (11):  LDA: Ortiz & Ballone (PW-type
          parametrization)

        - *lda_c_lyp* (12):  LDA: Lee, Yang, & Parr LDA

        - *lda_c_amgb* (13):  LDA Attacalite et al functional for the
          2D electron gas

        - *mgga_c_tpss* (202):  MGGA (not working)

        - *lda_c_wigner* (2):  LDA: Wigner parametrization

        - *lda_c_rpa* (3):  LDA: Random Phase Approximation

        - *lda_c_hl* (4):  LDA: Hedin & Lundqvist

        - *lda_c_gl* (5):  LDA: Gunnarson & Lundqvist

        - *lda_c_xalpha* (6):  LDA: Slater's Xalpha

        - *lda_c_vwn* (7):  LDA: Vosko, Wilk, & Nussair

        - *lda_c_pz* (8):  LDA: Perdew & Zunger

        - *lda_c_ob_pz* (9):  LDA: Ortiz & Ballone (PZ-type
          parametrization)

   * *SICorrection*
     _Section_: Hamiltonian::XC
     _Default_: sic_none
     This variable controls which Self Interaction Correction to use.
     Note that  this correction will be applyed to the functional
     chosen by 'XFunctional' and  'CFunctional'

     _Options_:
        - *sic_none* (1):  No Self Interaction Correction

        - *sic_pz* (2):  SIC a Perdew Zunger, hadled by the OEP
          technique

        - *sic_amaldi* (3):  Amaldi correction term (NOT WORKING)

   * *XFunctional*
     _Section_: Hamiltonian::XC
     _Default_: lda_x
     Defines the exchange functional

     _Options_:
        - *lda_x* (1):  LDA

        - *gga_x_pbe*:  GGA: Perdew, Burke & Ernzerhof (GGA)

        - *gga_xc_lb*:  GGA: van Leeuwen & Baerends (GGA)

        - *mgga_x_tpss*:  MGGA (not working)

        - *oep_x*:  OEP: Exact exchange



File: octopus.info,  Node: Casida,  Next: General,  Prev: XC,  Up: Hamiltonian

6.2.3 Casida
------------

   * *LinearResponseKohnShamStates*
     _Section_: Linear Response::Casida
     The calculation of the excitation spectrum of a system in the
     frequency-domain  formulation of linear-response time-dependent
     density functional theory (TDDFT)  implies the use of a basis set
     of occupied/unoccupied Kohn-Sham orbitals. This  basis set should,
     in principle, include all pairs formed by all occupied states,
     and an infinite number of unoccupied states. In practice, one has
     to truncate this  basis set, selecting a number of occupied and
     unoccupied states that will form the  pairs. These states are
     specified with this variable. If there are, say, 10 occupied
     states, and one sets this variable to the value "10-18", this
     means that occupied  states from 10 to 15, and unoccupied states
     from 16 to 18 will be considered.

     This variable is a string in list form, i.e. expressions such as
     "1,2-5,8-15" are  valid. You should include a non-null number of
     unoccupied states and a non-null number  of occupied states.



File: octopus.info,  Node: General,  Next: Curvilinear,  Prev: Casida,  Up: Hamiltonian

6.2.4 General
-------------

   * *ODESolver*
     _Section_: Math::General
     _Default_: ode_rk4
     Specifies what kind of root solver will be used

     _Options_:
        - *ode_rk4* (1):  Standard Runge-Kutta 4th order

        - *ode_fb78* (2):  Fehlberg solver

        - *ode_vr89* (3):  Verner solver

        - *ode_pd89* (4):  Prince-Dormand solver

   * *RootSolver*
     _Section_: Math::General
     _Default_: root_newton
     Specifies what kind of root solver will be used

     _Options_:
        - *root_bisection* (1):  Bisection method

        - *root_brent* (2):  Brent method

        - *root_newton* (3):  Newton method

        - *root_laguerre* (4):  Laguerre method

        - *root_watterstrom* (5):  Watterstrom method

   * *ScalarMeshType*
     _Section_: Math::General
     _Default_: mesh_sinh
     Specifies what kind of scalar mesh will be used

     _Options_:
        - *mesh_linear* (1):  Linear mesh

        - *mesh_double_log* (2):  Logarithmic mesh

        - *mesh_log* (3):  Double logarithmic mesh

        - *mesh_sinh* (4):  Sinh mesh

        - *gauss_legendre* (5):  Gauss-Legendre mesh

   * *SparskitSolver*
     _Section_: Math::General
     _Default_: sk_cg
     Specifies what kind of linear solver will be used

     _Options_:
        - *sk_dqgmres* (10):  Direct versions of Quasi Generalize
          Minimum Residual method

        - *sk_cg* (1):  Conjugate Gradient Method

        - *sk_cgnr* (2):  Conjugate Gradient Method (Normal Residual
          equation)

        - *sk_bcg* (3):  Bi-Conjugate Gradient Method

        - *sk_dbcg* (4):  BCG with partial pivoting

        - *sk_bcgstab* (5):  BCG stabilized

        - *sk_tfqmr* (6):  Transpose-Free Quasi-Minimum Residual method

        - *sk_fom* (7):  Full Orthogonalization Method

        - *sk_gmres* (8):  Generalized Minimum Residual method

        - *sk_fgmres* (9):  Flexible version of Generalized Minimum
          Residual method



File: octopus.info,  Node: Curvilinear,  Next: Derivatives,  Prev: General,  Up: Hamiltonian

6.2.5 Curvilinear
-----------------

   * *CurvMethod*
     _Section_: Mesh::Curvilinear
     _Default_: curv_uniform
     The relevant functions in octopus are represented on a mesh in
     real space.   This mesh may be an evenly spaced regular
     rectangular grid (standard mode),  or else an *adaptive* or
     *curvilinear grid*. We have implemented (not still  finished, this
     is still an experimental feature) three kinds of adative  meshes.

     _Options_:
        - *curv_uniform* (1):  Regular, uniform rectangular grid. The
          default.

        - *curv_gygi* (2):  The deformation of the grid is done
          according to the scheme described by  F. Gygi [F. Gygi and G.
          Galli, Phys. Rev. B 52, R2229 (1995)]

        - *curv_briggs* (3):  The deformation of the grid is done
          according to the scheme described by  Briggs [E.L. Briggs,
          D.J. Sullivan, and J. Bernholc, Phys. Rev. B 54 14362 (1996)]

        - *curv_modine* (4):  The deformation of the grid is done
          according to the scheme described by  Modine [N.A. Modine, G.
          Zumbach and E. Kaxiras, Phys. Rev. B 55, 10289 (1997)]


* Menu:

* Gygi::


File: octopus.info,  Node: Gygi,  Prev: Curvilinear,  Up: Curvilinear

6.2.5.1 Gygi
............

   * *CurvGygiA*
     _Section_: Mesh::Curvilinear::Gygi
     The grid spacing is reduced locally around each atom, and the
     reduction is  given by 1/(1+A), where A is specified by this
     variable, CurvGygiA. So, if  A=1 (the default), the grid spacing
     is reduced to one half = 1/(1+1).   [This is the A_{\alpha}
     variable in Eq. 2 of F. Gygi and G. Galli, Phys.   Rev. B 52,
     R2229 (1995)]  It must be larger than zero.

   * *CurvGygiAlpha*
     _Section_: Mesh::Curvilinear::Gygi
     This number determines the region over which the grid is enhanced
     (range of  enhancement of the resolution). That is, the grid is
     enhanced on a sphere  around each atom, whose radius is given by
     this variable. [This is the a_{\alpha}  variable in Eq. 2 of F.
     Gygi and G. Galli, Phys. Rev. B 52, R2229 (1995)].   The default
     is two atomic units.   It must be larger than zero.

   * *CurvGygiBeta*
     _Section_: Mesh::Curvilinear::Gygi
     This number determines the distance over which Euclidean
     coordinates are  recovered. [This is the b_{\alpha} variable in
     Eq. 2 of F. Gygi and G. Galli,  Phys. Rev. B 52, R2229 (1995)].
     The default is four atomic units.   It must be larger than zero.



File: octopus.info,  Node: Derivatives,  Next: FFTs,  Prev: Curvilinear,  Up: Hamiltonian

6.2.6 Derivatives
-----------------

   * *DerivativesSpace*
     _Section_: Mesh::Derivatives
     _Default_: real_space
     Defines in which space the gradients and the Laplacian are
     calculated.

     _Options_:
        - *real_space*:  Derivatives are calculated in real-space using
          finite differences.

        - *fourier_space* (1):  Derivatives are calculated in
          reciprocal space. Obviously this case implies cyclic boundary
          conditions,  so be careful.

   * *DerivativesStencil*
     _Section_: Mesh::Derivatives
     _Default_: stencil_star
     Decides what kind of stencil is used, i.e. what points, around
     each point in the mesh, are the neighboring points used in the
     expression of the differential operator.

     _Options_:
        - *stencil_star* (1):  A star around each point (i.e., only
          points in the axis).

        - *stencil_variational* (2):  Same as the star, but with
          coefficients built in a different way.

        - *stencil_cube* (3):  A cube of points around each point.

        - *stencil_starplus* (4):  The star, plus a number of off-axis
          points.



File: octopus.info,  Node: FFTs,  Next: Simulation Box,  Prev: Derivatives,  Up: Hamiltonian

6.2.7 FFTs
----------

   * *DoubleFFTParameter*
     _Section_: Mesh::FFTs
     _Default_: 2.0
     For solving Poisson equation in Fourier space, and for applying
     the local potential  in Fourier space, an auxiliary cubic mesh is
     built. This mesh will be larger than  the circumscribed cube to
     the usual mesh by a factor DoubleFFTParameter. See  the section
     that refers to Poisson equation, and to the local potential for
     details  [The default value of two is typically good].

   * *FFTOptimize*
     _Section_: Mesh::FFTs
     _Default_: yes
     Should octopus optimize the FFT dimensions?   This means that the
     cubic mesh to which FFTs are applied is not taken to be as small
     as possible: some points may be added to each direction in order
     to get a "good number"  for the performance of the FFT algorithm.
     In some cases, namely when using  the split-operator, or
     Suzuki-Trotter propagators, this option should be turned off.



File: octopus.info,  Node: Simulation Box,  Prev: FFTs,  Up: Hamiltonian

6.2.8 Simulation Box
--------------------

   * *BoxShape*
     _Section_: Mesh::Simulation Box
     _Default_: minimum
     This variable decides the shape of the simulation box.   Note that
     some incompatibilities apply:
        * Spherical or minimum mesh is not allowed for periodic systems.

        * Cylindrical mesh is not allowed for systems that are periodic
          in more than one dimension.

     _Options_:
        - *sphere* (1):  The simulation box will be a sphere of radius
          Radius

        - *cylinder* (2):  The simulation box will be a cylinder with
          radius Radius and height two times  Xlength

        - *minimum* (3):  The simulation box will be constructed by
          adding spheres created around each  atom (or user defined
          potential), of radius Radius.

        - *parallelepiped* (4):  The simulation box will be a
          parallelpiped whose dimensions are taken from  the variable
          lsize.

   * *Lsize*
     _Section_: Mesh::Simulation Box
     In case BoxShape is "parallelepiped", this is assumed to be a
     block of the form:

     %Lsize
     sizex | sizey | sizez
     %

     where the "size*" are half the lengths of the box in each
     direction.

     If BoxShape is "parallelpiped", this block has to be defined in
     the input file. The  number of columns must match the
     dimensionality of the calculation.

   * *PeriodicDimensions*
     _Section_: Mesh::Simulation Box
     Define which directions are to be considered periodic. Of course,
     it has to be a number  from 0 to three, and it cannot be larger
     than Dimensions.

     _Options_:
        - *0*:  No direction is periodic (molecule)

        - *1*:  The x direction is periodic (wire)

        - *2*:  The x and y directions are periodic (slab)

        - *3*:  The x, y, and z directions are periodic (bulk)

   * *Radius*
     _Section_: Mesh::Simulation Box
     If BoxShape is not "parallelepiped" defines the radius of the
     spheres or of the cylinder.   It has to be a positive number. If
     it is not defined in the input file, then the program  will
     attempt to fine a suitable default, but this is not always
     possible, in which case  the code will stop issuing this error
     message.

   * *Xlength*
     _Section_: Mesh::Simulation Box
     If BoxShape is "cylinder", it is half the total length of the
     cylinder.



File: octopus.info,  Node: SCF,  Next: Spectrum Calculations,  Prev: Hamiltonian,  Up: Input Variables

6.3 SCF
=======

   * *LCAOStart*
     _Section_: SCF
     _Default_: yes
     Before starting a SCF calculation, performs  a LCAO calculation.
     These should provide octopus with a good set  of initial
     wave-functions, and help the convergence of the SCF cycle.   (Up
     to current version, only a minimal basis set used.)

   * *SCFinLCAO*
     _Section_: SCF
     _Default_: no
     Performs all the SCF cycle restricting the calculation to the LCAO
     subspace.   This may be useful for systems with convergence
     problems (first do a  calculation within the LCAO subspace, then
     restart from that point for  an unrestricted calculation).


* Menu:

* Convergence::
* EigenSolver::
* Mixing::


File: octopus.info,  Node: Convergence,  Next: EigenSolver,  Prev: SCF,  Up: SCF

6.3.1 Convergence
-----------------

   * *ConvAbsDens*
     _Section_: SCF::Convergence
     _Default_: 1e-5
     Absolute convergence of the density:  \epsilon = \int {\rm d}^3r
     (\rho^{out}(\bf r) -\rho^{inp}(\bf r))^2.   A zero value means do
     not use this criterion.

   * *ConvAbsEv*
     _Section_: SCF::Convergence
     _Default_: 0.0
     Absolute convergence of the eigenvalues:  \epsilon =
     \sum_{j=1}^{N_{occ}} \vert \epsilon_j^{out}-\epsilon_j^{inp}\vert.
     A zero value means do not use this criterion.

   * *ConvRelDens*
     _Section_: SCF::Convergence
     _Default_: 0.0
     Relative convergence of the density:  \epsilon = {1\over N} \int
     {\rm d}^3r (\rho^{out}(\bf r) -\rho^{inp}(\bf r))^2.   _N_ is the
     total number of electrons in the problem.   A zero value means do
     not use this criterion.

   * *ConvRelEv*
     _Section_: SCF::Convergence
     _Default_: 0.0
     Relative convergence of the eigenvalues:  \epsilon = {1 \over N}
     \sum_{j=1}^{N_{occ}} \vert \epsilon_j^{out}-\epsilon_j^{inp}\vert.
     _N_ is the total number of electrons. A zero value means do not
     use this criterion.

   * *MaximumIter*
     _Section_: SCF::Convergence
     _Default_: 200
     Maximum number of SCF iterations. The code will stop even if
     convergence  has not been achieved. 0 means unlimited.



File: octopus.info,  Node: EigenSolver,  Next: Mixing,  Prev: Convergence,  Up: SCF

6.3.2 EigenSolver
-----------------

   * *EigenSolver*
     _Section_: SCF::EigenSolver
     _Default_: cg
     Decides the eigensolver that obtains the lowest eigenvalues  and
     eigenfunctions of the Kohn-Sham Hamiltonian.

     _Options_:
        - *trlan* (1):  Lanczos scheme, as implemented in the TRLan
          package.

        - *plan* (2):  Preconditioned Lanczos scheme.

        - *arpack* (3):  Implicitly Restarted Arnoldi Method, as
          implemented in the ARPACK package

        - *cg* (5):  Conjugate-gradients algorithm

        - *jdqz* (5):  Jacobi-Davidson scheme as implemented in the
          JDQZ package

        - *cg_new* (6):  A rewritting of the cg option, that will
          eventually substitute it.

        - *evolution* (7):  Propagation in imaginary time

   * *EigenSolverArnoldiVectors*
     _Section_: SCF::EigenSolver
     _Default_: 20
     This indicates how many Arnoldi vectors are generated  It must
     satisfy EigenSolverArnoldiVectors - Number Of Eigenvectors >= 2.
     See the ARPACK documentation for more details.

   * *EigenSolverFinalTolerance*
     _Section_: SCF::EigenSolver
     _Default_: 1.0e-6
     This is the final tolerance for the eigenvectors.

   * *EigenSolverFinalToleranceIteration*
     _Section_: SCF::EigenSolver
     _Default_: 7
     Determines how many interactions are needed  to go from
     EigenSolverInitTolerance to EigenSolverFinalTolerance.

   * *EigenSolverImaginaryTime*
     _Section_: SCF::EigenSolver
     _Default_: 1.0
     The imaginary-time step that is used in the imaginary-time
     evolution  method to obtain the lowest eigenvalues/eigenvectors.
     It must satisfy EigenSolverImaginaryTime > 0.

   * *EigenSolverInitTolerance*
     _Section_: SCF::EigenSolver
     _Default_: 1.0e-6
     This is the initial tolerance for the eigenvectors.

   * *EigenSolverMaxIter*
     _Section_: SCF::EigenSolver
     _Default_: 25
     Determines the maximum number of iterations  for the eigensolver
     (per state) - that is, if this number is reached, the
     diagonalization  is stopped even if the desired tolerance was not
     achieved.



File: octopus.info,  Node: Mixing,  Prev: EigenSolver,  Up: SCF

6.3.3 Mixing
------------

   * *MixNumberSteps*
     _Section_: SCF::Mixing
     _Default_: 3
     In the Broyden and in the GR-Pulay scheme, the new input density
     or potential is constructed  from the values of
     densities/potentials of previous a given number of previous
     iterations.   This number is set by this variable.

   * *Mixing*
     _Section_: SCF::Mixing
     _Default_: 0.3
     Both the linear and the Broyden scheme depend on a "mixing
     parameter", set by this variable.

   * *TypeOfMixing*
     _Section_: SCF::Mixing
     The scheme scheme used to produce, at each iteration in the self
     consistent cycle  that attempts to solve the Kohn-Sham equations,
     the input density from the value  of the input and output
     densities of previous iterations.

     _Options_:
        - *linear*:  Simple linear mixing.

        - *gr_pulay* (1):  "Guaranteed-reduction" Pulay scheme (FIXME:
          Add reference).

        - *broyden* (2):  Broyden scheme (FIXME: Add reference).

   * *What2Mix*
     _Section_: SCF::Mixing
     _Default_: density
     Selects what should be mixed during the SCF cycle.

     _Options_:
        - *density*:  The density

        - *potential* (1):  The Kohn-Sham potential



File: octopus.info,  Node: Spectrum Calculations,  Next: States,  Prev: SCF,  Up: Input Variables

6.4 Spectrum Calculations
=========================

   * *HarmonicSpectrumMode*
     _Section_: Spectrum Calculations
     _Default_: hs_from_dipole
     The oct-harmonic-spectrum may calculate the spectrum in two
     alternative ways,  mathematically equivalent but numerically
     diferent: by reading the dipole  moment (from the multipoles file)
     and calculating the accelaratio numerically  from it, or by
     reading directly the acceleration from the acceleration file,
     which may also be generated during a time-dependent run of octopus.

     _Options_:
        - *hs_from_dipole* (1):  Calculate the harmonic spectrum by
          numerically differentiating the multipoles file.

        - *hs_from_acceleration* (2):  Calculate the harmonic spectrum
          by reading the acceleration file.

   * *HarmonicSpectrumPolarization*
     _Section_: Spectrum Calculations
     _Default_: "z"
     The oct-harmonic-spectrum utility program needs to know the
     direction along  which the emission raidiation is considered to be
     polarized. It may be  linearly polarized or circularly polarized.

     _Options_:
        - *"+"*:  Circularly polarized field, counter clock-wise.

        - *"-"*:  Circularly polarized field, clock-wise.

        - *"x"*:  Linearly polarized field in the x direction.

        - *"y"*:  Linearly polarized field in the y direction.

        - *"z"*:  Linearly polarized field in the z direction.

   * *SpecDampMode*
     _Section_: Spectrum Calculations
     _Default_: polynomial
     Decides which damping/filtering is to be applied in order to
     calculate  spectra by calculating a Fourier transform

     _Options_:
        - *no*:  No filtering at all.

        - *exponential* (1):  Exponential filtering, corresponding with
          a Lorentzian-shaped spectrum

        - *polynomial* (2):  Third-order polynomial damping.

        - *gaussian* (3):  Gaussian damping



File: octopus.info,  Node: States,  Next: System,  Prev: Spectrum Calculations,  Up: Input Variables

6.5 States
==========

   * *ElectronicTemperature*
     _Section_: States
     _Default_: 0.0
     If Occupations is not set, ElectronicTemperature is the
     temperature in the Fermi-Dirac function used to distribute the
     electrons  among the existing states.

   * *ExcessCharge*
     _Section_: States
     _Default_: 0.0
     The net charge of the system. A negative value means that we are
     adding  electrons, while a positive value means we are taking
     electrons  from the system.

   * *ExtraStates*
     _Section_: States
     The number of states is in principle calculated considering the
     minimum  numbers of states necessary to hold the electrons present
     in the system.   The number of electrons is  in turn calculated
     considering the nature of the species supplied in the  Species
     block, and the value of the ExcessCharge variable.   However, one
     may command octopus to put more states, which is necessary if one
     wants to  use fractional occupational numbers, either fixed from
     the origin through  the Occupations block or by prescribing  an
     electronic temperature with ElectronicTemperature.

     Note that this number is unrelated to CalculationMode == unocc.

   * *Occupations*
     _Section_: States
     The occupation numbers of the orbitals can be fixed through the
     use of this  variable. For example:

     %Occupations
     2.0 | 2.0 | 2.0 | 2.0 | 2.0
     %

     would fix the occupations of the five states to _2.0_. There must
     be  as many columns as states in the calculation. If
     SpinComponents == polarized  this block should contain two lines,
     one for each spin channel.   This variable is very useful when
     dealing with highly symmetric small systems  (like an open shell
     atom), for it allows us to fix the occupation numbers  of
     degenerate states in order to help octopus to converge. This is to
     be used in conjuction with ExtraStates. For example, to calculate
     the  carbon atom, one would do:

     ExtraStates = 2
     %Occupations
     2 | 2/3 | 2/3 | 2/3
     %

   * *SpinComponents*
     _Section_: States
     _Default_: unpolarized
     The calculations may be done in three different ways:
     spin-restricted (TD)DFT (i.e., doubly  occupied "closed shells"),
     spin-unsrestricted or "spin-polarized" (TD)DFT (i.e. we have two
     electronic systes, one with spin up and one with spin down), or
     making use of two-component  spinors.

     _Options_:
        - *unpolarized* (1):  Spin-restricted calculations.

        - *spin_polarized* (2):  Spin unrestricted, also know as
          spin-DFT, SDFT. This mode will double the number of wave
          functions will double the number of wave-functions necessary
          for a spin-unpolarised  calculation.

        - *spinors* (3):  The spin-orbitals are two-component spinors.
          This effectively allows the spin-density to  arrange
          non-collinearly - i.e. the magnetization vector is allowed to
          take different  directions in different points.



File: octopus.info,  Node: System,  Next: Time Dependent,  Prev: States,  Up: Input Variables

6.6 System
==========

   * *SystemName*
     _Section_: System
     _Default_: "system"
     A string that identifies the current run. This parameter is
     seldomly used, but  it is sometimes useful to have in the input
     file.


* Menu:

* Coordinates::
* Species::
* Velocities::


File: octopus.info,  Node: Coordinates,  Next: Species,  Prev: System,  Up: System

6.6.1 Coordinates
-----------------

   * *Coordinates*
     _Section_: System::Coordinates
     If neither a "XYZCoordinates" nor a "PDBCoordinates" was found,
     octopus  tries to read the coordinates for the atoms from the
     block "Coordinates". The  format is quite straightforward:

     %Coordinates
     'C' |      -0.56415 | 0.0 | 0.0 | no
     'O' |  0.56415 | 0.0 | 0.0 | no
     %

     The first line defines a Carbon atom at coordinates ("-0.56415",
     "0.0", "0.0"),  that is _not_ allowed to move during dynamical
     simulations. The second line has  a similar meaning. This block
     obviously defines a Carbon monoxide molecule, if the  input units
     are AA. Note that in this way it is possible to fix some of the
     atoms (this  is not possible when specifying the coordinates
     through a "PDBCoordinates" or  "XYZCoordinates" file). It is
     always possible to fix _all_ atoms using the "MoveIons" directive.

   * *PDBCoordinates*
     _Section_: System::Coordinates
     If this variable is present, the program tries to read the atomic
     coordinates  from the file specified by its value. The PDB
     (Protein Data Bank  (http://www.rcsb.org/pdb/)) format is quite
     complicated, and it goes  well beyond the scope of this manual.
     You can find a comprehensive  description in <a
     href='http://www.rcsb.org/pdb/docs/format/pdbguide2.2/guide2.2_frame.html'>here</a>.
     From the plethora of instructions defined in the PDB standard,
     octopus  only reads two, "ATOM" and "HETATOM". From these fields,
     it reads:
        *  columns 13-16: The specie; in fact "octopus" only cares
          about the  first letter - "CA" and "CB" will both refer to
          Carbon - so elements whose  chemical symbol has more than one
          letter can not be represented in this way.   So, if you want
          to run mercury ("Hg") please use one of the other two methods
          to input the coordinates, "XYZCoordinates" or "Coordinates".

        *  columns 18-21: The residue. If residue is "QM", the atom is
          treated in Quantum  Mechanics, otherwise it is simply treated
          as an external classical point charge.   Its charge will be
          given by columns 61-65.

        *  columns 31-54: The Cartesian coordinates. The Fortran format
          is "(3f8.3)".

        *  columns 61-65: Classical charge of the atom. The Fortran
          format is "(f6.2)".

   * *XYZCoordinates*
     _Section_: System::Coordinates
     If "PDBCoordinates" is not present, the program reads the atomic
     coordinates from  the XYZ file specified by the variable
     "XYZCoordinates" - in case this variable  is present. The XYZ
     format is very simple:  The first line of the file has an integer
     indicating the number of atoms. The second can contain comments
     that are simply ignored by  "octopus". Then there follows one line
     per each atom, containing the chemical species and  the Cartesian
     coordinates of the atom.



File: octopus.info,  Node: Species,  Next: Velocities,  Prev: Coordinates,  Up: System

6.6.2 Species
-------------

   * *Species*
     _Section_: System::Species
     A specie is by definition either an "ion" (nucleus + core
     electrons) described  through a pseudo-potential, or an
     user-defined, model potential.   The format of this block is
     different for 1, 2 or 3 dimensions, and  can be best understood
     through examples.

     In 1D, or 2D, e.g.

     %Species
     'H'  | 1.0079 | 1 | "-1/sqrt(x^2 + 1)"
     %

     This defines a species labelled '_H_' of weight _1.0079_,  and
     valence charge 1. This "valence charge" is used to calculate  the
     number of electrons present in the calculation: as many  as
     indicated by the valence charges of the species, plus any extra
     charge  specified by the user. The last field may be  any user
     defined potetial - use _x_, _r_ (and _y_ in the 2D case) for the
     position of the electron relative to the species center.   For
     example, the potential often used in 1D calculation is  the
     soft-Coulomb potential -Z/\sqrt{x^2 + 1}. The previous example
     would then  be an appropriate description of a Hydrogen nucleus
     for one-dimensional calculations.

     In 3D, e.g.

     %Species
     'O'       | 15.9994 | 8   | "tm2"  | 1 | 1
     'H'       |  1.0079 | 1   | "hgh"  | 0 | 0
     'jelli01' | 23.2    | 8.0 |  5.0
     'point01' | 32.3    | 2.0
     'usdef'   | 1       | 8   | "1/2*r^2"
     %

     In this case, we have 5 "species" present, which exemplify the
     five kinds that  may be present:
        *  Oxygen labelled '_O_'. Next number is the atomic mass (in
          atomic  mass units), and third field, the atomic number (8,
          in this case).   Afterwards, "tm2" is the flavour of the
          pseudopotential: "tm2" stands  for Troullier-Martins. This
          means the pseudopotential will be  read from an _O.ascii_ or
          _O.vps_ file, either in the working  directory or in the
          _OCTOPUS-HOME/share/PP/TM2_ directory.   Next two numbers are
          the maximum  _l_-component of the pseudo-potential to
          consider in the  calculation, and the _l_-component to
          consider as local.

        *  Hydrogen defined in the same way as Oxygen. In this case,
          however, the  flavour is "hgh" standing for
          Hartwigsen-Goedecker-Hutter. Last two numbers  are
          irrelevant, since they do are not necessary to define the HGH
          pseudopotentials.

        *  All species whose label starts by 'jelli' are jellium
          spheres.   The other parameters are the weight, the nuclear
          charge, and the  valence charge of the sphere.

        *  All species whose label starts by 'point' are point charges.
          The other parameters are the weight and the nuclear charge.
          In  fact, point charges are implemented as _rather small_
          jellium  spheres, with zero valence charge.

        *  All species whose label starts by 'usdef' are user defined
          potentials. The second parameter is the mass, whereas the
          third parameter  is the 'valence charge', used to calculate
          the number of electrons.   Finally, the potential itself is
          defined by the fourth argument.   Use any of the _x_, _y_,
          _z_ or _r_ variables  to define the potential.

     Note that some common pseudopotentials are distributed with the
     code in the  directory _OCTOPUS-HOME/share/PP/_. To use these
     pseudopotentials you are  not required to define them explicitly
     in the Species block, as defaults  are provided by the program
     (you can override these defaults in any case).   Additional
     pseudopotentials can be downloaded from the  <a
     href='http://www.tddft.org/programs/octopus/pseudo.php'>octopus
     homepage<a>.



File: octopus.info,  Node: Velocities,  Prev: Species,  Up: System

6.6.3 Velocities
----------------

   * *RandomVelocityTemp*
     _Section_: System::Velocities
     If this variable is present, octopus will assign random velocities
     to the atoms  following a Bolzmann distribution with temperature
     given by RandomVelocityTemp.

   * *Velocities*
     _Section_: System::Velocities
     If XYZVelocities is not present, octopus will try to fetch the
     initial  atomic velocities from this block. If this block is not
     present, octopus  will reset the initial velocities to zero. The
     format of this block can be  illustrated by this example:

     %Velocities
     'C'  |      -1.7 | 0.0 | 0.0
     'O'  |  1.7 | 0.0 | 0.0
     %

     It describes one Carbon and one Oxygen moving at the relative
     velocity of 3.4, velocity units.

     Note: It is important for the velocities to maintain the ordering
     in which the species were defined in the coordinates
     specifications.

   * *XYZVelocities*
     _Section_: System::Velocities
     octopus will try to read the starting velocities of the atoms from
     the XYZ file  specified by the variable XYZVelocities.   Note that
     you do not need to specify initial velocities if you are not going
     to perform ion dynamics; if you are going to allow the ions to
     move but the velocities  are not specified, they are considered to
     be null.



File: octopus.info,  Node: Time Dependent,  Next: Unoccupied States,  Prev: System,  Up: Input Variables

6.7 Time Dependent
==================

   * *TDDeltaStrengthMode*
     _Section_: Time Dependent
     _Default_: kick_density
     When calculating the linear response of the density via the
     propagation  in real time, one needs to perfrom an initical kick
     on the KS system, at  time zero. Depending on what kind response
     property one wants to obtain,  this kick may be done in several
     modes.

     _Options_:
        - *kick_density*:  The total density of the system is perturbed.

        - *kick_spin* (1):  The individual spin densities are perturbed
          differently. Note that this mode  is only possible if the run
          is done in spin polarized mode, or with spinors.

        - *kick_spin_and_density* (2):  A combination of the two above.
          Note that this mode  is only possible if the run is done in
          spin polarized mode, or with spinors.

   * *TDExponentialMethod*
     _Section_: Time Dependent
     _Default_: standard
     Method used to numerically calculate the exponential of the
     Hamiltonian,  a core part of the full algorithm used to
     approximate the evolution  operator, specified through the
     variable TDEvolutionMethod.   In the case of using the Magnus
     method, described below, the action of the exponential  of the
     Magnus operator is also calculated through the algorithm specified
     by this variable.

     _Options_:
        - *split*:  It is important to distinguish between applying the
          split operator method  to calculate the exponential of the
          Hamiltonian at a given time - which  is what this variable is
          referring to - from the split operator method  as an
          algorithm to approximate the full evolution operator
          U(t+\delta t, t),  and which will be described below as one
          of the possibilities  of the variable TDEvolutionMethod.
          The equation that describes the split operator scheme is well
          known:

          \exp_{\rm SO} (-i \delta t H) = \exp (-i \delta t/2 V) \exp
          (-i \delta t T) \exp (-i \delta t/2 V).

          Note that this is a "kinetic referenced SO", since the
          kinetic term is sandwiched in the  middle. This is so because
          in octopus, the states spend most of its time in real-space;
          doing  it "potential referenced" would imply 4 FFTs instead
          of 2.   This split-operator technique may be used in
          combination with, for example,  the exponential midpoint rule
          as a means to approximate the evolution operator.   In that
          case, the potential operator _V_ that appears in the equation
          would be  calculated at time t+\delta t/2, that is, in the
          middle of the time-step.   However, note that if the
          split-operator method is invoked as a means to approximate
          the evolution operator (TDEvolutionMethod = 0), a different
          procedure is taken - it  will be described below -, and in
          fact the variable TDExponentialMethod has no  effect at all.

        - *suzuki-trotter* (1):  This is a higher-order SO based
          algorithm. See O. Sugino and Y. Miyamoto,  Phys. Rev. B *59*,
          2579 (1999). Allows for larger time-steps,  but requires five
          times more time than the normal SO.

          The considerations made above for the SO algorithm about the
          distinction  between using the method as a means to
          approximate U(t+\delta t) or as a  means to approximate the
          exponential also apply here. Setting TDEvolutionMethod = 1
          enforces the use of the ST as an algorithm to approximate the
          full evolution operator,  which is slightly different (see
          below).

        - *lanczos* (2):  Allows for larger time-steps.   However, the
          larger the time-step, the longer the computational time per
          time-step.   In certain cases, if the time-step is too large,
          the code will emit a warning  whenever it considers that the
          evolution may not be properly proceeding -  the Lanczos
          process did not converge. The method consists in a Krylov
          subspace approximation of the action of the exponential  (see
          M. Hochbruck and C. Lubich, SIAM J. Numer. Anal. *34*, 1911
          (1997) for details).   Two more variables control the
          performance of the method: the maximum dimension  of this
          subspace (controlled by variable TDExpOrder), and  the
          stopping criterium (controlled by variable TDLanczosTol).
          The smaller the stopping criterium, the more precisely the
          exponential  is calculated, but also the larger the dimension
          of the Arnoldi  subspace. If the maximum dimension allowed by
          TDExpOrder is not  enough to meet the criterium, the
          above-mentioned warning is emitted.

        - *standard* (3):  This method amounts to a straightforward
          application of the definition of  the exponential of an
          operator, in terms of it Taylor expansion.

          \exp_{\rm STD} (-i\delta t H) = \sum_{i=0}^{k} {(-i\delta
          t)^i\over{i!}} H^i.

          The order _k_ is determined by variable _TDExpOder_.   Some
          numerical considerations (by Jeff Giansiracusa and George F.
          Bertsch;  see http://www.phys.washington.edu/~bertsch/num3.ps)
          suggest the 4th order as especially suitable and stable.

        - *chebyshev* (4):  In principle, the Chebyshev expansion  of
          the exponential represents it more accurately than the
          canonical or standard expansion.   As in the latter case,
          TDExpOrder determines the order of the expansion.

          There exists a closed analytical form for the coefficients of
          the exponential in terms  of Chebyshev polynomials:

          \exp_{\rm CHEB} \left( -i\delta t H \right) =
          \sum_{k=0}^{\infty} (2-\delta_{k0})(-i)^{k}J_k(\delta t)
          T_k(H),

          where J_k are the Bessel functions of the first kind, and H
          has te be previously  scaled to [-1,1].   See H. Tal-Ezer and
          R. Kosloff, J. Chem. Phys. *81*,  3967 (1984); R. Kosloff,
          Annu. Rev. Phys. Chem. *45*, 145 (1994);  C. W. Clenshaw,
          MTAC *9*, 118 (1955).

   * *TDLasers*
     _Section_: Time Dependent
     The block TDLasers describe the type and shape of time-dependent
     external perturbations  that are applied to the system.   Each
     line of the block describes a laser field; this way you can
     actually have more  than one laser (e.g. a "pump" and a "probe").
     The syntax of each line is, then:

     %TDLasers
     nx | ny | nz | amplitude | omega | envelope | tau0 | t0 | tau1 |
     filename1 | filename2
     %

     The first three (possibly complex) numbers mark the polarization
     direction of the  field. The "amplitude" is obviously the
     amplitude of the field. The "omega" is the  frequency. The
     "envelope" decides the shape of the enveloping function - see the
     manual for details. "tau0", "t0" and "tau1" are three paramenters
     that decide on the  temporal shape of the pulse - the exact
     details depend on the particular envelope.   If the envelope is
     given in a file, this will be "filename1". If the spatial part  of
     the field is given in a file, this will be "filename2".

     The last three columns ("tau1", "filename1" and "filename2") are
     optional; they will  only be searched if needed.

     In order to give the spatial shape of the field in a file, the
     component "filename2"  has to be present. If it is not present,
     then the laser field will be a dipolar field  (which is the usual
     case).

   * *TDMaximumIter*
     _Section_: Time Dependent
     _Default_: 1500
     Number of time steps in which the total integration time is
     divided;  in previous notation, _N_.

   * *TDTimeStep*
     _Section_: Time Dependent
     _Default_: 0.07 a.u.
     Time-step for the propagation;  in previous notation, \delta t.



File: octopus.info,  Node: Unoccupied States,  Prev: Time Dependent,  Up: Input Variables

6.8 Unoccupied States
=====================

   * *NumberUnoccStates*
     _Section_: Unoccupied States
     _Default_: 5
     How many unoccupied states to compute.

   * *WriteMatrixElements*
     _Section_: Unoccupied States
     _Default_: no
     If true outputs the following matrix elements:
        * <i|T + V_ext|j>

        * <ij| 1/|r1-r2| |kl>

     in the directory ME



File: octopus.info,  Node: Undocumented Variables,  Next: External utilities,  Prev: Input Variables,  Up: Top

7 Undocumented Variables
************************

If you want to use these variables you will have to go to the code to
find out what they do. If you do it, please take the time to write a
short description and send a patch of the manual to us ;) BTW, some of
this variables describe things that may not work, or are under
developments, so don't blame us...
   o   AnimationSampling

   o   AxisType

   o   BoundaryZeroDerivative

   o   CenterOfInversion

   o   CurrentDFT

   o   GuessDensityAtomsMagnet

   o   KineticCutoff

   o   LB94_beta

   o   LB94_modified

   o   LB94_threshold

   o   OEP_level

   o   OEP_mixing

   o   OptControlAlpha

   o   OptControlEps

   o   OptControlInitLaser

   o   OptControlMaxIter

   o   OutputDuringSCF

   o   OutputELF_FS

   o   OutputWfsSqMod

   o   PeriodicDimensions

   o   RestartFileFormat

   o   ShifKPoints

   o   StaticMagneticField

   o   TDDeltaStrengthMode

   o   TDOutputSpin

   o   VlocalCutoff

   o   FromScratch


File: octopus.info,  Node: External utilities,  Next: Examples,  Prev: Undocumented Variables,  Up: Top

8 External utilities
********************

A few small programs are generated along with `octopus', for the
purpose of post-processing the generated information. These utilities
should all be run from the directory where `octopus' was run, so that
it may see the input file, and the directories created by it.

* Menu:

* oct-sf::
* oct-rsf::
* oct-hs-mult::
* oct-hs-acc::
* oct-xyz-anim::
* oct-excite::
* oct-broad::
* oct-make-st::
* oct-center-geom::
* wf.net::


File: octopus.info,  Node: oct-sf,  Next: oct-rsf,  Prev: External utilities,  Up: External utilities

8.1 `oct-sf'
============

This utility generates the dipole strength function of the given system.
Its main input is the `td.general/multipoles' file. Output is written
to a file called `spectrum'. This file is made of two columns: energy
(in eV or a.u., depending on the units specified in the input file),
and dipole strength function (in 1/eV, or 1/a.u., idem).

   In the input file, the user may set the `SpecTransformMode' - this
should be set to "sin" for proper use -, the `SpecDampMode' -
recommended value is "pol", which ensures fulfilling of the N-sum rule,
the `SpecStartTime', the `SpecEndTime', the `SpecEnergyStep', the
`SpecMinEnergy' and the `SpecMaxEnergy'.


File: octopus.info,  Node: oct-rsf,  Next: oct-hs-mult,  Prev: oct-sf,  Up: External utilities

8.2 `oct-rsf'
=============


File: octopus.info,  Node: oct-hs-mult,  Next: oct-hs-acc,  Prev: oct-rsf,  Up: External utilities

8.3 `oct-hs-mult'
=================

Calculates the harmonic spectrum, out of the multipoles file. To do.


File: octopus.info,  Node: oct-hs-acc,  Next: oct-xyz-anim,  Prev: oct-hs-mult,  Up: External utilities

8.4 `oct-hs-acc'
================

Calculates the harmonic spectrum, out of the acceleration file. To do.


File: octopus.info,  Node: oct-xyz-anim,  Next: oct-excite,  Prev: oct-hs-acc,  Up: External utilities

8.5 `oct-xyz-anim'
==================

Reads out the `td.general/coordinates' file, and makes a movie in XYZ
format. To do.


File: octopus.info,  Node: oct-excite,  Next: oct-broad,  Prev: oct-xyz-anim,  Up: External utilities

8.6 `oct-excite'
================

Calculates the excitation spectrum within linear response. This utility
can output just the difference of eigenvalues by setting
`LinEigenvalues', the excitations using M. Petersilka formula
(`LinPetersilka'), or M. Casida (`LinCasida'). This utility requires
that a calculation of unoccupied states (`CalculationMode' = unocc) has
been done before, and it outputs the results to the sub-directory
"linear". The states entering the calculation can be chosen with the
variable `ExciteStates'.


File: octopus.info,  Node: oct-broad,  Next: oct-make-st,  Prev: oct-excite,  Up: External utilities

8.7 `oct-broad'
===============

Generates a spectrum by broadening the excitations obtained by the
`oct-excite' utility. The parameters of the spectrum can be set using
the variables `LinBroadening', `LinMinEnergy', `LinMaxEnergy', and
`LinEnergyStep'.


File: octopus.info,  Node: oct-make-st,  Next: oct-center-geom,  Prev: oct-broad,  Up: External utilities

8.8 `oct-make-st'
=================

`make_st' reads `tmp/restart.static' and replaces some of the Kohn-Sham
states by Gaussians wave packets. The states which should be replaced
are given in the `%MakeStates' section in the input file and written to
`tmp/restart.static.new'. (You probably want to copy that file to
`tmp/restart.static' and use then `CalculationMode=5' or `6'.)

     %MakeStates
       ik | ist | idim | type | sigma | x0 | k
     %

   The first values stand for

   * ik: The k point (or the spin, if `spin-components=2') of the state

   * ist: The state to be replaced

   * idim: The component of the state (if the wave functions have more
     than one component, i.e. when `spin-components=3' is used).

   * The type of the wave packet; currently only `1' (Gaussian) is
     available

   The next items depend on the type chosen.  For a Gaussian wave
packet, defined as

   psi(x) = 1/sigma sqrt(1/2pi) exp(ik(x-x0)) exp(-(x-x0)^2/(2
sigma^2)),

   they are:

   * \sigma the width of the Gaussian

   * k: the *k* vector. In 3D use `k1|k2|k3'.

   * x_0: the coordinate where the Gaussian is initially centred. In 3D
     use `x01|x02|x03'.


File: octopus.info,  Node: oct-center-geom,  Next: wf.net,  Prev: oct-make-st,  Up: External utilities

8.9 `oct-center-geom'
=====================

This utility centers and aligns the coordinates of the molecule. It
reads the file specified in the input file (either by the `Coordinates'
block, or by the `XYZCoordinates' or `PDBCoordinates' variables), and
outputs the adjusted coordinates to the file `adjusted.xyz'. The
following parameters are read from the `inp'ut file:

   * `MainAxis' (block data): A vector of three reals defining the axis
     to which the molecule should be align. If not present, the default
     value will be
              %MainAxis
                1 | 0 | 1
              %

   * `AxisType' (int, inertia): This variable describes how to
     calculate the "main" axis of the molecule. Possible values are:
        - `inertia' or `1': Axis of inertia;

        - `pseudo'  or `2': Axis of inertia calculated as if all atoms
          had mass 1;

        - `large'   or `2': The longest axis of the molecule.



File: octopus.info,  Node: wf.net,  Prev: oct-center-geom,  Up: External utilities

8.10 `wf.net'
=============

This is an OpenDX network, aimed at the visualization of wave-functions.
To be able to use it, you need to have properly installed the OpenDX
program (get it at opendx.org), as well as the Chemistry extensions
obtainable at the Cornell Theory Center
(http://www.tc.cornell.edu/Services/Vis/dx/index.asp).  Once these are
working, you may follow a small tutorial on `wf.net' by following next
steps:

   o Place in a directory the program wf.net, the (needed) auxiliary
     file wf.cfg, and the sample inp file that can all be found in
     `OCTOPUS-HOME'/util.

   o Run `octopus'. The inp file used prescribes the calculation of the
     C atom in its ground state, in spin-polarized mode. It also
     prescribes that the wave-functions should be written in "dx"
     format. At the end, these should be written in subdirectory
     "static": wf-00x-00y-1.dx, where x runs from 1 to 2 (spin quantum
     number) and y runs from 1 to 4 (wave-function index).

   o Run the OpenDX program. Click on "Run Visual Programs" on the DX
     main menu, and select the program `wf.net'. The program will be
     executed, and several windows should open. One of them should be
     called "Application Comment". It contains a small tutorial. Follow
     it from now on.



File: octopus.info,  Node: Examples,  Next: Options Index,  Prev: External utilities,  Up: Top

9 Examples
**********

* Menu:

* Hello world::
* Benzene::


File: octopus.info,  Node: Hello world,  Next: Benzene,  Prev: Examples,  Up: Examples

9.0.1 Hello world
-----------------

As a first example, we will take a sodium atom.  With your favourite
text editor, create the following input "inp".
       SystemName = 'Na'
       CalculationMode = 1
       %Species
         'Na' | 22.989768 | 11 | "tm2" | 0 | 0
       %
       %Coordinates
         'Na' | 0.0 | 0.0 | 0.0 | no
       %
       Radius = 12.0
       Spacing = .6
       TypeOfMixing = 2

   This input file should be essentially self-explanatory.  Note that a
Troullier-Martins pseudopotential file ("Na.vps", or "Na.ascii") should
be accesible to the program. A sample "Na.ascii" may be found in
`OCTOPUS-HOME/share/PP/TM2'. If `octopus' was installed (`make install'
was issued after `make'), there should be no need to do anything - the
program should find it. Otherwise, you may as well place it in the
working directory.  Then run `octopus' - for example, do `octopus > out
', so that the output is stored in "out" file. If everything goes OK,
"out" should look like (1):
                         Running octopus, version 1.1
                  (build time - Fri Mar 14 14:23:49 CET 2003)

     Info: Calculation started on 2003/03/17 at 03:49:56
     Info: Reading pseudopotential from file:
           '/home/marques/share/octopus/PP/TM2/Na.ascii'
           Calculating atomic pseudo-eigenfunctions for specie Na....
           Done.
     Info: l =  0 component used as local potential
       Type = sphere           Radius [b] =  12.000
       Spacing [b] = ( 0.600, 0.600, 0.600)    volume/point [b^3] =  0.21600
       # inner mesh =  33401   # outer mesh =  18896
     Info: Derivatives calculated in real-space
     Info: Local Potential in Reciprocal Space.
     Info: FFTs used in a double box (for poisson | local potential)
           box size = (  81,  81,  81)
           alpha =      2.00000
     Info: Using FFTs to solve poisson equation with spherical cutoff.
     Info: Exchange and correlation
           Exchange    family    : LDA
                       functional: non-relativistic
           Correlation family    : LDA
                       functional: Perdew-Zunger
     Info: Allocating rpsi.
     Info: Random generating starting wavefunctions.
     Info: Unnormalized total charge =      0.998807
     Info: Renormalized total charge =      1.000000
     Info: Setting up Hamiltonian.
     Info: Performing LCAO calculation.
     Info: LCAO basis dimension:      1
           (not considering spin or k-points)
     Eigenvalues [H]
        #   Eigenvalue    Occupation      Error (1)
        1    -0.102098       1.000000
     Info: SCF using real wavefunctions.
     Info: Broyden mixing used. It can (i) boost your convergence,
           (ii) do nothing special, or (iii) totally screw up the run.
           Good luck!
     Info: Converged =     0
     Eigenvalues [H]
        #   Eigenvalue    Occupation      Error (1)
        1    -0.102975       1.000000      (2.8E-02)
     Info: iter =    1 abs_dens = 0.53E-03 abs_ener = 0.60E+00

     Info: Converged =     0
     Eigenvalues [H]
        #   Eigenvalue    Occupation      Error (1)
        1    -0.102477       1.000000      (1.4E-03)
     Info: iter =    2 abs_dens = 0.43E-03 abs_ener = 0.65E-05

     Info: Converged =     1
     Eigenvalues [H]
        #   Eigenvalue    Occupation      Error (1)
        1    -0.102419       1.000000      (5.1E-04)
     Info: iter =    3 abs_dens = 0.39E-04 abs_ener = 0.20E-06

     Info: Converged =     1
     Eigenvalues [H]
        #   Eigenvalue    Occupation      Error (1)
        1    -0.102436       1.000000      (8.5E-05)
     Info: iter =    4 abs_dens = 0.24E-04 abs_ener = 0.52E-08

     Info: Converged =     1
     Eigenvalues [H]
        #   Eigenvalue    Occupation      Error (1)
        1    -0.102437       1.000000      (1.5E-06)
     Info: iter =    5 abs_dens = 0.14E-05 abs_ener = 0.36E-10

     Info: SCF converged in    5 iterations
     Info: Deallocating rpsi.
     Info: Calculation ended on 2003/03/17 at 03:50:04
   Take now a look at the working directory. It should include the
following files:
     -rw-rw-r--    1 user  group       177 Jul 10 12:29 inp
     -rw-rw-r--    1 user  group      4186 Jul 10 12:35 out
     -rw-rw-r--    1 user  group      1626 Jul 10 12:35 out.oct
     drwxrwxr-x    2 user  group      4096 Jul 10 12:35 static
     drwxrwxr-x    2 user  group      4096 Jul 10 12:35 tmp

   Besides the initial file (`inp') and the `out' file, two new
directories appear. In `static', you will find the file `info', with
information about the static calculation (it should be hopefully
self-explanatory, otherwise please complain to the authors).  In `tmp',
you will find the `restart.static', a binary file containg restart
information about the ground-state, which is used if, for example, you
want to start a time-dependent calculation afterwards.  Finally, you
can safely ignore `out.oct': it is an output from the liboct library,
irrelevant for what concerns physics ;).

   *Exercises*:
   * Study how the total energy and eigenvalue of the sodium atom
     improve   with the mesh spacing.

   * Calculate the static polarizability of the sodium atom
     (`CalculationMode = 7').    Two new files will be generated:
     `restart.pol' that can be used to resume   the polarizability
     calculation, and `Na.pol' that contains the static polarizability
     tensor. Note that this calculation overwrites
     `tmp/restart.static', so that   what now is there is the ground
     state for the system _with_ an external static   electrical field
     applied. Delete it since it is useless.

   * Calculate a few unoccupied states (`CalculationMode = 3'). The
     eigenspectrum   will be in the file `eigenvalues'. Why don't we
     find a Rydberg series in the   eigenspectrum?

   * Repeat the previous calculation with PBE, LB94, and exact exchange.
      Don't forget to *move* the file `tmp/restart.static' when
     switching   between exchange-correlation functionals.

   * Perform a time-dependent evolution (`CalculationMode = 5'), to
     calculate   the optical spectrum of the Na atom. Use a
     `TDDeltaStrength = 0.05', polarised   in the `x' direction. The
     multipole moments of the density are output to   the file
     `td.general/multipoles'. You can process this file with the utility
      `strength-function' to obtain the optical spectrum.    If you
     have computer time to waste, re-run the time-dependent
     simulation for some other xc choices.


   ---------- Footnotes ----------

   (1) Before this output, a beautiful octopus ascii-art picture may be
printed...


File: octopus.info,  Node: Benzene,  Prev: Hello world,  Up: Examples

9.0.2 Benzene
-------------

Well, the sodium atom is a bit too trivial. Let's try something harder:
benzene.  you will just need the geometry for benzene to be able to
play. Here it is (in AA):
      C  0.000  1.396  0.000
      C  1.209  0.698  0.000
      C  1.209 -0.698  0.000
      C  0.000 -1.396  0.000
      C -1.209 -0.698  0.000
      C -1.209  0.698  0.000
      H  0.000  2.479  0.000
      H  2.147  1.240  0.000
      H  2.147 -1.240  0.000
      H  0.000 -2.479  0.000
      H -2.147 -1.240  0.000
      H -2.147  1.240  0.000

   Follow now the steps of the previous example. Carbon and Hydrogen
have a much harder pseudo-potential than Sodium, so you will probably
have to use a tighter mesh. It also takes much more time...


File: octopus.info,  Node: Options Index,  Prev: Examples,  Up: Top

Options Index
*************

 [index ]
* Menu:

* AtomsMagnetDirection
:                 Hamiltonian.                                (line   7)
* AxisType:                              oct-center-geom.     (line  19)
* BoxShape
:                             Simulation Box.                 (line   7)
* CalculationMode
:                      Generalities.                          (line   7)
* CFunctional
:                          XC.                                (line   7)
* ClassicPotential
:                     Hamiltonian.                            (line  21)
* ConvAbsDens
:                          Convergence.                       (line   7)
* ConvAbsEv
:                            Convergence.                     (line  14)
* ConvRelDens
:                          Convergence.                       (line  21)
* ConvRelEv
:                            Convergence.                     (line  29)
* Coordinates
:                          Coordinates.                       (line   7)
* CurvGygiA
:                            Gygi.                            (line   7)
* CurvGygiAlpha
:                        Gygi.                                (line  16)
* CurvGygiBeta
:                         Gygi.                               (line  25)
* CurvMethod
:                           Curvilinear.                      (line   7)
* DebugLevel
:                           Debug.                            (line   7)
* DerivativesSpace
:                     Derivatives.                            (line   7)
* DerivativesStencil
:                   Derivatives.                              (line  21)
* Dimensions
:                           Generalities.                     (line  38)
* DoubleFFTParameter
:                   FFTs.                                     (line   7)
* EigenSolver
:                          EigenSolver.                       (line   7)
* EigenSolverArnoldiVectors
:            EigenSolver.                                     (line  32)
* EigenSolverFinalTolerance
:            EigenSolver.                                     (line  39)
* EigenSolverFinalToleranceIteration
:   EigenSolver.                                              (line  44)
* EigenSolverImaginaryTime
:             EigenSolver.                                    (line  50)
* EigenSolverInitTolerance
:             EigenSolver.                                    (line  57)
* EigenSolverMaxIter
:                   EigenSolver.                              (line  62)
* ElectronicTemperature
:                States.                                      (line   7)
* ExcessCharge
:                         States.                             (line  14)
* ExtraStates
:                          States.                            (line  21)
* FFTOptimize
:                          FFTs.                              (line  17)
* FlushMessages
:                        IO.                                  (line   7)
* GuessMagnetDensity
:                   Hamiltonian.                              (line  26)
* HarmonicSpectrumMode
:                 Spectrum Calculations.                      (line   7)
* HarmonicSpectrumPolarization
:         Spectrum Calculations.                              (line  24)
* LCAOStart
:                            SCF.                             (line   7)
* LinearResponseKohnShamStates
:         Casida.                                             (line   7)
* Lsize
:                                Simulation Box.              (line  32)
* MainAxis:                              oct-center-geom.     (line  12)
* MakeStates:                            oct-make-st.         (line  12)
* MaximumIter
:                          Convergence.                       (line  37)
* Mixing
:                               Mixing.                       (line  15)
* MixNumberSteps
:                       Mixing.                               (line   7)
* MultigridLevels
:                      Hamiltonian.                           (line  55)
* NonInteractingElectrons
:              Hamiltonian.                                   (line  67)
* NumberUnoccStates
:                    Unoccupied States.                       (line   7)
* Occupations
:                          States.                            (line  35)
* ODESolver
:                            General.                         (line   7)
* ParallelizationGroupRanks
:            Parallel.                                        (line   7)
* ParallelizationStrategy
:              Parallel.                                      (line  14)
* PDBCoordinates
:                       Coordinates.                          (line  27)
* PeriodicDimensions
:                   Simulation Box.                           (line  48)
* PoissonSolver
:                        Poisson.                             (line   7)
* PoissonSolverMaxMultipole
:            Poisson.                                         (line  39)
* PoissonSolverMGMaxCycles
:             Multigrid.                                      (line   7)
* PoissonSolverMGPostsmoothingSteps
:    Multigrid.                                               (line  13)
* PoissonSolverMGPresmoothingSteps
:     Multigrid.                                              (line  19)
* PoissonSolverMGRelaxationMethod
:      Multigrid.                                             (line  25)
* PoissonSolverMGRestrictionMethod
:     Multigrid.                                              (line  41)
* PoissonSolverThreshold
:               Poisson.                                      (line  45)
* ProfilingMode
:                        Debug.                               (line  22)
* Radius
:                               Simulation Box.               (line  63)
* RandomVelocityTemp
:                   Velocities.                               (line   7)
* RelativisticCorrection
:               Hamiltonian.                                  (line  81)
* RootSolver
:                           General.                          (line  21)
* ScalarMeshType
:                       General.                              (line  37)
* SCFinLCAO
:                            SCF.                             (line  15)
* SICorrection
:                         XC.                                 (line  44)
* SparskitSolver
:                       General.                              (line  53)
* SpecDampMode
:                         Spectrum Calculations.              (line  42)
* Species
:                              Species.                       (line   7)
* SpinComponents
:                       States.                               (line  59)
* stderr
:                               IO.                           (line  23)
* stdout
:                               IO.                           (line  31)
* SystemName
:                           System.                           (line   7)
* TDDeltaStrengthMode
:                  Time Dependent.                            (line   7)
* TDExponentialMethod
:                  Time Dependent.                            (line  27)
* TDLasers
:                             Time Dependent.                 (line 128)
* TDMaximumIter
:                        Time Dependent.                      (line 159)
* TDTimeStep
:                           Time Dependent.                   (line 165)
* TypeOfMixing
:                         Mixing.                             (line  21)
* Units
:                                Units.                       (line   7)
* UnitsInput
:                           Units.                            (line  22)
* UnitsOutput
:                          Units.                             (line  29)
* Velocities
:                           Velocities.                       (line  13)
* What2Mix
:                             Mixing.                         (line  36)
* WorkDir
:                              IO.                            (line  14)
* WriteMatrixElements
:                  Unoccupied States.                         (line  12)
* XFunctional
:                          XC.                                (line  59)
* Xlength
:                              Simulation Box.                (line  72)
* XYZCoordinates
:                       Coordinates.                          (line  56)
* XYZVelocities
:                        Velocities.                          (line  32)



Tag Table:
Node: Top667
Node: Authors2851
Node: Copying6232
Node: Installation7712
Node: Quick instructions8701
Node: Long instructions9236
Ref: Long instructions-Footnote-118869
Ref: Long instructions-Footnote-219427
Node: Different octopus executables19639
Node: Troubleshooting21441
Node: The parser23387
Node: Description26654
Node: Mesh26937
Node: Run Mode SCF27317
Node: Run Mode Unoccupied States28370
Node: Run Mode Time Dependent29063
Node: Function output for visualization33034
Node: Spectrum calculations34185
Node: Input Variables34681
Node: Generalities35147
Node: Debug36603
Node: IO38087
Node: Parallel39394
Node: Units40461
Node: Hamiltonian41674
Node: Poisson45587
Node: Multigrid47077
Node: XC48633
Node: Casida50607
Node: General51797
Node: Curvilinear53859
Node: Gygi55134
Node: Derivatives56476
Node: FFTs57727
Node: Simulation Box58806
Node: SCF61296
Node: Convergence62118
Node: EigenSolver63556
Node: Mixing65795
Node: Spectrum Calculations67114
Node: States69157
Node: System72337
Node: Coordinates72723
Node: Species75826
Node: Velocities79714
Node: Time Dependent81155
Node: Unoccupied States89354
Node: Undocumented Variables89831
Node: External utilities90936
Node: oct-sf91511
Node: oct-rsf92295
Node: oct-hs-mult92422
Node: oct-hs-acc92631
Node: oct-xyz-anim92845
Node: oct-excite93076
Node: oct-broad93709
Node: oct-make-st94068
Node: oct-center-geom95348
Node: wf.net96394
Node: Examples97775
Node: Hello world97934
Ref: Hello world-Footnote-1104557
Node: Benzene104641
Node: Options Index105458

End Tag Table
