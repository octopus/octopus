This is octopus-devel.info, produced by makeinfo version 4.7 from
octopus-devel.texi.

   This manual is for octopus 1.99devel, a first principles, electronic
structure, excited states, time-dependent density functional theory
program.

   Copyright (C) 2002, 2003, 2004 Miguel A. L. Marques, Alberto Castro
and Angel Rubio

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.1 or any later version published by the Free Software
     Foundation.

INFO-DIR-SECTION Individual utilities
START-INFO-DIR-ENTRY
* octopus: (octopus).           The octopus program.
END-INFO-DIR-ENTRY


File: octopus-devel.info,  Node: Top,  Next: Authors,  Prev: (dir),  Up: (dir)

octopus
*******

This manual is for octopus 1.99devel, a first principles, electronic
structure, excited states, time-dependent density functional theory
program.

   Copyright (C) 2002, 2003, 2004 Miguel A. L. Marques, Alberto Castro
and Angel Rubio

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.1 or any later version published by the Free Software
     Foundation.

* Menu:

* Authors::
* Copying::
* Introduction::
* xc::
* xc_functl::
* lib_xc::

 --- The Detailed Node Listing ---

`xc'

* type xc_type::
* subroutine xc_init::
* subroutine xc_write_info::
* subroutine xc_end::
* subroutine xc_get_vxc::
* OEP levels::

`xc_functl'

* type xc_functl_type::
* subroutine xc_functl_init_exchange::
* subroutine xc_functl_init_correlation::
* subroutine xc_functl_write_info::
* subroutine xc_functl_end::

`lib_xc'

* subroutine xc_lda_init::
* subroutine xc_lda::
* subroutine xc_lda_end::
* subroutine xc_gga_init::
* subroutine xc_gga::
* subroutine xc_gga_lb::
* subroutine xc_mgga_init::
* subroutine xc_mgga::
* subroutine xc_mgga_end::
* LDA functionals::
* GGA functionals::
* MGGA functionals::


File: octopus-devel.info,  Node: Authors,  Next: Copying,  Prev: Top,  Up: Top

Authors and collaborators
*************************

The main developing team of this program is composed of:

   * Miguel A. L. Marques (Donostia International Physics Center, San
     Sebastia'n, Espan~a)

   * Angel Rubio, (Donostia International Physics Center and Department
     of Materials Science UPV/EHU, San Sebastia'n, Espan~a), and

   * Alberto Castro, (alberto.castro@tddft.org, Theoretische Physik,
     Freie Universita"t Berlin, Berlin 14195, Deutschland).

   Other contributors are:
   * Micael Oliveira: mixing, and a lot of stuff.

   * Carlo Andrea Rozzi - infinite systems (almost done!)

   * Sebastien Hamel    - paralel version of oct-excite.



File: octopus-devel.info,  Node: Copying,  Next: Introduction,  Prev: Authors,  Up: Top

The `octopus'  Copying Conditions
*********************************

This program is "free"; this means that everyone is free to use it and
free to redistribute it on a free basis.  What is not allowed is to try
to prevent others from further sharing any version of this program that
they might get from you.

   Specifically, we want to make sure that you have the right to give
away copies of the program, that you receive source code or else can
get it if you want it, that you can change this program or use pieces
of them in new free programs, and that you know you can do these things.

   To make sure that everyone has such rights, we have to forbid you to
deprive anyone else of these rights.  For example, if you distribute
copies of the program, you must give the recipients all the rights that
you have.  You must make sure that they, too, receive or can get the
source code.  And you must tell them their rights.

   Also, for our own protection, we must make certain that everyone
finds out that there is no warranty for this program.  If these
programs are modified by someone else and passed on, we want their
recipients to know that what they have is not what we distributed, so
that any problems introduced by others will not reflect on our
reputation.

   The precise conditions of the license are found in the General Public
Licenses that accompany it.


File: octopus-devel.info,  Node: Introduction,  Next: xc,  Prev: Copying,  Up: Top

1 Introduction
**************

[Note to info readers: The preferred way to read this manual is in its
pdf or dvi versions, since there are quite a few equations that will
not print out well in info format. However, we have tried to make the
info format readable. For this purpose, we have chosen the following
convention: instead of removing the equations in the info files, they
will show up as the TeX commands that produce them in the printed
documentation]


File: octopus-devel.info,  Node: xc,  Next: xc_functl,  Prev: Introduction,  Up: Top

2 `xc'
******

The module `xc' takes care of _most_ of the problem of calculating the
exchange and correlation potential and energy functionals.
Unfortunately, it cannot handle all the problem, as it would be
desirable, because the OEP functionals have to be handled within the
`hamiltonian' module (to obtain an OEP functional one needs to apply
the Hamiltonian). Since Fortran 90 is unable of handling circular
dependencies, the obtention of OEP functionals (or the obtention of the
SIC through the OEP method) is done in the `h_xc_oep' subroutine in the
`hamiltonian' module. We can consider `h_xc_oep' to be within the `xc'
module _in spirit_.

   Note that `octopus'  does not distinguish, for the moment, between
ground-state DFT xc functionals, and time-dependent DFT functionals. In
other words, in all cases the _adiabatic_ approximation is assumed. In
mathematical terms, we may formalize this in the following way: let n
be the time-dependent density, a function living in the
four-dimensional space-time world.  We will call n_t(\vecr) = n(\vecr,
t), the electronic density at time t, a function in the
three-dimensional space.  An exchange and/or correlation _energy_
functional E^\alpha in ground state DFT may then be used to build an
_adiabatic_ exchange and/or correlation action functional in the
following way:
a
 The time-dependent potential functional is then:
a
 We use the distinct notation v^\alpha[n](\vecr,t) and v^\alpha \rm
(GS)[n_t](\vecr) to stress that the exchange and correlation potential
in TDDFT - the former - and the exchange and correlation potential in
GS-DFT - the latter - are in principle two conceptually different
objects, which coincide only thanks to the adiabatic approximation.
This is the reason why we may actually only refer to the functionals in
the GS-DFT context.

   We may classify the xc functionals contained in the `octopus'  code
following John Perdew's Jacob's Ladder scheme:

  1. LDA rung: A functional \alpha belonging to the LDA rung depends
     only on the electronic density (on the spin density in
     spin-polarized or spinors cases). Moreover, it has a _local_
     dependency on the density, i.e.:
     a

     The potential may be then derived by functional derivation:
     a

  2. GGA rung: A functional \alpha belonging to the GGA rung depends on
     the electronic density, and also on its gradient. Moreover, it
     also has a _local_ dependency (yes, the GGA is also a local
     functional in this sense).
     a

  3. mGGA rung:

  4. OEP rung: This is the family of functionals which are defined in
     terms of the occupied Kohn-Sham orbitals, \lbrace \varphi_i
     \rbrace_i=1^N.  These are in fact the only _non-local_
     functionals. The name of the rung, OEP, stands for
     "optimized-effective-potential", the reason being that in general
     this is the method used to derive the potential from the energy
     functional (direct functional derivation is in this case not
     possible). A more suitable name would be orbital-dependent
     functionals.


* Menu:

* type xc_type::
* subroutine xc_init::
* subroutine xc_write_info::
* subroutine xc_end::
* subroutine xc_get_vxc::
* OEP levels::


File: octopus-devel.info,  Node: type xc_type,  Next: subroutine xc_init,  Prev: xc,  Up: xc

2.1 `type xc_type'
==================


type(xc_functl_type) :: functl(2)
integer              :: sic_correction
type(xc_functl_type) :: sic_aux(2)
integer              :: mGGA_implementation
integer              :: oep_level
FLOAT                :: oep_mixing
logical              :: nlcc

This data type holds all the necessary information to fully
characterize the exchange and correlation functional used in an
`octopus' calculation. Its componets are the following:

   * `functl(2)': The first element of this two-element array is the
     `xc_functl_type' structure that holds the information about the
     exchange functional; the second element holds the correlation
     functional.

   * `sic_correction' determines wether self-interaction corrections
     (SIC) are to be applied or not. It only holds if any of the
     `functl' components is holding a functional of the `XC_FAMILY_LDA'
     or `XC_FAMILY_GGA' families (see *Note type xc_functl_type::).

     The possible values are: 0 (do not apply SIC corrections), or
     anything else (do apply SIC corrections).

   * `sic_aux(2)': These are two `xc_functl_type' structures, which
     hold auxiliary exchange and correlation functionals, necessary to
     builid the SIC. [WARNING: I believe that this could be avouided]

   * `mGGA_implementation': The mGGA functional is in fact an orbital
     dependent functional. It may then also use the OEP formalism. The
     precise way in which the mGGA functional is implemented is then
     decided by this variable, which my take two values:

        * `mGGA_implementation = 1': GEA-like implementation.

        * `mGGA_implementation = 2': OEP-like implementation (not yet
          implemented).

   * `oep_level': The optimized effective potential method is applied in
     three cases: (i) in case a SIC is applied to a LDA or GGA
     functional; (ii) in case the exact exchange functional is
     requested; and (iii) in case the mGGA is to be implemented through
     the OEP (`mGGA_implementation = 2'). However, several possible
     choices are then possible to approximate (or calculate exactly)
     the OEP.  The options - the values that the integer `oep_level'
     may take - are listed in *Note OEP levels::.

   * `oep_mixing'

   * `nlcc'



File: octopus-devel.info,  Node: subroutine xc_init,  Next: subroutine xc_write_info,  Prev: type xc_type,  Up: xc

2.2 `subroutine xc_init'
========================


type(xc_type), intent(out) :: xcs
logical,       intent(in)  :: nlcc
integer,       intent(in)  :: spin_channels

This subroutine initializes a `xc_type' variable, the `xcs' argument,
maiinly by reading in variables from the input file. Two input
arguments need, however, to be passed in:

   * `nlcc', used to fill in `xc_type%nlcc' (see *Note type xc_type::).

   * `spin_channels', which is needed to call `xc_functl_init_exchange'
     and `xc_functl_init_correlation' (see `xc_functl'). It should be
     equal to one if the calculations are unpolarized, and equal to two
     if the calculations are spin-polarized, or based in two-spinors.


   This routine is in charge of calling `xc_functl_init_exchange' (see
*Note subroutine xc_functl_init_exchange::) and
`xc_functl_init_correlation' (see *Note subroutine
xc_functl_init_correlation::).

   It also reads some extra variables, from the input file:
   * `MGGAimplementation' : it is used to fill
     `xcs%mGGA_implementation'.

   * `SICCorrection': used to fill `xcs%sic_correction'.

   * `OEP_level': used to fill `xcs%oep_level'.

   * `OEP_mixing': used to fill `xcs%oep_mixing'.


File: octopus-devel.info,  Node: subroutine xc_write_info,  Next: subroutine xc_end,  Prev: subroutine xc_init,  Up: xc

2.3 `subroutine xc_write_info'
==============================


type(xc_type), intent(in) :: xcs
integer,       intent(in) :: iunit


File: octopus-devel.info,  Node: subroutine xc_end,  Next: subroutine xc_get_vxc,  Prev: subroutine xc_write_info,  Up: xc

2.4 `subroutine xc_end'
=======================


type(xc_type), intent(inout) :: xcs


File: octopus-devel.info,  Node: subroutine xc_get_vxc,  Next: OEP levels,  Prev: subroutine xc_end,  Up: xc

2.5 `subroutine xc_get_vxc'
===========================


type(xc_type),        intent(in)    :: xcs
type(mesh_type),      intent(in)    :: m
type(f_der_type),     intent(inout) :: f_der
type(states_type),    intent(in)    :: st
FLOAT,                intent(inout) :: vxc(:,:), ex, ec
FLOAT,                intent(in)    :: ip, qtot
[logical, optional,    intent(in)    :: aux]

This routine fills the exchange and correlation potential `vxc' (as
well as the exchange and correlation energies, `ex' and `ec'.  It takes
care of the "simple" functionals, i.e. LDA, GGA and mGGA; The SIC
corrections to these functionals or the exact exchange OEP is handled
in the `h_xc_OEP' subroutine, which should be called afte calling
`xc_get_vxc'.

   The input variables are:

   * `xcs': This is the `xc_type' variable that holds all the
     information about the exchange and correlation functional. It
     should have been initialized previously by the `xc_init'
     subroutine.

   * `m': The mesh where all the system functions live.

   * `f_der': This is the `f_der_type' structure: the structure that
     knows how to do the derivatives. It is defined `inout' for
     technical reasons, but it should not change.

   * `st': The `states_type' structure that holds the density and the
     Kohn-Sham states.

   * `ip': The ionization potential of the system, or some reasonable
     estimation for it, necessary only in case the van Leeuween &
     Baerends potential is to be used.

   * `qtot': The total electron number of the system, also only
     necessary in case the van Leeuween & Baerends potential is to be
     used.

   * `aux': This is an optional flag:
        * If it is passed, and it is set to `.true.', the exchange and
          correlation functional used will be those held in
          `xcs%sic_aux'. This is done in order to calculate the
          self-interaction corrections.

        * Otherwise, they will be those held in `xcs%functl'.

   * `vxc', `ex', `ec': the values of these three variables on entry.
     is added to the calculated values.

   The output variables are:
   * `ex': The exchange energy.

   * `ec': The correlation energy.

   * `vxc(:, :)': The dimension of this array are `(m%np, st%d%nspin)'.
     On output, it holds the exchange and correlation potential - added
     to whatever it held before.


File: octopus-devel.info,  Node: OEP levels,  Prev: subroutine xc_get_vxc,  Up: xc

2.6 OEP levels
==============

   * `XC_OEP_NONE = 0'

   * `XC_OEP_SLATER = 1'

   * `XC_OEP_KLI = 2'

   * `XC_OEP_CEDA = 3'

   * `XC_OEP_FULL = 4'


File: octopus-devel.info,  Node: xc_functl,  Next: lib_xc,  Prev: xc,  Up: Top

3 `xc_functl'
*************

* Menu:

* type xc_functl_type::
* subroutine xc_functl_init_exchange::
* subroutine xc_functl_init_correlation::
* subroutine xc_functl_write_info::
* subroutine xc_functl_end::


File: octopus-devel.info,  Node: type xc_functl_type,  Next: subroutine xc_functl_init_exchange,  Prev: xc_functl,  Up: xc_functl

3.1 `xc_functl_type'
====================


integer :: family
integer :: id
integer :: spin_channels
integer(POINTER_SIZE) :: conf
integer(POINTER_SIZE) :: info

The integer `family' may take one of the four following families:
   * `XC_FAMILY_LDA  = 1' => For LDA functionals.

   * `XC_FAMILY_GGA  = 2' => For GGA functionals.

   * `XC_FAMILY_MGGA = 3' => For MGGA functionals.

   * `XC_FAMILY_OEP  = 4' => For OEP functionals (i.e. orbital
     dependent functionals).

   This value is set in either the `xc_functl_init_exchange' and
`xc_functl_init_correlation', depending on the functional requested,
read from the input file, and which in turns sets the `id' integer
identifier.

   The integer `id' is the identifier for the functional(1). It may
take the following values:

   * For exchange funcionals:

        * Within the `XC_FAMILY_LDA' family, any of the exchange
          functionals listed in *Note LDA functionals::. In fact, only
          one: `XC_LDA_X'.

        * Within the `XC_FAMILY_GGA' family, any of the exchange
          functionals listed in *Note GGA functionals::.

        * Within the `XC_FAMILY_MGGA' family, any of the exchange
          functionals listed in *Note MGGA functionals::. In fact, only
          one: `XC_MGGA_X_TPSS'.

        * Within the `XC_FAMILY_OEP' family, it may `XC_OEP_X = 301',
          corresponding to the exact-exchange functional.

   * For correlation functionals:

        * Within the `XC_FAMILY_LDA' family, any of the correlation
          functionals listed in *Note LDA functionals::.

        * Within the `XC_FAMILY_GGA' family, any of the correlation
          functionals listed in *Note GGA functionals::.

        * Within the `XC_FAMILY_MGGA' family, any of the correlation
          functionals listed in *Note MGGA functionals::. In fact, only
          one: `XC_MGGA_C_TPSS'.

        * Within the `XC_FAMILY_OEP' family, there is none.


   The `spin_channels' integer may be one, in case the calculation is of
spin-unpolarized type (i.e. restricted to paired electrons in closed
shells), or two, in case the calculation is spin-polarized, or it is a
two-spinors like calculation.

   The `integer(POINTER_SIZE)' `conf' and `info' are the pointers needed
to use the subroutines in the `lib_xc' module (see *Note lib_xc::).

   ---------- Footnotes ----------

   (1) Note that it does not fully identify the exchange and
correlation functional - SIC corrections can be added to, for example,
one LDA functional. This possibility is handled in the `xc' module


File: octopus-devel.info,  Node: subroutine xc_functl_init_exchange,  Next: subroutine xc_functl_init_correlation,  Prev: type xc_functl_type,  Up: xc_functl

3.2 `subroutine xc_functl_init_exchange'
========================================


type(xc_functl_type), intent(out) :: functl
integer,              intent(in)  :: spin_channels

This subroutine initializes one `xc_functl_type' structure (argument
`functl'), so that it holds information about one exchange functional.
Its only input is `spin_channels' - which is used to fill in
`functl%spin_channels', whereas the rest of the needed information is
obtained through the input file.

   The input file variable `XFunctional' is read, and used to fill in
`functl%id'. According to its value `functl%family' is then set by the
code.  The values given in the input file for `XFunctional' must then
be any of the accepted values for `functl%id' - in the exchange case.
Some mnemonic variables are provided in the `SHARE/octopus/variables'
directory.

   Besides filling the `xc_functl_type' structure `functl', the main
task of this subroutine is to call either `xc_lda_init', `xc_gga_init'
or `xc_mgga_init' in module `lib_xc' (see *Note lib_xc::).


File: octopus-devel.info,  Node: subroutine xc_functl_init_correlation,  Next: subroutine xc_functl_write_info,  Prev: subroutine xc_functl_init_exchange,  Up: xc_functl

3.3 `subroutine xc_functl_init_correlation'
===========================================


type(xc_functl_type), intent(out) :: functl
integer,              intent(in)  :: spin_channels

This subroutine initializes one `xc_functl_type' structure (argument
`functl'), so that it holds information about one correlation
functional. Its only input is `spin_channels' - which is used to fill
in `functl%spin_channels', whereas the rest of the needed information
is obtained through the input file.

   The input file variable `CFunctional' is read, and used to fill in
`functl%id'. According to its value `functl%family' is then set by the
code.  The values given in the input file for `CFunctional' must then
be any of the accepted values for `functl%id' - in the correlation case.
Some mnemonic variables are provided in the `SHARE/octopus/variables'
directory.

   Besides filling the `xc_functl_type' structure `functl', the main
task of this subroutine is to call either `xc_lda_init', `xc_gga_init'
or `xc_mgga_init' in module `lib_xc' (see *Note lib_xc::).


File: octopus-devel.info,  Node: subroutine xc_functl_write_info,  Next: subroutine xc_functl_end,  Prev: subroutine xc_functl_init_correlation,  Up: xc_functl

3.4 subroutine xc_functl_write_info
===================================


type(xc_functl_type), intent(in) :: functl
integer,              intent(in) :: iunit

It outputs to the file opened in unit `iunit' information about the
functional initialized in `functl'.


File: octopus-devel.info,  Node: subroutine xc_functl_end,  Prev: subroutine xc_functl_write_info,  Up: xc_functl

3.5 `subroutine xc_functl_end'
==============================


type(xc_functl_type), intent(inout) :: functl

This subroutine does the necessary cleaning of a `xc_fucntl_type'
variable that is not going to be used any more.


File: octopus-devel.info,  Node: lib_xc,  Prev: xc_functl,  Up: Top

4 `lib_xc'
**********

This module is in charge of providing the _simple_ functionals, i.e. the
LDA, GGA and mGGA functionals. It is in fact nothing else than an
interface to the `libxc.a' C library.

   The LDA, GGA and mGGA functionals defined here are `local' (yes, the
GGA and MGGA are also local), in the sense that the value of the
potential at a given point depends only on the values of the density -
and the gradient of the density and the kinetic energy density, for the
GGA and mGGA cases - at a given point:


v^{\rm LDA}_{\rm xc}(\vec{r}) = v^{\rm LDA}_{\rm xc}[n(\vec{r})]\,,

v^{\rm GGA}_{\rm xc}(\vec{r}) = v^{\rm GGA}_{\rm xc}[n(\vec{r}), \vec{\nabla}n(\vec{r})]\,,

v^{\rm mGGA}_{\rm xc}(\vec{r}) = v^{\rm mGGA}_{\rm xc}[n(\vec{r}), \vec{\nabla}n(\vec{r}), \tau(\vec{r})]\,.

   Note that these functionals are not the only ones used by the
`octopus'  code - there is also the possibility of employing
self-interaction corrections, optimized effective potential methods,
etc.  To make use of them, the `hamiltonian' module makes also use of
the `xc_functl' and `xc' modules.

   The usage of this module is as follows: first, one must initialize a
`POINTER_SIZE' integer trough either the `xc_lda_init', `xc_gga_init'
or the `xc_mgga_init' subroutines (see below). This is a pointer to the
a correspondig C data structure.  Once initialized, one may retrieve
the values of the functional through the `xc_lda', `xc_gga' or the
`xc_mgga' subroutines. Cleaning up is finally done through the
`xc_lda_end', `xc_gga_end' and `xc_mgga' end subroutines.

   One may also retrieve information about each functional with the the
set of `xc_info' subroutines.

* Menu:

* subroutine xc_lda_init::
* subroutine xc_lda::
* subroutine xc_lda_end::
* subroutine xc_gga_init::
* subroutine xc_gga::
* subroutine xc_gga_lb::
* subroutine xc_mgga_init::
* subroutine xc_mgga::
* subroutine xc_mgga_end::
* LDA functionals::
* GGA functionals::
* MGGA functionals::


File: octopus-devel.info,  Node: subroutine xc_lda_init,  Next: subroutine xc_lda,  Prev: lib_xc,  Up: lib_xc

4.1 `subroutine xc_lda_init'
============================


integer(POINTER_SIZE), intent(out) :: p
integer(POINTER_SIZE), intent(out) :: info
integer,               intent(in)  :: functional
integer,               intent(in)  :: nspin
[integer,               intent(in)  :: dim]
[integer,               intent(in)  :: rel]
[FLOAT,                 intent(in)  :: alpha]

It initializes the `p' handler to hold the LDA functional determined by
`functional', which may be one of the LDA constants (see *Note LDA
functionals::).  The `info' pointer may then be used to retrieve
infomation about the functional. `nspin' may be one or two, depending
on wether we want spin-unpolarized or spin-polarized results,
respectively.

   In the case of the exchange functional (`p = XC_LDA_X'), one must
supply the argument `dim', specifying the dimensionality of the problem
(two or three), and also the `rel' flag, which may be
`XC_NON_RELATIVISTIC = 0' or `XC_RELATIVISTIC =  1'.

   In the case of the X\alpha functional (p = `XC_LDA_C_XALPHA)'), one
must supply `dim', `rel' and the defining constant `alpha'.


File: octopus-devel.info,  Node: subroutine xc_lda,  Next: subroutine xc_lda_end,  Prev: subroutine xc_lda_init,  Up: lib_xc

4.2 `subroutine xc_lda'
=======================


integer(POINTER_SIZE), intent(in)  :: p
FLOAT,                 intent(in)  :: rho
FLOAT,                 intent(out) :: e
FLOAT,                 intent(out) :: v

It retrieves the LDA exchange or correlation energy and potential.  The
specific functional is determined by the handler `p', which should have
been initialized before. The energy and potential are placed into `e'
and `v', respectively, whereas `rho' is the input density. Both `rho'
and `v' may be the first element of two-sized arrays, if the functional
has been defined to be spin-polarized.


File: octopus-devel.info,  Node: subroutine xc_lda_end,  Next: subroutine xc_gga_init,  Prev: subroutine xc_lda,  Up: lib_xc

4.3 subroutine `xc_lda_end'
===========================


integer(POINTER_SIZE), intent(inout) :: p

It finalizes the LDA handler `p'.


File: octopus-devel.info,  Node: subroutine xc_gga_init,  Next: subroutine xc_gga,  Prev: subroutine xc_lda_end,  Up: lib_xc

4.4 `subroutine xc_gga_init'
============================


integer(POINTER_SIZE), intent(out) :: p
integer(POINTER_SIZE), intent(out) :: info
integer,               intent(in)  :: functional
integer,               intent(in)  :: nspin
[integer,               intent(in)  :: modified]
[FLOAT,                 intent(in)  :: threshold]


File: octopus-devel.info,  Node: subroutine xc_gga,  Next: subroutine xc_gga_lb,  Prev: subroutine xc_gga_init,  Up: lib_xc

4.5 `subroutine xc_gga'
=======================


integer(POINTER_SIZE), intent(in)  :: p
FLOAT,                 intent(in)  :: rho
FLOAT,                 intent(in)  :: grho
FLOAT,                 intent(out) :: e
FLOAT,                 intent(out) :: dedd
FLOAT,                 intent(out) :: dedgd


File: octopus-devel.info,  Node: subroutine xc_gga_lb,  Next: subroutine xc_mgga_init,  Prev: subroutine xc_gga,  Up: lib_xc

4.6 `subroutine xc_gga_lb'
==========================


integer(POINTER_SIZE), intent(in)  :: p
FLOAT,                 intent(in)  :: rho
FLOAT,                 intent(in)  :: grho
FLOAT,                 intent(in)  :: r
FLOAT,                 intent(in)  :: ip
FLOAT,                 intent(in)  :: qtot
FLOAT,                 intent(out) :: dedd


File: octopus-devel.info,  Node: subroutine xc_mgga_init,  Next: subroutine xc_mgga,  Prev: subroutine xc_gga_lb,  Up: lib_xc

4.7 `subroutine xc_mgga_init'
=============================


integer(POINTER_SIZE), intent(out) :: p
integer(POINTER_SIZE), intent(out) :: info
integer,               intent(in)  :: functional
integer,               intent(in)  :: nspin

It initializes the `p' handler to hold one of the MGGA functionals,
which are:
   * XC_MGGA_X_TPSS = 201 => Perdew, Tao, Staroverov & Scuseria exchange

   * XC_MGGA_C_TPSS = 202 => Perdew, Tao, Staroverov & Scuseria
     correlation
   One of these constants, depending on wether we need the exchange or
the correlation, has to be passed in `functional' variable.  The `info'
pointer may then be used to retrieve infomation about the functional.
`nspin' may be one or two, depending on wether we want spin-unpolarized
or spin-polarized results, respectively.


File: octopus-devel.info,  Node: subroutine xc_mgga,  Next: subroutine xc_mgga_end,  Prev: subroutine xc_mgga_init,  Up: lib_xc

4.8 `subroutine xc_mgga'
========================


integer(POINTER_SIZE), intent(in)  :: p
FLOAT,                 intent(in)  :: rho
FLOAT,                 intent(in)  :: grho
FLOAT,                 intent(in)  :: tau
FLOAT,                 intent(out) :: e
FLOAT,                 intent(out) :: dedd
FLOAT,                 intent(out) :: dedgd
FLOAT,                 intent(out) :: dedtau


File: octopus-devel.info,  Node: subroutine xc_mgga_end,  Next: LDA functionals,  Prev: subroutine xc_mgga,  Up: lib_xc

4.9 `subroutine xc_mgga_end'
============================


integer(POINTER_SIZE), intent(inout) :: p


File: octopus-devel.info,  Node: LDA functionals,  Next: GGA functionals,  Prev: subroutine xc_mgga_end,  Up: lib_xc

4.10 LDA functionals
====================

Exchange:
   * XC_LDA_X =  1 => LDA exchange.

Correlation:
   * XC_LDA_C_WIGNER =  2 => Wigner parametrization

   * XC_LDA_C_RPA    =  3 => Random Phase Approximation

   * XC_LDA_C_HL     =  4 => Hedin & Lundqvist

   * XC_LDA_C_GL     =  5 => Gunnarson & Lundqvist

   * XC_LDA_C_XALPHA =  6 => Slaters Xalpha

   * XC_LDA_C_VWN    =  7 => Vosko, Wilk, & Nussair

   * XC_LDA_C_PZ     =  8 => Perdew & Zunger

   * XC_LDA_C_OB_PZ  =  9 => Ortiz & Ballone (PZ)

   * XC_LDA_C_PW     = 10 => Perdew & Wang

   * XC_LDA_C_OB_PW  = 11 => Ortiz & Ballone (PW)

   * XC_LDA_C_LYP    = 12 => Lee, Yang, & Parr LDA

   * XC_LDA_C_AMGB   = 13 => Attacalite et al


File: octopus-devel.info,  Node: GGA functionals,  Next: MGGA functionals,  Prev: LDA functionals,  Up: lib_xc

4.11 GGA functionals
====================

Exchange:
   * XC_GGA_X_PBE = 101 => Perdew, Burke & Ernzerhof exchange

   * XC_GGA_XC_LB = 103 => van Leeuwen & Baerends

Correlation:
   * XC_GGA_C_PBE = 102 => Perdew, Burke & Ernzerhof correlation


File: octopus-devel.info,  Node: MGGA functionals,  Prev: GGA functionals,  Up: lib_xc

4.12 MGGA functionals
=====================

Exchange:
   * XC_MGGA_X_TPSS = 201 => Perdew, Tao, Staroverov & Scuseria exchange

Correlation:
   * XC_MGGA_C_TPSS = 202 => Perdew, Tao, Staroverov & Scuseria
     correlation



Tag Table:
Node: Top679
Node: Authors1976
Node: Copying2730
Node: Introduction4195
Node: xc4743
Node: type xc_type8029
Node: subroutine xc_init10407
Node: subroutine xc_write_info11726
Node: subroutine xc_end11982
Node: subroutine xc_get_vxc12195
Node: OEP levels14662
Node: xc_functl14900
Node: type xc_functl_type15191
Ref: type xc_functl_type-Footnote-117674
Node: subroutine xc_functl_init_exchange17874
Node: subroutine xc_functl_init_correlation19083
Node: subroutine xc_functl_write_info20316
Node: subroutine xc_functl_end20744
Node: lib_xc21087
Node: subroutine xc_lda_init23125
Node: subroutine xc_lda24341
Node: subroutine xc_lda_end25078
Node: subroutine xc_gga_init25342
Node: subroutine xc_gga25806
Node: subroutine xc_gga_lb26236
Node: subroutine xc_mgga_init26713
Node: subroutine xc_mgga27642
Node: subroutine xc_mgga_end28165
Node: LDA functionals28391
Node: GGA functionals29213
Node: MGGA functionals29573

End Tag Table
