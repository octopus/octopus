This is octopus.info, produced by makeinfo version 4.5 from
octopus.texi.

INFO-DIR-SECTION Individual utilities
START-INFO-DIR-ENTRY
* octopus: (octopus).           The octopus program.
END-INFO-DIR-ENTRY

This manual is for octopus 1.1, a first principles, electronic
structure, excited states, time-dependent density functional theory
program.

   Copyright (C) 2002, 2003 Miguel A. L. Marques, Alberto Castro and
Angel Rubio

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.1 or any later version published by the Free Software
     Foundation.
   

File: octopus.info,  Node: Top,  Next: Copying,  Prev: (dir),  Up: (dir)

octopus
*******

This manual is for octopus 1.1, a first principles, electronic
structure, excited states, time-dependent density functional theory
program.

   Copyright (C) 2002, 2003 Miguel A. L. Marques, Alberto Castro and
Angel Rubio

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.1 or any later version published by the Free Software
     Foundation.
   
* Menu:

* Copying::
* Authors::
* Introduction::
* Installation::
* The input file::
* External utilities::
* Examples::
* Options Index::

 --- The Detailed Node Listing ---

Introduction

* Description of octopus::
* Time dependent density functional theory::

Installation

* Quick instructions::
* Long instructions::
* Troubleshooting::

Description of input options

* The parser::
* Input file options::

Input file options

* Generalities::
* Species::
* Coordinates::
* Velocities::
* Mesh::
* States::
* Hamiltonian::
* Exchange and correlation::
* SCF::
* Unoccupied States::
* Time Dependent::
* Photo-electron spectrum::
* Geometry optimization::
* Function output for visualization::
* Spectrum calculations::
* Varia::

External utilities

* strength-function::
* hs-from-mult::
* hs-from-acc::
* nbo2xyz::
* excitations::
* broad::
* make_st::
* choose_st::
* wf.net::

Examples

* Hello world::
* Benzene::


File: octopus.info,  Node: Copying,  Next: Authors,  Prev: Top,  Up: Top

Copying
*******

   This program is "free"; this means that everyone is free to use it
and free to redistribute it on a free basis.  What is not allowed is to
try to prevent others from further sharing any version of this program
that they might get from you.

   Specifically, we want to make sure that you have the right to give
away copies of the program, that you receive source code or else can
get it if you want it, that you can change this program or use pieces
of them in new free programs, and that you know you can do these things.

   To make sure that everyone has such rights, we have to forbid you to
deprive anyone else of these rights.  For example, if you distribute
copies of the program, you must give the recipients all the rights that
you have.  You must make sure that they, too, receive or can get the
source code.  And you must tell them their rights.

   Also, for our own protection, we must make certain that everyone
finds out that there is no warranty for this program.  If these
programs are modified by someone else and passed on, we want their
recipients to know that what they have is not what we distributed, so
that any problems introduced by others will not reflect on our
reputation.

   The precise conditions of the license are found in the General Public
Licenses that accompany it.


File: octopus.info,  Node: Authors,  Next: Introduction,  Prev: Copying,  Up: Top

Authors, Collaborators and Acknowledgements.
********************************************

   The main developing team of this program is composed of Miguel A. L.
Marques and Angel Rubio, working at the Donostia International Physics
Center and Department of Materials Science UPV/EHU (San Sebastian,
Espan~a), and Alberto Castro, who works at the University of
Valladolid, Departamento de Fi'sica Teo'rica (Valladolid, Espan~a).

   `octopus' is based on a fixed-nucleus code written by George F.
Bertsch and K. Yabana to perform real-time dynamics in clusters (Phys
Rev B *54*, 4484 (1996)) and on a condensed matter real-space
plane-wave based code written by A. Rubio, X. Blase and S.G. Louie
(Phys. Rev. Lett. *77*, 247 (1996)).  The code was afterwards extended
to handle periodic systems by G.F. Bertsch, J.I. Iwata, A. Rubio, and
K. Yabana (Phys. Rev. B, *62*, 7998 (2000)). Contemporaneously there was
a major rewrite of the original cluster code to handle a vast majority
of finite systems. At this point the cluster code was named "tddft".

   This version was consequently enhanced and beautified by A. Castro
(at the time Ph.D. student of A. Rubio), originating a fairly verbose
15,000 lines of Fortran 90/77. In the year 2000, M. Marques (aka
Hyllios, aka Anto'nio de Faria, corsa'rio portugue^s), joined the A.
Rubio group in Valladolid as a postdoc. Having to use "tddft" for his
work, and being petulant enough to think he could structure the code
better than his predecessors, he started a major rewrite of the code
together with A. Castro, finishing version 0.2 of "tddft." But things
were still not perfect: due to their limited experience in Fortran 90,
and due to the inadequacy of this language for anything beyond a HELLO
WORLD program, several parts of the code were still clumsy. Also the
idea of GPLing the almost 20,000 lines arose during an alcoholic
evening. So after several weeks of fantic coding and after getting rid
of the Numerical Recipes code that still lingered around, `octopus' was
born.

   The present released version has been completely rewritten and keeps
very little relation to the old version (even input and output files)
and has been enhanced with major new flags to perform various
excited-state dynamics in finite and extended systems (one-dimensional
periodic chains). The code will be updated frequently and new versions
can be found here (http://www.tddft.org/programs/octopus).

   The main features of the present version are described in detail in
_octopus: a first principles tool for excited states electron-ion
dynamics_, Comp. Phys. Comm. *151*, 60 (2003).  Updated references as
well as results obtained with octopus will be posted regularly to the
`octopus' web page. If you find the code useful for you research we
would appreciate if you give reference to this work and previous ones.

   If you have some free time, and if you feel like taking a joy ride
with Fortran 90, just drop us an email <octopus@tddft.org>. You can
also send us patches, comments, ideas, wishes, etc. They will be
included in new releases of octopus.


File: octopus.info,  Node: Introduction,  Next: Installation,  Prev: Authors,  Up: Top

Introduction
************

* Menu:

* Description of octopus::
* Time dependent density functional theory::


File: octopus.info,  Node: Description of octopus,  Next: Time dependent density functional theory,  Prev: Introduction,  Up: Introduction

Description of `octopus'
========================

   `octopus' (1) is a program aimed at the ab initio virtual
experimentation on electron/ion dynamics in external electromagnetic
fields of arbitrary intensity, shape and frequency in a hopefully ever
increasing range of systems types. Its main characteristics are:

   * Electrons are described quantum-mechanically within the
     Density-Functional Theory (DFT) for the ground-state whereas the
     excitation spectra is computed using time-dependent form (TDDFT)
     by performing simulations in time.

   * The electron-nucleus interaction is described within the
     pseudo-potential approximation. Nuclei are described classically
     as point particles.

   * Wave-functions are expanded in a real-space grid. The kinetic
     energy operator is computed with a high-order finite difference
     method.  FFTs are used in part of the calculations.  Time and grid
     spacing are related by imposing a stable time-evolution.

   * Forces on the ions are computed through the Ehrenfest theorem.
     Extension to quantum mechanical nuclear dynamics is in progress.

   * Allows for spin-polarised calculations as well as non-collinear
     magnetism and spin-orbit effects.

   * Computes photo-electron (energy and angle resolved) and
     photo-absorption spectra for different polarised external
     electromagnetic fields. Linear response calculations are a simple
     case of this general time-evolution procedure (see below).

   * Includes non-linear electronic effects: high-harmonic generation,
     interaction with a laser pulse of arbitrary intensity. For the
     time being only time- and spatially-dependent electric fields are
     included, in the future magnetic fields will be incorporated.

   * Reads different geometry files including protein-data-base (PDB)
     for biological calculations (interaction of biomolecules with
     electromagnetic fields).

   * It allows for one and two dimesional modes by using for example
     the soft-coulomb potential or any other given as input.

   * Laser-pulse optimisation using genetic algorithms (to be done).

   * Utilities to analyse the computed spectra.

   * A very effective and easy-to-use parser to handle the input file.


   ---------- Footnotes ----------

   (1) _octopus_: Etymology: New Latin _Octopod-_, _Octopus_, from
Greek _oktOpous_.  Any of a genus (_Octopus_) of cephalopod mollusks
that have eight muscular arms equipped with two rows of suckers;
broadly, any octopod excepting the paper nautilus.  Something that
resembles an octopus especially in having many centrally directed
branches.  (Taken from the Merryam-Webster's dictionary.)


File: octopus.info,  Node: Time dependent density functional theory,  Prev: Description of octopus,  Up: Introduction

Time dependent density functional theory
========================================

   Several reviews of time-dependent density function theory (TDDFT)
and its applications have appeared recently, like the works by Gross et
al. (1), Casida (2), Dobson et al, (3) , and Burke et al (4).

   The Hohenberg-Kohn-Sham theory as described is a ground state
theory, and it is hence not meant for the calculation of electronic
excitations.  However, one can extend the ideas of static DFT. When one
asks for the evolution of the system under the influence of a
time-dependent external potential, one should search the extrema of the
quantum mechanical action

   A = \int_t0^t1 dt  <\psi(t) | i\partial_t -H(t) | \psi>

   Theorems have now been established for time-dependent DFT(5) which
are parallel to those of static DFT.  The first theorem proves a
one-to-one mapping between time-dependent potentials and time-dependent
densities; the second proves the stationary-action principle.

   The proof of the first theorem is based directly on the evolution of
the time-dependent Schro"dinger equation from a fixed initial
many-particle state \Psi(t_0)=\Psi_0 under the influence of a
time-dependent potential v(t) required to be expandable in a Taylor
series around t_0.  The initial state \Psi_0 does not need to be the
ground state or some other eigenstate of the initial potential.  As one
does not rely on the adiabatic connection as in standard
zero-temperature many-body perturbation theory the formalism is able to
handle external perturbations varying fast in time. By virtue of the
first theorem, the time-dependent density determines the external
potential uniquely up to an additive purely time-dependent function.
On the other hand, the potential determines the time-dependent
wave-function, therefore the expectation value of any quantum
mechanical operator is a unique functional of the density.

   The second theorem deals with the variational principle of the action
functional with the initial condition \Psi(t_0)=\Psi_0.  From the
previous one-to-one mapping between time-dependent potentials and
densities, the action is a functional of the density that must have a
stationary point at the correct time-dependent density.  Thus the Euler
equation corresponding to the extrema of A[\rho],

   \delta A[\rho] / \delta \rho(r) = 0,

   determines the time-dependent density, just as in the Hohenberg-Kohn
formalism the static ground state density is given by the minimum of
the total energy (\delta E[\rho]/\delta \rho(\bf r,t)=0).

   Similarly, one can define a time-dependent Kohn-Sham (KS) scheme by
introducing a non-interacting system that reproduces the exact
interacting density \rho(\bf r,t).  One gets the following
time-dependent KS-equations:

   ( 1/2 \nabla^2 + V_eff(r,t) ) \psi_i(r,t)  = i \partial_t \psi_i(r,t)

   \rho(r,t) = V_H(r,t) = \sum_i=1^N |\psi_i(r,t)|^2

   where

   V_eff(r,t) = V_H(r,t) + V_xc(r,t) + V_ext(r,t)

   is the effective time-dependent potential felt by the electrons. It
consists of the sum of the external time-dependent applied field, the
time-dependent Hartree term, plus the  xc potential (defined through
the equivalence between the interacting and fictitious non-interacting
systems). The variational principle yields

   V_xc(r,t) = \delta A_xc[\rho] / \delta \rho(r,t).

   where A_\rm xc[\rho] is the xc part of the action functional.

   The main advantage of the time-dependent KS scheme lies in its
computational simplicity compared to other quantum-chemical models such
as time-dependent Hartree-Fock or configuration interaction.

   ---------- Footnotes ----------

   (1)   Gross, E.K.U., C.A. Ullricht and U.J. Grossmann, 1994, in
_Density Functional Theory_, (NATOP ASI Series), p.194;   Gross,
E.K.U., F. J. Dobson, and M. Petersilka, 1996,   _Density Functional
Theory_ (Springer, New York).

   (2)   Casida, M.E., 1995, in _Recent Advances in Density Functional
Methods_,   Part I, ed. D.P. Chong (World Scientific, Singapore), p.155;
 Casida, M.E., 1996, in _Recent Developments and Applications of Modern
 Density Functional Theory_, ed. J.M. Seminario (Elsevier Science,
Amsterdam), p.391

   (3)   Dobson, J , G. Vignale and M.P. Das (Eds), 1997a,
_Electronic Density Functional Theory: Recent Progress and New
Directions_   (Plenum, New York)

   (4)   Burke, K., M. Petersilka and E.K.U. Gross, 2001, in   _Recent
Advances in Density Functional Methods_, edited by P.    Fantucci and
A. Bencini (World Scientific, Singapure).

   (5)   Runge, E. and E. K. U. Gross, 1984, Phys. Rev. Lett.    *52*
997.


File: octopus.info,  Node: Installation,  Next: The input file,  Prev: Introduction,  Up: Top

Installation
************

* Menu:

* Quick instructions::
* Long instructions::
* Troubleshooting::


File: octopus.info,  Node: Quick instructions,  Next: Long instructions,  Prev: Installation,  Up: Installation

Quick instructions
==================

   For the inpatients, here goes the quick-start:
     prompt> gzip -cd octopus<-version>.tar.gz | tar xvf -
     prompt> cd octopus-<version>
     prompt> ./configure
     prompt> make
     prompt> make install

   This will probably *not* work, so before giving up, just read the
following paragraphs.

   Also, rpm and deb binaries for linux are supplied on the web-page.


File: octopus.info,  Node: Long instructions,  Next: Troubleshooting,  Prev: Quick instructions,  Up: Installation

Long instructions
=================

   The code is written in standard Fortran 90, with some routines
written in C (and in bison, if we count the input parser). To build it
you will need both a C compiler (`gcc' works just fine), and a Fortran
90 compiler. No free-software Fortran 90 compiler is available yet, so,
if you want to chew the `octopus', you will have either to help the g95
(http://g95.sourceforge.net) project or use any of the available
comercial compilers.

   Besides the compiler, you will also need:
  1. `make':  most computers have it installed, otherwise just grab the
     GNU `make' and install it.

  2. `cpp': The C preprocessor is heavily used in `octopus'.  GNU `cpp'
     is just fine, but any `cpp' that accepts the `-C' flag (preserve
     comments) should work just as well.

  3. FFTW: Just grab this great library from here (http://www.fftw.org/)

  4. LAPACK/BLAS: Not heavily used, but required. If you are running
     Linux, there is a fair chance they are already installed in your
     system. The same goes to the more heavyweight machines (alphas,
     IBMs, SGIs, etc.). Otherwise, just grab the source from here
     (http://www.netlib.org).

  5. GSL: Finally that someone had the nice idea of making a public
     scientific library! GSL still needs to grow, but it is already
     quite useful and impressive.  `octopus' uses splines, complex
     numbers, special functions, etc. from GSL, so it is a must! If you
     don't have it already installed in your system, you can obtain GSL
     from here (http://sources.redhat.com/gsl/). You will need version
     1.0 or higher.

  6. MPI: If you want to run `octopus' in multi-tentacle (parallel)
     mode, you will need an implementation of MPI.  `mpich'
     (http://www-unix.mcs.anl.gov/mpi/mpich/) works just fine in our
     Linux boxes.


   First you should obtain the code gzipped-tarred file
`octopus<-version>.tar.gz' (this you probably have already done). The
code is freely available, and can be downloaded from
`http://www.tddft.org/programs/octopus'. There exists a `cvs' server,
which you can browse at
`http://nautilus.fis.uc.pt/cgi-bin/cvsweb.cgi/marques/octopus/'.  The
sources of the cvs version (in general more unstable the the _official_
distribution) may be downloaded by anonymous cvs access:

     prompt> cvs -d :pserver:anonymous@nautilus.fis.uc.pt:/server/cvsroot
             login
     
     prompt> cvs -d :pserver:anonymous@nautilus.fis.uc.pt:/server/cvsroot
             co marques/octopus

   Uncompress and untar it (`gzip -cd octopus<-version>.tar.gz | tar
-xvf -').  In the following, `OCTOPUS-HOME' denotes the home directory
of octopus, created by the `tar' command.

   The `OCTOPUS-HOME' contains the following subdirectories:
   * `build': contains files related to the building system. Not of
     real interest     for the plain user.

   * `CVS': May actually not be there; contains files related to the
     CVS - the     user does not need to know anything about it.

   * `doc': The documentation of `octopus' in _texinfo_ format.

   * `liboct': Small C library that handles the interface to     GSL
     and the parsing of the input file. It also contains some assorted
       routines that we didn't want to write in boring Fortran.

   * `samples': Sample input files for `octopus'.

   * `share': Made to contain "auxiliary" files eventually used by the
     code;     in practice now it contains the Troullier-Martins and
     Hartwigsen-Goedecker-Hutter     pseudopotential files.

   * `src': Fortran 90 source files. Note that these have to be
     preprocessed     before being fed to the Fortran compiler, so do
     not be scared by     all the # directives.

   Before configuring you can (should) setup a couple of options.
Although the configure script tries to guess your system settings for
you, we recommend that you set explicitly the default Fortran 90
compiler and the compiler options. In `bash' you would typically do:
     export F90=abf90
     export F90FLAGS="-O -YEXT_NAMES=LCS -YEXT_SFX=_"
   if you are using the Absoft Fortran 90 compiler on a linux machine.

   You can now run the configure script (`./configure').  (1) You can
use a fair amount of options to spice `octopus' to your own taste.  To
obtain a full list just type `./configure --help'. Some commonly used
options include:
   * `--prefix=PREFIX': Change the base installation dir of `octopus'
     to `PREFIX'. The executable will be installed in `PREFIX/bin',
     the libraries in `PREFIX/lib' and the documentation in
     `PREFIX/info'.    `PREFIX' defaults to the home directory of the
     user who runs `configure'.

   * `--with-fftw=DIR': Installation directory of the FFTW library.

   * `--with-lapack=DIR': Installation directory of the LAPACK and
     BLAS libraries.

   * `--with-gsl-prefix=DIR': Installation directory of the GSL
     library. The   libraries are expected to be in `DIR/lib' and the
     include   files in `DIR/include'. The value of `DIR' is usually
     found by   issuing the command `gsl-config --prefix'. (If the GSL
     library is   installed, the program `gsl-config' should be
     somewhere.)

   * `--enable-mpi': Builds the parallel version (MPI) of `octopus'.

   * `--enable-complex': Builds a version with complex wave-functions
     for the ground-state calculations (wave-functions are always
     complex for the evolution). This is needed when spinors are needed
     -- e.g. noncollinear magnetism is going to be considered, or the
     spin-orbit coupling term will be used.

   Run `make', and then `make install'. If everything went fine, you
should now be able to taste `octopus'. Depending on the options passed
to the configure script, some suffixes or prefixes could be added to
the generic name `octopus' -- i.e. `zoctopus' for the code compiled for
complex wave-functions, `zoctopus-mpi' for a parallel version of the
code compiled for complex wave-function, and so on.

   The program has been tested in the following platforms:
   * `i686*-linux-gnu': with the Absoft (http://www.absoft.com),   and
     the Intel (http://www.intel.com/software/products/compilers/)
     compiler.

   * `alphae*': both in Linux and in OSF/1 with Compaq's `fort'
     compiler.

   * `powerpc-ibm-aix4.3.3.0': with native `xlf90' compiler.
   If you manage to compile/run `octopus' on a different platform or
with a different compiler, please let us know so we can update the
list. Patches to solve compiler issues are also welcomed.

   Build the documentation in the format you prefer. Since you are
reading this, you already have it in some format. Due to the power of
`texinfo', a series of formats are available, namely `dvi', `html',
`pdf' and `info'. The `octopus.texi' source code of this document is in
the `OCTOPUS-HOME/doc' directory.

   ---------- Footnotes ----------

   (1) If you downloaded the cvs version, you will not find the
`configure' script.  In order to compile the development version you
will first have to run the GNU autotools.  This may be done by
executing the script `./autogen.sh'.  Note that you need to have
working versions of the `automake' (1.7.3), `autoconf' (2.57) and
`libtool' (1.4.3) programs (the versions we currently use are between
parentheses). Note that the `autogen.sh' script will likely fail if you
have (much) older versions of the autotools.


File: octopus.info,  Node: Troubleshooting,  Prev: Long instructions,  Up: Installation

Troubleshooting
===============

   If you are reading this it is because something went wrong. Let us
see if we can fix it ;)

   *Could not find library...*: This is probably the most common error
you can get. `octopus' uses three different libraries, `GSL', `FFTW',
and `BLAS'/`LAPACK'. We assume that you have already installed these
libraries but, for some reason, you were not able to compile the code.
So, what went wrong?
   * Did you pass the correct `--with-XXXX' (where XXXX is gsl, fftw or
      lapack in lowercase) to the configure script? If your libraries
     are   installed in a non-standard directory (like `/opt/lapack'),
     you will   have to pass the script the location of the library (in
     this example,   you could try `./configure
     --with-lapack=/opt/lapack'.

   * If you are working on an alpha station, do not forget that the
     `CXML'   library includes `BLAS' and `LAPACK', so it can be used by
      `octopus'. If needed, just set the correct path with
     `--with-lapack'.

   * If the configuration script can not find `FFTW', it is probable
     that   you did not compile `FFTW' with the same Fortran compiler
     or with the   same compiler options. The basic problem is that
     Fortran sometimes converts   the function names to uppercase, at
     other times to lowercase, and it can   add an "_" to them, or even
     two. Obviously all libraries and the program   have to use the
     same convention, so the best is to compile everything with   the
     same Fortran compiler/options. If you are a power user, you can
     check the   convention used by your compiler using the command `nm
     <library>'.


   *Whatever went wrong...*: Up to now, we cannot really make a list of
commonly found problems. So if something else went wrong, please
subscribe to `octopus-users' mailing list, and ask.


File: octopus.info,  Node: The input file,  Next: External utilities,  Prev: Installation,  Up: Top

Description of input options
****************************

* Menu:

* The parser::
* Input file options::


File: octopus.info,  Node: The parser,  Next: Input file options,  Prev: The input file,  Up: The input file

The parser
==========

   All input options should be in a file called "`inp'", in the
directory `octopus' is run from. Alternatively, if this file is not
found, standard input is read. For a fairly comprehensive example, just
look at the file `OCTOPUS_HOME/samples/inp'

   At the beginning of the program `liboct' reads the `inp' file,
parses it, and generates a list of variables that will be read by
`octopus' (note that the input is case independent).  There are two
kind of variables, scalar values (strings or numbers), and blocks (that
you may view as matrices). A scalar variable `var' can be defined by:
     var = exp
   `var' can contain any alphanumeric character plus "_", and `exp' can
be a quote delimited string, a number (integer, real, or complex), a
variable name, or a mathematical expression.  In the expressions all
arithmetic operators are supported ("a+b", "a-b", "a*b", "a/b"; for
exponentiation the C syntax "a^b" is used), and the following functions
can be used:
   * `sqrt(x)': The square root of `x'.

   * `exp(x)': The exponential of `x'.

   * `log(x)' or `ln(x)': The natural logarithm of `x'.

   * `log10(x)': Base 10 logarithm of `x'.

   * `sin(x)', `cos(x)', `tan(x)', `cot(x)',   `sec(x)', `csc(x)': The
     sinus, co-sinus, tangent, co-tangent,   secant and co-secant of
     `x'.

   * `asin(x)', `acos(x)', `atan(x)', `acot(x)',   `asec(x)',
     `acsc(x)': The inverse (arc-) sinus, co-sinus, tangent, co-tangent,
      secant and co-secant of `x'.

   * `sinh(x)', `cosh(x)', `tanh(x)', `coth(x)',   `sech(x)',
     `csch(x)': The hyperbolic sinus, co-sinus, tangent, co-tangent,
     secant and co-secant of `x'.

   * `asinh(x)', `acosh(x)', `atanh(x)', `acoth(x)',   `asech(x)',
     `acsch(x)': The inverse hyperbolic sinus, co-sinus, tangent,
     co-tangent,   secant and co-secant of `x'.
   You can also use any of the predefined variables:
   * `pi': 3.141592653589793, what else is there to say?

   * `e': The base of the natural logarithms.

   * `false' or `f' or `no': False in all its flavors. For the
     curious, `false' is defined as 0.

   * `true' or `t' or `yes': The truthful companion of `false'. For the
      curious, `true' is defined as 1.

   Blocks are defined as a collection of values, organised in row and
column format.  The syntax is the following:
     %var
       exp | exp | exp | ...
       exp | exp | exp | ...
       ...
     %
   Rows in a block are separated by a newline, while columns are
separated by the character "|". There may be any number of lines and any
number of columns in a block. Note also that each line can have a
different number of columns.

   If `octopus' tries to read a variable that is not defined in the
`inp' file, it automatically assigns to it a default value. All
variables read are output to the file "`out.oct'". If you are not sure
of what the program is reading, just take a look at it.  Everything
following the character "#" until the end of the line is considered a
comment and is simply cast into oblivion.


File: octopus.info,  Node: Input file options,  Prev: The parser,  Up: The input file

Input file options
==================

   `octopus' has quite a few options, that we will subdivide in
different groups.  After the name of the option, its type and default
value (when applicable) are given in parenthesis.

* Menu:

* Generalities::
* Species::
* Coordinates::
* Velocities::
* Mesh::
* States::
* Hamiltonian::
* Exchange and correlation::
* SCF::
* Unoccupied States::
* Time Dependent::
* Photo-electron spectrum::
* Geometry optimization::
* Function output for visualization::
* Spectrum calculations::
* Varia::


File: octopus.info,  Node: Generalities,  Next: Species,  Prev: Input file options,  Up: Input file options

Generalities
------------

   *   `SystemName' (string, 'system'): A string that identifies the
     current run. This parameter is used to build the names of some
     files generated by `octopus'.

   *   `Dimensions' (integer, 3): `octopus' can run in 1, 2 or 3
     dimensions, depending on the value of this variable. Note that not
     all options may be available in all cases.

   *   `CalculationMode' (integer, 1): It defines the type of
     simulation to perform. Options are:
        - `1': Start static calculation.

        - `2': Resume static calculation.

        - `3': Calculate unoccuppied states.

        - `4': Resume calculation of unoccupied states.

        - `5': Start time-dependent propagation.

        - `6': Resume time-dependent propagation.

        - `7': Start static polarizability calculation.

        - `8': Resume static polarizability calculation.

        - `10': Perform geometry minimization.

        - `11': Calculates the phonon spectrum of the system.

        - `12': _Optimum control_ mode (experimental).

        - `99': Print out an octopus recipe.

   * `Units' (string, 'a.u'): Atomic units seem to be the preferred
     system in the atomic and molecular physics community (despite the
     opinion of some of the authors of this program). Accordingly,
     atomic units can be used both for input and output. However, some
     people like using eV for energies and AA for lengths. This other
     system of units (the _convenient system_, in words of Prof. George
     F. Bertsch), can also be used. See the Frequently Asked Questions
     for some more details.  Valid options are:
        - `'a.u'': atomic units

        - `'eVA'': electron-volts/aangstro"m

   * `UnitsInput' (string, 'a.u.'): Same as `Units', but only refers to
     the values in the input file.

   * `UnitsOutput' (string, 'a.u.'): Same as `Units', but only refers
     to the values in the output files.

   *   `Verbose' (integer, 30): Verbosity level of the program. The
     higher, the more verbose `octopus' is. Current levels are:
        - `verbose <=  0': Silent mode. No output except fatal errors.

        - `verbose >   0': Warnings only.

        - `verbose >  20': Normal program info.

        - `verbose > 999': Debug mode. Issues a message every time the
          program enters an (important) subroutine, and prints the time
          it spend upon return.

   *   `DebugLevel' (integer, 3): Restricts the output of entry/exit
     subroutine information to the required level.



File: octopus.info,  Node: Species,  Next: Coordinates,  Prev: Generalities,  Up: Input file options

Species
-------

   * `Species' (block data): A specie is by definition an ion (nucleus
     + core electrons) described through a pseudo-potential, or a model
     potential.  The format of this block is different for 1, 2 or 3
     dimensions, and can be best understood through examples.

        * In 1D, or 2D, e.g.
                 %Species
                   'H'  | 1.0079 | 1 | "-1/sqrt(x^2 + 1)"
                 %
          This defines a species labelled '`H'' of weight `1.0079', and
          valence charge `1'. This "valence charge" is used to calculate
          the number of electrons present in the calculation: as many
          as indicated by the valence charges of the species, plus any
          extra charge specified by the user (*note States::). Last
          field may be any user defined potetial - use `x', `r' (and
          `y' in the 2D case) for the position of the electron relative
          to the species center.  For example. the potential often used
          in 1D calculations is the soft-Coulomb potential -Z/sqrt(x*x
          + 1).

        * In 3D, e.g.
                 %Species
                   'O'       | 15.9994 | 8   | "tm2"  | 1 | 1
                   'H'       |  1.0079 | 1   | "hgh"  | 0 | 0
                   'jelli01' | 23.2    | 8.0 |  5.0
                   'point01' | 32.3    | 2.0
                   'usdef'   | 1 | 8 | "1/2*r^2"
                 %
          In this case, we have 5 "species" present:
             - Oxygen labelled '`O''. Next number is the atomic mass
               (in atomic mass units), and third field, the atomic
               number (8, in this case).  Afterwards, "tm2" is the
               flavour of the pseudopotential: "tm2" stands for
               Troullier-Martins. This means the pseudopotential will be
               read from an `O.ascii' or `O.vps' file, either in the
               working directory or in the `OCTOPUS-HOME/share/PP/TM2'
               directory.  Next two numbers are the maximum
               _l_-component of the pseudo-potential to consider in the
               calculation, and the _l_-component to consider as local.

             - Hydrogen defined in the same way as Oxygen. In this
               case, however, the flavour is "hgh" standing for
               Hartwigsen-Goedecker-Hutter. Last two numbers are
               irrelevant.

             - All species whose label starts by 'jelli' are jellium
               spheres.  The other parameters are the weight, the
               nuclear charge, and the valence charge of the sphere.

             - All species whose label starts by 'point' are point
               charges.  The other parameters are the weight and the
               nuclear charge. In fact, point charges are implemented
               as _rather small_ jellium spheres, with zero valence
               charge.

             - All species whose label starts by 'usdef' are user
               defined potentials. The second parameter is the mass,
               whereas the third parameter is the 'valence charge',
               used to calculate the number of electrons.  Finally, the
               potential itself is defined by the fourth argument.  Use
               any of the `x', `y', `z' or `r' variables to define the
               potential.



File: octopus.info,  Node: Coordinates,  Next: Velocities,  Prev: Species,  Up: Input file options

Coordinates
-----------

   `octopus' successively tries to read the atomic coordinates from a
PDB file, a XYZ file, or else directly from the `inp' file.
   * `PDBCoordinates' (string, 'coords.pdb'):   Tries to read the
     atomic coordinates from the file `PDBCoordinates'.    The PDB
     (Protein Data Bank (http://www.rcsb.org/pdb/)) format is   quite
     complicated, and it goes well beyond the scope of this manual. You
      can find a comprehensive description in
     `http://www.rcsb.org/pdb/docs/format/pdbguide2.2/guide2.2_frame.html'.
      From the plethora of instructions defined in the PDB standard,
     `octopus'   only reads 2, `ATOM' and `HETATOM'. From these fields,
     it reads:
        - columns 13-16 : The specie; in fact `octopus' only cares
          about the first     letter - 'CA' and 'CB' will both refer to
          Carbon - so elements whose     chemical symbol has more than
          one letter can not be represented in this way.      So, if
          you want to run mercury ('Hg') please use one of the other
          two methods     to input the atomic coordinates,
          `XYZCoordinates' or `Coordinates'.

        - columns 18-21 : The residue. If residue is 'QM', the atom is
          treated     in Quantum Mechanics, otherwise it is simply
          treated as an external classical     point charge. Its charge
          will be given by columns 61-65.

        - columns 31-54 : The Cartesian coordinates. The Fortran format
          is     `'(3f8.3)''.

        - columns 61-65 : Classical charge of the atom. The Fortran
          format is     `'(f6.2)''.

   * `XYZCoordinates' (string, 'coords.xyz'):   If `PDBCoordinates' is
     not present, reads the atomic coordinates   from the XYZ file
     `XYZCoordinates'. The XYZ format is very simple,   as can be seem
     from this example for the CO molecule (in AA).
              2
                CO molecule in equilibrium
              C  -0.56415   0.0   0.0
              O   0.56415   0.0   0.0
       The first line of the file has an integer indicating the number
     of   atoms. The second can contain comments that are simply
     ignored by   `octopus'. Then there follows one line per each atom,
     containing   the chemical species and the Cartesian coordinates of
     the atom.

   * `Coordinates' (block data):   If neither a `XYZCoordinates' nor a
     `PDBCoordinates' was found,   `octopus' tries to read the
     coordinates for the atoms from the   block `Coordinates'. The
     format is quite straightforward:
              %Coordinates
                'C' | -0.56415 | 0.0 | 0.0 | no
                'O' |  0.56415 | 0.0 | 0.0 | no
              %
       The first line defines a Carbon atom at coordinates (`-0.56415',
      `0.0', `0.0'), that is _not_ allowed to move during   dynamical
     simulations. The second line has a similar meaning. This   block
     obviously defines a Carbon monoxide molecule, if the input   units
     are AA. Note that in this way it is possible to fix some of   the
     atoms (this is not possible when specifying the coordinates through
      a `PDBCoordinates' or `XYZCoordinates' file). It is always
     possible to fix _all_ atoms using the `MoveIons' directive.

   * `AdjustCoordinates' (logical, false):   If true, translates the
     atom coordinates so that the   geometrical centre of the molecule
     coincides with the zero of   the mesh, and rotates them, fixing
     the largest dimension   of the molecule to the axis defined
     through `MainAxis'.    Very useful when handling large and
     elongated molecules - try   it out!

   * `MainAxis' (block data):   Defines the axis to be used if
     `AdjustCoordinates' is true.    If not set defaults to the z axis.



File: octopus.info,  Node: Velocities,  Next: Mesh,  Prev: Coordinates,  Up: Input file options

Velocities
----------

   * `XYZVelocities' (string, 'velocities.xyz'):   `octopus' will try
     to read the starting velocities of the atoms from the XYZ file
     `XYZVelocities'.

   * `Velocities' (block data):   If `XYZVelocities' is not present,
     `octopus' will try to fetch the initial   atomic velocities from
     this block. If this block is not present, `octopus'   will reset
     the initial velocities to zero. The format of this block can be
     illustrated by this example:
              %Velocities
                'C'  | -1.7 | 0.0 | 0.0
                'O'  |  1.7 | 0.0 | 0.0
              %
       It describes one Carbon and one Oxygen moving at the relative
     velocity of `3.4', velocity units.  Note: It is important for the
     velocities to maintain the ordering in which the species were
     defined in the coordinates specifications.

   * `RandomVelocityTemp' (double, 0):   If this variable is present,
     `octopus' will assign random velocities to the atoms   following a
     Bolzmann distribution with temperature `RandomVelocityTemp'.



File: octopus.info,  Node: Mesh,  Next: States,  Prev: Velocities,  Up: Input file options

Mesh
----

   `octopus' uses a grid in real space to solve the Kohn-Sham equations.
The grid is equally-spaced, but the spacings can be different for each
Cartesian direction. The shape of the simulation region may also be
tuned to suit the geometric configuration of the system.

   * `BoxShape' (integer, sphere): It is the shape of the simulation
     box. The allowed values are:
        - `sphere' or `1': A sphere

        - `cylinder' or `2': A cylinder. The cylinder axis will be in
          the z direction

        - `minimum' or `3': Sum of spheres around each atom.

        - `parallelepiped' or `4': As the name indicates.
     For a 1D calculation, it would obviously always be a 1D "sphere".

   * `Radius' (double, 20.0 a.u.): If `BoxShape != parallelepiped'
     defines the radius of the spheres or of the cylinder.

   * `Lsize' (block data): In case `BoxShape = parallelepiped', this is
     assumed to be a block of the form:
              %Lsize
                sizex | sizey | sizez
              %
     where the `size*' are half of the lengths of the box in each
     direction.

   * `ZLength' (double, 1.0 a.u.): If `BoxShape == cylinder' is half
     the total length of the cylinder.

   * `Spacing' (double, 0.6 a.u.) or (block data): If the code is
     compiled in 1D mode or if `BoxShape != parallelepiped' defines the
     (constant) spacing between points in the grid. Otherwise, it is
     assumed to be a block of the form:
              %Spacing
                spacingx | spacingy | spacingz
              %

   * `DerivativesSpace' (integer, real_space) Defines in which space
     gradients and the Laplacian are calculated. Allowed values are:
        - `real_space' or `0': Derivatives are calculated in real-space
               using finite differences. The order of the derivative
          can be set with       `OrderDerivatives'.

        - `fourier_space' or `1': Derivatives are calculated in
          reciprocal space. Obviously this case implies cyclic boundary
          conditions,       so be careful.

   * `OrderDerivatives' (integer, 4): If `DerivativesSpace ==
     real_space' use a finite difference discretisation of this order
     for the derivatives, that is a `OrderDerivatives*2 + 1' formula.
     See (MISSING ARTICLE) for details.

   * `DoubleFFTParameter' (real, 2.0): For solving Poisson equation in
     Fourier space, and for applying the local potential in Fourier
     space, an auxiliary cubic mesh is built. This mesh will be larger
     than the circumscribed cube to the usual mesh by a factor
     `DoubleFFTParameter'. See the section that refers to Poisson
     equation, and to the local potential for details.

   * `FFTOptimize' (logical, true): Should `octopus' optimize the FFT
     dimension? In some cases, namely when using the split-operator, or
     Suzuki-Trotter propagators, this option should be turned off.



File: octopus.info,  Node: States,  Next: Hamiltonian,  Prev: Mesh,  Up: Input file options

States
------

   * `SpinComponents' (integer, 1): Defines the spin mode `octopus'
     will run in. Valid modes are:
        - `1': Spin-unpolarised calculation.

        - `2': Spin-polarised calculation (collinear spin). This mode
          will double the number of wave-functions necessary for a
          spin-unpolarised calculation.

        - `3': Non-collinear spin. This mode will double the number of
          wave-functions necessary for a spin-unpolarised calculation,
          and each of the wave-functions will be a 2-spinor.

   * `NumberKPoints' (integer, 1): If `octopus' was compiled for
     periodic systems, the number of _k_ points to use in the
     calculation. If `NumberKPoints == 1', use only the Gamma point.
     (Note: current version in fact does not implement this
     possibility. Setting this variable to more that 1 may lead to
     erroneous results.)

   * `ExcessCharge' (double, 1): The net charge of the system. A
     negative value means that we are adding electrons, while a
     positive value means we are taking electrons from the system.

   * `ExtraStates' (integer, 1): How many unoccupied states to use in
     the ground-state calculation. Note that this number is unrelated
     to `CalculationMode == 4'.

   * `Occupations' (block data): The occupation numbers of the orbitals
     can be fixed through the use of this variable. For example:
              %Occupations
                2.0 | 2.0 | 2.0 | 2.0 | 2.0
              %
     would fix the occupations of the five states to `2.0'. There must
     be as many columns as states in the calculation. If
     `SpinComponents == 2' this block should contain two lines, one for
     each spin channel.  This variable is very useful when dealing with
     highly symmetric small systems (like an open shell atom), for it
     allows us to fix the occupation numbers of degenerate states in
     order to help `octopus' to converge. This is to be used in
     conjuction with `ExtraStates'. For example, to calculate the
     carbon atom, one would do:
            ExtraStates=2
            %Occupations
                2 | 2/3 | 2/3 | 2/3
              %

   * `ElectronicTemperature' (double, 0.0): If `Occupations' is not
     set, `ElectronicTemperature' is the temperature in the Fermi-Dirac
     function used to distribute the electrons among the existing
     states.



File: octopus.info,  Node: Hamiltonian,  Next: Exchange and correlation,  Prev: States,  Up: Input file options

Hamiltonian
-----------

   * `NonInteractingElectrons' (logical, false):   If `true', treat the
     electrons as non-interacting, i.e. neglect both   Hartree and
     exchange-correlation contributions to the Kohn-Sham potential.
     A probable choice for one-electron problems.

   * `ClassicPotential' (logical, false): If `true', add to the
     external potential the potential generated by the point charges
     read from the PDB input (see `PBDCoordinates').

   * `LocalPotentialSpace' (integer, fourier_space): If
     `fourier_space', generate the local part of the pseudo-potential
     in Fourier space; Otherwise do it directly in real space. The
     auxiliary box defined via the `DoubleFFTParameter' is used for
     this purpose.

   * `NonLocalPotentialSpace' (integer, real_space): If `fourier_space'
     generate the non-local part of the pseudo-potential in Fourier
     space; Otherwise do it directly in real space. _Generating the
     potential in Fourier space seems to reduce the egg-box effect but
     this option has not been extensively tested._

   * `GridRefinement' (integer, 3): If `NonLocalPotentialSpace ==
     fourier_space', a grid refinement technique is applied to reduce
     the error in the calculation of the non-local projectors. This
     variable defines the number of points to interpolate between the
     normal mesh points, in order to apply this  method. _This seems to
     reduce the egg-box effect but this option has not been extensively
     tested._

   * `RelativisticCorrection' (integer, 0):   The default value means
     that _no_ relativistic correction is used. To   include spin-orbit
     coupling turn `RelativisticCorrection' to 1 (this will only   work
     when using an executable compiled for complex wave-functions.)



File: octopus.info,  Node: Exchange and correlation,  Next: SCF,  Prev: Hamiltonian,  Up: Input file options

Exchange and correlation
------------------------

   The exchange-correlation functional is controlled by the 4
parameters `XFamily', `XFunctional', `CFamily' and `CFunctional'.
Obviously, the `X' parameters control the exchange part of the
functional, while the `C' parameters control the correlation. The
possible values are:

   * `XFamily == 'ZER'': No exchange.

   * `XFamily == 'LDA'': Local density approximation.
        - `XFunctional == 'NREL'': Non-relativistic exchange.

        - `XFunctional ==  'REL'': Relativistic exchange.

   * `XFamily == 'GGA'': Generalised gradient approximations.
        - `XFunctional ==  'PBE'':  J.P.Perdew, K.Burke and M.Ernzerhof,
             	PRL *77*, 3865 (1996).

        - `XFunctional == 'PBER'': PBE with some relativistic
          corrections.

        - `XFunctional == 'LB94'': van Leeuwen and Baerends functional.

   * `XFamily == 'KLI'': Optimised effective potential method within
     the Krieger, Lee and Iafrate approximation.
        - `XFunctional ==   'X'': Exact exchange functional.

        - `XFunctional == 'SIC'': Self interaction corrected LDA.

   And now comes the correlation variables:

   * `CFamily == 'ZER'': No correlation.

   * `CFamily == 'LDA'': Local density approximation.
        - `CFunctional ==   'PZ81'':  Perdew and Zunger,       PRB
          *23*, 5075 (1981).

        - `CFunctional == 'PW92'': J.P.Perdew and Y.Wang,       PRB
          *45*, 13244 (1992).

   * `CFamily == 'GGA'': Generalised gradient approximations.
        - `CFunctional == 'PBE'': J.P.Perdew, K.Burke and M.Ernzerhof,
            	PRL *77*, 3865 (1996).

   * `CFamily == 'KLI'': Optimised effective potential method within
     the Krieger, Lee and Iafrate approximation.
        - `CFunctional == 'SIC'': Self interaction corrected LDA.

